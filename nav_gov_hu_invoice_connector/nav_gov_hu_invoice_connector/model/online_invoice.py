#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Jun  6 15:33:22 2022 by generateDS.py version 2.39.2.
# Python 3.7.3 (default, Jan 22 2021, 20:04:44)  [GCC 8.3.0]
#
# Command line options:
#   ('-o', 'online_invoice.py')
#   ('-c', 'catalog.xml')
#   ('-s', 'invoice_subclass')
#   ('--external-encoding', 'utf-8')
#   ('--export', 'write etree literal')
#   ('--output-directory', 'generatedDS')
#
# Command line arguments:
#   onlineInvoice.xsd
#
# Command line:
#   /home/frappe/.local/bin/generateDS -o "online_invoice.py" -c "catalog.xml" -s "invoice_subclass" --external-encoding="utf-8" --export="write etree literal" --output-directory="generatedDS" onlineInvoice.xsd
#
# Current working directory (os.getcwd()):
#   v3
#
import datetime
import sys

import pytz

try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ModulenotfoundExp_ :
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            # if input_data.microsecond == 0:
            #     _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
            #         input_data.year,
            #         input_data.month,
            #         input_data.day,
            #         input_data.hour,
            #         input_data.minute,
            #         input_data.second,
            #     )
            # else:
            #     _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
            #         input_data.year,
            #         input_data.month,
            #         input_data.day,
            #         input_data.hour,
            #         input_data.minute,
            #         input_data.second,
            #         ('%f' % (float(input_data.microsecond) / 1000000))[2:],
            #     )
            # if input_data.tzinfo is not None:
            #     tzoff = input_data.tzinfo.utcoffset(input_data)
            #     if tzoff is not None:
            #         total_seconds = tzoff.seconds + (86400 * tzoff.days)
            #         if total_seconds == 0:
            #             _svalue += 'Z'
            #         else:
            #             if total_seconds < 0:
            #                 _svalue += '-'
            #                 total_seconds *= -1
            #             else:
            #                 _svalue += '+'
            #             hours = total_seconds // 3600
            #             minutes = (total_seconds - (hours * 3600)) // 60
            #             _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            # return _svalue
            return input_data.isoformat()[:-3] + "Z"
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class AnnulmentCodeType(str, Enum):
    """AnnulmentCodeType -- Technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s k
    ó
    d t
    í
    pusa
    Technical annulment code type
    
    """
    ERRATIC_DATA='ERRATIC_DATA' # Hibás adattartalom miatti technikai érvénytelenítésTechnical annulment due to erratic data content
    ERRATIC_INVOICE_NUMBER='ERRATIC_INVOICE_NUMBER' # Hibás számlaszám miatti technikai érvénytelenítésTechnical annulment due to erratic invoice number
    ERRATIC_INVOICE_ISSUE_DATE='ERRATIC_INVOICE_ISSUE_DATE' # Hibás számla kiállítási dátum miatti technikai érvénytelenítésTechnical annulment due to erratic invoice issue date
    ERRATIC_ELECTRONIC_HASH_VALUE='ERRATIC_ELECTRONIC_HASH_VALUE' # Hibás elektronikus számla hash érték miatti technikai érvénytelenítésTechnical annulment due to erratic electronic invoice hash value


class AnnulmentVerificationStatusType(str, Enum):
    """AnnulmentVerificationStatusType -- Technikai
    é
    rv
    é
    nytelen
    í
    t
    ő
    k
    é
    r
    é
    sek j
    ó
    v
    á
    hagy
    á
    si st
    á
    tusza
    Verification status of technical annulment requests
    
    """
    NOT_VERIFIABLE='NOT_VERIFIABLE' # A technikai érvénytelenítés kliens hiba miatt nem hagyható jóváThe technical annulment is not verifiable due to client error
    VERIFICATION_PENDING='VERIFICATION_PENDING' # A technikai érvénytelenítés jóváhagyásra várThe technical annulment is awaiting verification
    VERIFICATION_DONE='VERIFICATION_DONE' # A technikai érvénytelenítés jóváhagyásra kerültThe technical annulment has been verified
    VERIFICATION_REJECTED='VERIFICATION_REJECTED' # A technikai érvénytelenítés elutasításra kerültThe technical annulment has been rejected


class BusinessResultCodeType(str, Enum):
    """BusinessResultCodeType -- Ü
    zleti eredm
    é
    ny k
    ó
    d t
    í
    pus
    Business result code type
    
    """
    ERROR='ERROR' # HibaError
    WARN='WARN' # FigyelmeztetésWarn
    INFO='INFO' # TájékoztatásInformation


class CustomerVatStatusType(str, Enum):
    """CustomerVatStatusType -- Vev
    ő
    Á
    FA szerinti st
    á
    tusz t
    í
    pusa
    Customers status type by VAT
    
    """
    DOMESTIC='DOMESTIC' # Belföldi ÁFA alanyDomestic VAT subject
    OTHER='OTHER' # Egyéb (belföldi nem ÁFA alany, nem természetes személy, külföldi ÁFA alany és külföldi nem ÁFA alany, nem természetes személy)Other (domestic non-VAT subject, non-natural person, foreign VAT subject and foreign non-VAT subject, non-natural person)
    PRIVATE_PERSON='PRIVATE_PERSON' # Nem ÁFA alany (belföldi vagy külföldi) természetes személyNon-VAT subject (domestic or foreign) natural person


class FunctionCodeType(str, Enum):
    """FunctionCodeType -- Funkci
    ó
    k
    ó
    d t
    í
    pus
    Function code type
    
    """
    OK='OK' # Sikeres műveletSuccessful operation
    ERROR='ERROR' # HibaError


class IncorporationType(str, Enum):
    """IncorporationType -- Gazdas
    á
    gi t
    í
    pus
    Incorporation type
    
    """
    ORGANIZATION='ORGANIZATION' # Gazdasági társaságEconomical company
    SELF_EMPLOYED='SELF_EMPLOYED' # Egyéni vállalkozóSelf employed private entrepreneur
    TAXABLE_PERSON='TAXABLE_PERSON' # Adószámos magánszemélyPrivate person with tax number


class InvoiceAppearanceType(str, Enum):
    """InvoiceAppearanceType -- Sz
    á
    mla megjelen
    é
    si form
    á
    ja t
    í
    pus
    Form of appearance of the invoice type
    
    """
    PAPER='PAPER' # Papír alapú számlaInvoice issued on paper
    ELECTRONIC='ELECTRONIC' # Elektronikus formában előállított, nem EDI számlaElectronic invoice (non-EDI)
    EDI='EDI' # EDI számlaEDI invoice
    UNKNOWN='UNKNOWN' # A szoftver nem képes azonosítani vagy a kiállításkor nem ismertThe software cannot be identify the form of appearance of the invoice or it is unknown at the time of issue


class InvoiceCategoryType(str, Enum):
    """InvoiceCategoryType -- A sz
    á
    mla t
    í
    pusa
    Type of invoice
    
    """
    NORMAL='NORMAL' # Normál (nem egyszerűsített és nem gyűjtő) számlaNormal (not simplified and not aggregate) invoice
    SIMPLIFIED='SIMPLIFIED' # Egyszerűsített számlaSimplified invoice
    AGGREGATE='AGGREGATE' # GyűjtőszámlaAggregate invoice


class InvoiceDirectionType(str, Enum):
    """InvoiceDirectionType -- Kimen
    ő
    vagy bej
    ö
    v
    ő
    sz
    á
    mla keres
    é
    si param
    é
    tere
    Inbound or outbound invoice query parameter
    
    """
    INBOUND='INBOUND' # Bejövő (vevő oldali) számla keresési paramétereInbound (customer side) invoice query parameter
    OUTBOUND='OUTBOUND' # Kimenő (kiállító oldali) számla keresési paramétereOutbound (supplier side) invoice query parameter


class InvoiceStatusType(str, Enum):
    """InvoiceStatusType -- A sz
    á
    mla feldolgoz
    á
    si st
    á
    tusza
    Processing status of the invoice
    
    """
    RECEIVED='RECEIVED' # BefogadvaReceived
    PROCESSING='PROCESSING' # Feldolgozás alattProcessing
    SAVED='SAVED' # ElmentveSaved
    DONE='DONE' # KészDone
    ABORTED='ABORTED' # KihagyvaAborted


class LanguageType(str, Enum):
    """LanguageType -- Nyelv megnevez
    é
    s t
    í
    pus
    Language naming type
    
    """
    HU='HU' # Magyar nyelvHungarian language
    EN='EN' # Angol nyelvEnglish language
    DE='DE' # Német nyelvGerman language


class LineNatureIndicatorType(str, Enum):
    """LineNatureIndicatorType -- Adott t
    é
    telsor term
    é
    k
    é
    rt
    é
    kes
    í
    t
    é
    s vagy szolg
    á
    ltat
    á
    s ny
    ú
    jt
    á
    s jelleg
    é
    nek jelz
    é
    se
    Indication of the nature of the supply of goods or services on a given line
    
    """
    PRODUCT='PRODUCT' # TermékértékesítésSupply of goods
    SERVICE='SERVICE' # Szolgáltatás nyújtásSupply of services
    OTHER='OTHER' # Egyéb, nem besorolhatóOther, non-qualifiable


class LineOperationType(str, Enum):
    """LineOperationType -- A sz
    á
    mlat
    é
    tel m
    ó
    dos
    í
    t
    á
    s t
    í
    pusa
    Invoice line modification type
    
    """
    CREATE='CREATE'
    MODIFY='MODIFY'


class ManageAnnulmentOperationType(str, Enum):
    """ManageAnnulmentOperationType -- Technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s m
    ű
    veleti t
    í
    pus
    Technical annulment operation type
    
    """
    ANNUL='ANNUL' # Korábbi adatszolgáltatás technikai érvénytelenítéseTechnical annulment of previous exchange


class ManageInvoiceOperationType(str, Enum):
    """ManageInvoiceOperationType -- Sz
    á
    mlam
    ű
    velet t
    í
    pus
    Invoice operation type
    
    """
    CREATE='CREATE' # Adatszolgáltatás eredeti számlárólOriginal invoice exchange
    MODIFY='MODIFY' # Adatszolgáltatás az eredeti számlát módosító okiratrólModification invoice exchange
    STORNO='STORNO' # Adatszolgáltatás az eredeti számla érvénytelenítésérőlExchange concerning invoice invalidation


class MarginSchemeType(str, Enum):
    """MarginSchemeType -- K
    ü
    l
    ö
    nb
    ö
    zet szerinti szab
    á
    lyoz
    á
    s t
    í
    pus
    Field type for inputting margin-scheme taxation
    
    """
    TRAVEL_AGENCY='TRAVEL_AGENCY' # Utazási irodákTravel agencies
    SECOND_HAND='SECOND_HAND' # Használt cikkekSecond-hand goods
    ARTWORK='ARTWORK' # MűalkotásokWorks of art
    ANTIQUES='ANTIQUES' # Gyűjteménydarabok és régiségekCollector’s items and antiques


class MetricTypeType(str, Enum):
    """MetricTypeType -- Metrika t
    í
    pus
    á
    nak le
    í
    r
    ó
    ja
    Metric's descriptor type
    
    """
    COUNTER='COUNTER' # Növekmény típusú metrikaIncremental type metric
    GAUGE='GAUGE' # Pillanatkép típusú metrikaSnapshot type metric
    HISTOGRAM='HISTOGRAM' # Kvantilis típusú, eloszlást mérő metrikaQuantile type, dispersion sampler metric
    SUMMARY='SUMMARY' # Összegző érték típusú metrikaSum value type metric


class OriginalRequestVersionType(str, Enum):
    """OriginalRequestVersionType -- A lek
    é
    rdezett sz
    á
    mla requestVersion
    é
    rt
    é
    ke
    Request version value of the queried invoice
    
    """
    _1_0='1.0'
    _1_1='1.1'
    _2_0='2.0'
    _3_0='3.0'


class PaymentMethodType(str, Enum):
    """PaymentMethodType -- Fizet
    é
    s m
    ó
    dja
    Method of payment
    
    """
    TRANSFER='TRANSFER' # Banki átutalásBank transfer
    CASH='CASH' # KészpénzCash
    CARD='CARD' # Bankkártya, hitelkártya, egyéb készpénz helyettesítő eszközDebit card, credit card, other cash-substitute payment instrument
    VOUCHER='VOUCHER' # Utalvány, váltó, egyéb pénzhelyettesítő eszközVoucher, bill of exchange, other non-cash payment instrument
    OTHER='OTHER' # EgyébOther


class ProductCodeCategoryType(str, Enum):
    """ProductCodeCategoryType -- A term
    é
    kk
    ó
    d fajt
    á
    j
    á
    nak jel
    ö
    l
    é
    s
    é
    re szolg
    á
    l
    ó
    t
    í
    pus
    The type used to mark the kind of product code
    
    """
    VTSZ='VTSZ' # Vámtarifa szám VTSZCustoms tariff number CTN
    SZJ='SZJ' # Szolgáltatás jegyzék szám SZJBusiness service list number BSL
    KN='KN' # KN kód (Kombinált Nómenklatúra, 2658/87/EGK rendelet I. melléklete)CN code (Combined Nomenclature, 2658/87/ECC Annex I)
    AHK='AHK' # A Jövedéki törvény (2016. évi LXVIII. tv) szerinti e-TKO adminisztratív hivatkozási kódja AHKAdministrative reference code of e-TKO defined in the Act LXVIII of 2016 on Excise Duties
    CSK='CSK' # A termék 343/2011. (XII. 29) Korm. rendelet 1. sz. melléklet A) cím szerinti csomagolószer-katalógus kódja (CsK kód)Packaging product catalogue code of the product according to the Title A) in the Schedule No.1 of the Government Decree No. 343/2011. (XII. 29.)
    KT='KT' # A termék 343/2011. (XII. 29) Korm. rendelet 1. sz. melléklet B) cím szerinti környezetvédelmi termékkódja (Kt kód)Environmental protection product code of the product according to the Title B) in the Schedule No.1 of the Government Decree No. 343/2011. (XII. 29.)
    EJ='EJ' # Építményjegyzék számClassification of Inventory of Construction
    TESZOR='TESZOR' # A Termékek és Szolgáltatások Osztályozási Rendszere (TESZOR) szerinti termékkód - 451/2008/EK rendeletProduct code according to the TESZOR (Hungarian Classification of Goods and Services), Classification of Product by Activity, CPA - regulation 451/2008/EC
    OWN='OWN' # A vállalkozás által képzett termékkódThe own product code of the enterprise
    OTHER='OTHER' # Egyéb termékkódOther product code


class ProductFeeMeasuringUnitType(str, Enum):
    """ProductFeeMeasuringUnitType -- D
    í
    jt
    é
    tel egys
    é
    g t
    í
    pus
    Unit of the rate type
    
    """
    DARAB='DARAB' # DarabPiece
    KG='KG' # KilogrammKilogram


class ProductFeeOperationType(str, Enum):
    """ProductFeeOperationType -- Term
    é
    kd
    í
    j
    ö
    sszes
    í
    t
    é
    s t
    í
    pus
    Product fee summary type
    
    """
    REFUND='REFUND' # VisszaigénylésRefund
    DEPOSIT='DEPOSIT' # Raktárba szállításDeposit


class ProductStreamType(str, Enum):
    """ProductStreamType -- Term
    é
    k
    á
    ram t
    í
    pus
    Product stream
    
    """
    BATTERY='BATTERY' # AkkumulátorBattery
    PACKAGING='PACKAGING' # CsomagolószerPackaging products
    OTHER_PETROL='OTHER_PETROL' # Egyéb kőolajtermékOther petroleum product
    ELECTRONIC='ELECTRONIC' # Az elektromos, elektronikai berendezésThe electric appliance, electronic equipment
    TIRE='TIRE' # GumiabroncsTire
    COMMERCIAL='COMMERCIAL' # Reklámhordozó papírCommercial printing paper
    PLASTIC='PLASTIC' # Az egyéb műanyag termékOther plastic product
    OTHER_CHEMICAL='OTHER_CHEMICAL' # Egyéb vegyipari termékOther chemical product
    PAPER='PAPER' # Irodai papírPaper stationery


class QueryOperatorType(str, Enum):
    """QueryOperatorType -- Rel
    á
    ci
    ó
    s m
    ű
    velet t
    í
    pus
    Relational operator type
    
    """
    EQ='EQ' # EgyenlőségEquals
    GT='GT' # Nagyobb mint relációGreater than relation
    GTE='GTE' # Nagyobb vagy egyenlő relációGreater or equals relation
    LT='LT' # Kisebb mint relációLess than relation
    LTE='LTE' # Kisebb vagy egyenlő relációLess or equals relation


class RequestStatusType(str, Enum):
    """RequestStatusType -- A k
    é
    r
    é
    s feldolgoz
    á
    si st
    á
    tusza
    Processing status of the request
    
    """
    RECEIVED='RECEIVED' # BefogadvaReceived
    PROCESSING='PROCESSING' # Feldolgozás alattProcessing
    SAVED='SAVED' # ElmentveSaved
    FINISHED='FINISHED' # Feldolgozás befejezveFinished processing
    NOTIFIED='NOTIFIED' # LekérdezveNotified


class SoftwareOperationType(str, Enum):
    """SoftwareOperationType -- A számlázóprogram működési típusa
    (lokális program vagy online számlázó szolgáltatás)
    Billing operation type (local program or online billing service)
    
    """
    LOCAL_SOFTWARE='LOCAL_SOFTWARE' # Lokális programLocal program
    ONLINE_SERVICE='ONLINE_SERVICE' # Online számlázó szolgáltatásOnline billing service


class SourceType(str, Enum):
    """SourceType -- Az adatszolgáltatás forrása
    Data exchange source
    
    """
    WEB='WEB' # Webes adatszolgáltatásWeb exchange
    XML='XML' # Kézi XML feltöltésManual XML upload
    MGM='MGM' # Gép-gép adatkapcsolati adatszolgáltatásMachine-to-machine exchange
    OPG='OPG' # Online pénztárgépes adatszolgáltatásOnline cash register exchange
    OSZ='OSZ' # NAV online számlázóNTCA online invoicing


class TakeoverType(str, Enum):
    """TakeoverType -- Az átvállalás adatait tartalmazó típus
    Field type for data of takeover
    
    """
    _0_1='01' # A 2011. évi LXXXV. tv. 14. § (4) bekezdés szerint az eladó (első belföldi forgalomba hozó) vállalja át a vevő termékdíj-kötelezettségétThe supplier takes over buyer’s product fee liability on the basis of Paragraph (4), Section 14 of the Act LXXXV of 2011
    _0_2_AA='02_aa' # A 2011. évi LXXXV. tv. 14. § (5) aa) alpontja szerint a vevő szerződés alapján átvállalja az eladó termékdíj-kötelezettségétOn the basis of contract, the buyer takes over supplier’s product fee liability on the basis of sub-point aa), Paragraph (5), Section 14 of the Act LXXXV of 2011
    _0_2_AB='02_ab'
    _0_2_B='02_b'
    _0_2_C='02_c'
    _0_2_D='02_d'
    _0_2_EA='02_ea'
    _0_2_EB='02_eb'
    _0_2_FA='02_fa'
    _0_2_FB='02_fb'
    _0_2_GA='02_ga'
    _0_2_GB='02_gb'


class TaxpayerAddressTypeType(str, Enum):
    """TaxpayerAddressTypeType -- Adózói cím típus
    Taxpayer address_list type
    
    """
    HQ='HQ' # SzékhelyHeadquarter
    SITE='SITE' # TelephelySite office
    BRANCH='BRANCH' # FióktelepBranch office


class TechnicalResultCodeType(str, Enum):
    """TechnicalResultCodeType -- Technikai eredmény kód típus
    Technical result code type
    
    """
    CRITICAL='CRITICAL' # Kritikus hibaCritical error
    ERROR='ERROR' # HibaError


class UnitOfMeasureType(str, Enum):
    """UnitOfMeasureType -- Mennyiség egység típus
    Unit of measure type
    
    """
    PIECE='PIECE' # DarabPiece
    KILOGRAM='KILOGRAM' # KilogrammKilogram
    TON='TON' # Metrikus tonnaMetric ton
    KWH='KWH' # Kilowatt óraKilowatt hour
    DAY='DAY' # NapDay
    HOUR='HOUR' # ÓraHour
    MINUTE='MINUTE' # PercMinute
    MONTH='MONTH' # HónapMonth
    LITER='LITER' # LiterLiter
    KILOMETER='KILOMETER' # KilométerKilometer
    CUBIC_METER='CUBIC_METER' # KöbméterCubic meter
    METER='METER' # MéterMeter
    LINEAR_METER='LINEAR_METER' # FolyóméterLinear meter
    CARTON='CARTON' # KartonCarton
    PACK='PACK' # CsomagPack
    OWN='OWN' # Saját mennyiségi egység megnevezésOwn unit of measure


class BasicHeaderType(GeneratedsSuper):
    """BasicHeaderType -- A kérés tranzakcionális adatai
    Transactional data of the request
    requestId -- A kérés/válasz azonosítója, minden üzenetváltásnál - adószámonként - egyedi
    Identifier of the request/response, unique with the taxnumber in every data exchange transaction
    timestamp -- A kérés/válasz keletkezésének UTC ideje
    UTC time of the request/response
    requestVersion -- A kérés/válasz verziószáma, hogy a hívó melyik interfész verzió szerint küld adatot
     és várja a választ
    Request version number, indicating which datastructure the client sends data in, and in which the response is expected
    headerVersion -- A header verziószáma
    Header version number
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, requestId=None, timestamp=None, requestVersion=None, headerVersion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "common"
        self.requestId = requestId
        self.validate_EntityIdType(self.requestId)
        self.requestId_nsprefix_ = "common"
        if isinstance(timestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timestamp
        self.timestamp = initvalue_
        self.timestamp_nsprefix_ = "common"
        self.requestVersion = requestVersion
        self.validate_AtomicStringType15(self.requestVersion)
        self.requestVersion_nsprefix_ = "common"
        self.headerVersion = headerVersion
        self.validate_AtomicStringType15(self.headerVersion)
        self.headerVersion_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasicHeaderType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasicHeaderType.subclass:
            return BasicHeaderType.subclass(*args_, **kwargs_)
        else:
            return BasicHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_requestId(self):
        return self.requestId
    def set_requestId(self, requestId):
        self.requestId = requestId
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def get_requestVersion(self):
        return self.requestVersion
    def set_requestVersion(self, requestVersion):
        self.requestVersion = requestVersion
    def get_headerVersion(self):
        return self.headerVersion
    def set_headerVersion(self, headerVersion):
        self.headerVersion = headerVersion
    def validate_EntityIdType(self, value):
        result = True
        # Validate type EntityIdType, a restriction on AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityIdType_patterns_, ))
                result = False
        return result
    validate_EntityIdType_patterns_ = [['^([+a-zA-Z0-9_]{1,30})$']]
    def validate_GenericTimestampType(self, value):
        result = True
        # Validate type GenericTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not self.gds_validate_simple_patterns(
                    self.validate_GenericTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_GenericTimestampType_patterns_, ))
                result = False
        return result
    validate_GenericTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,3})?Z)$']]
    def validate_AtomicStringType15(self, value):
        result = True
        # Validate type AtomicStringType15, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on AtomicStringType15' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on AtomicStringType15' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.requestId is not None or
            self.timestamp is not None or
            self.requestVersion is not None or
            self.headerVersion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicHeaderType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BasicHeaderType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BasicHeaderType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasicHeaderType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BasicHeaderType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BasicHeaderType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicHeaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.requestId is not None:
            namespaceprefix_ = self.requestId_nsprefix_ + ':' if (UseCapturedNS_ and self.requestId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequestId>%s</%srequestId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.requestId), input_name='requestId')), namespaceprefix_ , eol_))
        if self.timestamp is not None:
            namespaceprefix_ = self.timestamp_nsprefix_ + ':' if (UseCapturedNS_ and self.timestamp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimestamp>%s</%stimestamp>%s' % (namespaceprefix_ , self.gds_format_datetime(self.timestamp, input_name='timestamp'), namespaceprefix_ , eol_))
        if self.requestVersion is not None:
            namespaceprefix_ = self.requestVersion_nsprefix_ + ':' if (UseCapturedNS_ and self.requestVersion_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequestVersion>%s</%srequestVersion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.requestVersion), input_name='requestVersion')), namespaceprefix_ , eol_))
        if self.headerVersion is not None:
            namespaceprefix_ = self.headerVersion_nsprefix_ + ':' if (UseCapturedNS_ and self.headerVersion_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sheaderVersion>%s</%sheaderVersion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.headerVersion), input_name='headerVersion')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='BasicHeaderType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        if self.requestId is not None:
            requestId_ = self.requestId
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}requestId').text = self.gds_format_string(requestId_)
        if self.timestamp is not None:
            timestamp_ = self.timestamp
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}timestamp').text = self.gds_format_datetime(timestamp_)
        if self.requestVersion is not None:
            requestVersion_ = self.requestVersion
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}requestVersion').text = self.gds_format_string(requestVersion_)
        if self.headerVersion is not None:
            headerVersion_ = self.headerVersion
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}headerVersion').text = self.gds_format_string(headerVersion_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='BasicHeaderType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.requestId is not None:
            showIndent(outfile, level)
            outfile.write('requestId=%s,\n' % self.gds_encode(quote_python(self.requestId)))
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
        if self.requestVersion is not None:
            showIndent(outfile, level)
            outfile.write('requestVersion=%s,\n' % self.gds_encode(quote_python(self.requestVersion)))
        if self.headerVersion is not None:
            showIndent(outfile, level)
            outfile.write('headerVersion=%s,\n' % self.gds_encode(quote_python(self.headerVersion)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'requestId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'requestId')
            value_ = self.gds_validate_string(value_, node, 'requestId')
            self.requestId = value_
            self.requestId_nsprefix_ = child_.prefix
            # validate type EntityIdType
            self.validate_EntityIdType(self.requestId)
        elif nodeName_ == 'timestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.timestamp = dval_
            self.timestamp_nsprefix_ = child_.prefix
            # validate type GenericTimestampType
            self.validate_GenericTimestampType(self.timestamp)
        elif nodeName_ == 'requestVersion':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'requestVersion')
            value_ = self.gds_validate_string(value_, node, 'requestVersion')
            self.requestVersion = value_
            self.requestVersion_nsprefix_ = child_.prefix
            # validate type AtomicStringType15
            self.validate_AtomicStringType15(self.requestVersion)
        elif nodeName_ == 'headerVersion':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'headerVersion')
            value_ = self.gds_validate_string(value_, node, 'headerVersion')
            self.headerVersion = value_
            self.headerVersion_nsprefix_ = child_.prefix
            # validate type AtomicStringType15
            self.validate_AtomicStringType15(self.headerVersion)
# end class BasicHeaderType


class BasicRequestType(GeneratedsSuper):
    """BasicRequestType -- Alap k
    é
    r
    é
    s adatok
    Basic request data
    header -- A k
    é
    r
    é
    s tranzakcion
    á
    lis adatai
    Transactional data of the request
    user -- A k
    é
    r
    é
    s authentik
    á
    ci
    ó
    s adatai
    Authentication data of the request
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, header=None, user=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.header = header
        self.header_nsprefix_ = None
        self.user = user
        self.user_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasicRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasicRequestType.subclass:
            return BasicRequestType.subclass(*args_, **kwargs_)
        else:
            return BasicRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_header(self):
        return self.header
    def set_header(self, header):
        self.header = header
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.header is not None or
            self.user is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicRequestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BasicRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BasicRequestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasicRequestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BasicRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BasicRequestType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            namespaceprefix_ = self.header_nsprefix_ + ':' if (UseCapturedNS_ and self.header_nsprefix_) else ''
            self.header.export(outfile, level, namespaceprefix_, namespacedef_='', name_='header', pretty_print=pretty_print)
        if self.user is not None:
            namespaceprefix_ = self.user_nsprefix_ + ':' if (UseCapturedNS_ and self.user_nsprefix_) else ''
            self.user.export(outfile, level, namespaceprefix_, namespacedef_='', name_='user', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BasicRequestType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.header is not None:
            header_ = self.header
            header_.to_etree(element, name_='header', mapping_=mapping_, nsmap_=nsmap_)
        if self.user is not None:
            user_ = self.user
            user_.to_etree(element, name_='user', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='BasicRequestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.header is not None:
            showIndent(outfile, level)
            outfile.write('header=model_.BasicHeaderType(\n')
            self.header.exportLiteral(outfile, level, name_='header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user=model_.UserHeaderType(\n')
            self.user.exportLiteral(outfile, level, name_='user')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'header':
            obj_ = BasicHeaderType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'user':
            obj_ = UserHeaderType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.user = obj_
            obj_.original_tagname_ = 'user'
# end class BasicRequestType


class BasicResponseType(GeneratedsSuper):
    """BasicResponseType -- Alap v
    á
    lasz adatok
    Basic response data
    header -- A v
    á
    lasz tranzakcion
    á
    lis adatai
    Transactional data of the response
    result -- Alap v
    á
    laszeredm
    é
    ny adatok
    Basic result data
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, header=None, result=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.header = header
        self.header_nsprefix_ = None
        self.result = result
        self.result_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasicResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasicResponseType.subclass:
            return BasicResponseType.subclass(*args_, **kwargs_)
        else:
            return BasicResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_header(self):
        return self.header
    def set_header(self, header):
        self.header = header
    def get_result(self):
        return self.result
    def set_result(self, result):
        self.result = result
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.header is not None or
            self.result is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BasicResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BasicResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasicResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BasicResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BasicResponseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            namespaceprefix_ = self.header_nsprefix_ + ':' if (UseCapturedNS_ and self.header_nsprefix_) else ''
            self.header.export(outfile, level, namespaceprefix_, namespacedef_='', name_='header', pretty_print=pretty_print)
        if self.result is not None:
            namespaceprefix_ = self.result_nsprefix_ + ':' if (UseCapturedNS_ and self.result_nsprefix_) else ''
            self.result.export(outfile, level, namespaceprefix_, namespacedef_='', name_='result', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BasicResponseType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.header is not None:
            header_ = self.header
            header_.to_etree(element, name_='header', mapping_=mapping_, nsmap_=nsmap_)
        if self.result is not None:
            result_ = self.result
            result_.to_etree(element, name_='result', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='BasicResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.header is not None:
            showIndent(outfile, level)
            outfile.write('header=model_.BasicHeaderType(\n')
            self.header.exportLiteral(outfile, level, name_='header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.result is not None:
            showIndent(outfile, level)
            outfile.write('result=model_.BasicResultType(\n')
            self.result.exportLiteral(outfile, level, name_='result')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'header':
            obj_ = BasicHeaderType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.header = obj_
            obj_.original_tagname_ = 'header'
        elif nodeName_ == 'result':
            class_obj_ = self.get_class_obj_(child_, BasicResultType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.result = obj_
            obj_.original_tagname_ = 'result'
# end class BasicResponseType


class BasicResultType(GeneratedsSuper):
    """BasicResultType -- Alap v
    á
    laszeredm
    é
    ny adatok
    Basic result data
    funcCode -- Feldolgoz
    á
    si eredm
    é
    ny
    Processing result
    errorCode -- A feldolgoz
    á
    si hibak
    ó
    d
    Processing error code
    message -- Feldolgoz
    á
    si
    ü
    zenet
    Processing message
    notifications -- Egy
    é
    b
    é
    rtes
    í
    t
    é
    sek
    Miscellaneous notifications
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, funcCode=None, errorCode=None, message=None, notifications=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.funcCode = funcCode
        self.validate_FunctionCodeType(self.funcCode)
        self.funcCode_nsprefix_ = None
        self.errorCode = errorCode
        self.validate_SimpleText50NotBlankType(self.errorCode)
        self.errorCode_nsprefix_ = None
        self.message = message
        self.validate_SimpleText1024NotBlankType(self.message)
        self.message_nsprefix_ = None
        self.notifications = notifications
        self.notifications_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasicResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasicResultType.subclass:
            return BasicResultType.subclass(*args_, **kwargs_)
        else:
            return BasicResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_funcCode(self):
        return self.funcCode
    def set_funcCode(self, funcCode):
        self.funcCode = funcCode
    def get_errorCode(self):
        return self.errorCode
    def set_errorCode(self, errorCode):
        self.errorCode = errorCode
    def get_message(self):
        return self.message
    def set_message(self, message):
        self.message = message
    def get_notifications(self):
        return self.notifications
    def set_notifications(self, notifications):
        self.notifications = notifications
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_FunctionCodeType(self, value):
        result = True
        # Validate type FunctionCodeType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['OK', 'ERROR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FunctionCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on FunctionCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on FunctionCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText1024NotBlankType(self, value):
        result = True
        # Validate type SimpleText1024NotBlankType, a restriction on AtomicStringType1024.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText1024NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText1024NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText1024NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText1024NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText1024NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.funcCode is not None or
            self.errorCode is not None or
            self.message is not None or
            self.notifications is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BasicResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BasicResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasicResultType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BasicResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BasicResultType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.funcCode is not None:
            namespaceprefix_ = self.funcCode_nsprefix_ + ':' if (UseCapturedNS_ and self.funcCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfuncCode>%s</%sfuncCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.funcCode), input_name='funcCode')), namespaceprefix_ , eol_))
        if self.errorCode is not None:
            namespaceprefix_ = self.errorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.errorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorCode>%s</%serrorCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorCode), input_name='errorCode')), namespaceprefix_ , eol_))
        if self.message is not None:
            namespaceprefix_ = self.message_nsprefix_ + ':' if (UseCapturedNS_ and self.message_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smessage>%s</%smessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.message), input_name='message')), namespaceprefix_ , eol_))
        if self.notifications is not None:
            namespaceprefix_ = self.notifications_nsprefix_ + ':' if (UseCapturedNS_ and self.notifications_nsprefix_) else ''
            self.notifications.export(outfile, level, namespaceprefix_, namespacedef_='', name_='notifications', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BasicResultType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.funcCode is not None:
            funcCode_ = self.funcCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}funcCode').text = self.gds_format_string(funcCode_)
        if self.errorCode is not None:
            errorCode_ = self.errorCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}errorCode').text = self.gds_format_string(errorCode_)
        if self.message is not None:
            message_ = self.message
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}message').text = self.gds_format_string(message_)
        if self.notifications is not None:
            notifications_ = self.notifications
            notifications_.to_etree(element, name_='notifications', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='BasicResultType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.funcCode is not None:
            showIndent(outfile, level)
            outfile.write('funcCode=%s,\n' % self.gds_encode(quote_python(self.funcCode)))
        if self.errorCode is not None:
            showIndent(outfile, level)
            outfile.write('errorCode=%s,\n' % self.gds_encode(quote_python(self.errorCode)))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % self.gds_encode(quote_python(self.message)))
        if self.notifications is not None:
            showIndent(outfile, level)
            outfile.write('notifications=model_.NotificationsType(\n')
            self.notifications.exportLiteral(outfile, level, name_='notifications')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'funcCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'funcCode')
            value_ = self.gds_validate_string(value_, node, 'funcCode')
            self.funcCode = value_
            self.funcCode_nsprefix_ = child_.prefix
            # validate type FunctionCodeType
            self.validate_FunctionCodeType(self.funcCode)
        elif nodeName_ == 'errorCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'errorCode')
            value_ = self.gds_validate_string(value_, node, 'errorCode')
            self.errorCode = value_
            self.errorCode_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.errorCode)
        elif nodeName_ == 'message':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'message')
            value_ = self.gds_validate_string(value_, node, 'message')
            self.message = value_
            self.message_nsprefix_ = child_.prefix
            # validate type SimpleText1024NotBlankType
            self.validate_SimpleText1024NotBlankType(self.message)
        elif nodeName_ == 'notifications':
            obj_ = NotificationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notifications = obj_
            obj_.original_tagname_ = 'notifications'
# end class BasicResultType


class CryptoType(GeneratedsSuper):
    """CryptoType -- Kriptográfiai metódust leírótípus
    Denoting type of cryptographic method
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cryptoType=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "common"
        self.cryptoType = _cast(None, cryptoType)
        self.cryptoType_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CryptoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CryptoType.subclass:
            return CryptoType.subclass(*args_, **kwargs_)
        else:
            return CryptoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cryptoType(self):
        return self.cryptoType
    def set_cryptoType(self, cryptoType):
        self.cryptoType = cryptoType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText50NotBlankType(self, value):
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='CryptoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CryptoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CryptoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CryptoType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CryptoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CryptoType'):
        if self.cryptoType is not None and 'cryptoType' not in already_processed:
            already_processed.add('cryptoType')
            outfile.write(' cryptoType=%s' % (quote_attrib(self.cryptoType), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='CryptoType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='CryptoType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        if self.cryptoType is not None:
            element.set('cryptoType', self.cryptoType)
        if self._hasContent():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='CryptoType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cryptoType is not None and 'cryptoType' not in already_processed:
            already_processed.add('cryptoType')
            showIndent(outfile, level)
            outfile.write('cryptoType=%s,\n' % (self.cryptoType,))
    def _exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cryptoType', node)
        if value is not None and 'cryptoType' not in already_processed:
            already_processed.add('cryptoType')
            self.cryptoType = value
            self.validate_SimpleText50NotBlankType(self.cryptoType)    # validate type SimpleText50NotBlankType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CryptoType


class GeneralErrorHeaderResponseType(BasicResponseType):
    """GeneralErrorHeaderResponseType -- Á
    ltal
    á
    nos hibat
    í
    pus minden REST oper
    á
    ci
    ó
    ra
    Generic fault type for every REST operation
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicResponseType
    def __init__(self, header=None, result=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "tns"
        super(globals().get("GeneralErrorHeaderResponseType"), self).__init__(header, result, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralErrorHeaderResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralErrorHeaderResponseType.subclass:
            return GeneralErrorHeaderResponseType.subclass(*args_, **kwargs_)
        else:
            return GeneralErrorHeaderResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            super(GeneralErrorHeaderResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='GeneralErrorHeaderResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralErrorHeaderResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeneralErrorHeaderResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralErrorHeaderResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeneralErrorHeaderResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeneralErrorHeaderResponseType'):
        super(GeneralErrorHeaderResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralErrorHeaderResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='GeneralErrorHeaderResponseType', fromsubclass_=False, pretty_print=True):
        super(GeneralErrorHeaderResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GeneralErrorHeaderResponseType', mapping_=None, nsmap_=None):
        element = super(GeneralErrorHeaderResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='GeneralErrorHeaderResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GeneralErrorHeaderResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(GeneralErrorHeaderResponseType, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(GeneralErrorHeaderResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(GeneralErrorHeaderResponseType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class GeneralErrorHeaderResponseType


class NotificationsType(GeneratedsSuper):
    """NotificationsType -- Egy
    é
    b
    é
    rtes
    í
    t
    é
    sek
    Miscellaneous notifications
    notification -- É
    rtes
    í
    t
    é
    s
    Notification
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, notification=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if notification is None:
            self.notification = []
        else:
            self.notification = notification
        self.notification_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotificationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotificationsType.subclass:
            return NotificationsType.subclass(*args_, **kwargs_)
        else:
            return NotificationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_notification(self):
        return self.notification
    def set_notification(self, notification):
        self.notification = notification
    def add_notification(self, value):
        self.notification.append(value)
    def insert_notification_at(self, index, value):
        self.notification.insert(index, value)
    def replace_notification_at(self, index, value):
        self.notification[index] = value
    def _hasContent(self):
        if (
            self.notification
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='NotificationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NotificationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NotificationsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NotificationsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NotificationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NotificationsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='NotificationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for notification_ in self.notification:
            namespaceprefix_ = self.notification_nsprefix_ + ':' if (UseCapturedNS_ and self.notification_nsprefix_) else ''
            notification_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='notification', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NotificationsType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        for notification_ in self.notification:
            notification_.to_etree(element, name_='notification', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='NotificationsType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('notification=[\n')
        level += 1
        for notification_ in self.notification:
            showIndent(outfile, level)
            outfile.write('model_.NotificationType(\n')
            notification_.exportLiteral(outfile, level, name_='NotificationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notification':
            obj_ = NotificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.notification.append(obj_)
            obj_.original_tagname_ = 'notification'
# end class NotificationsType


class NotificationType(GeneratedsSuper):
    """NotificationType -- É
    rtes
    í
    t
    é
    s
    Notification
    notificationCode -- É
    rtes
    í
    t
    é
    s k
    ó
    d
    Notification code
    notificationText -- É
    rtes
    í
    t
    é
    s sz
    ö
    veg
    Notification text
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, notificationCode=None, notificationText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.notificationCode = notificationCode
        self.validate_SimpleText100NotBlankType(self.notificationCode)
        self.notificationCode_nsprefix_ = None
        self.notificationText = notificationText
        self.validate_SimpleText1024NotBlankType(self.notificationText)
        self.notificationText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotificationType.subclass:
            return NotificationType.subclass(*args_, **kwargs_)
        else:
            return NotificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_notificationCode(self):
        return self.notificationCode
    def set_notificationCode(self, notificationCode):
        self.notificationCode = notificationCode
    def get_notificationText(self):
        return self.notificationText
    def set_notificationText(self, notificationText):
        self.notificationText = notificationText
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText1024NotBlankType(self, value):
        result = True
        # Validate type SimpleText1024NotBlankType, a restriction on AtomicStringType1024.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText1024NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText1024NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText1024NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText1024NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText1024NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.notificationCode is not None or
            self.notificationText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='NotificationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NotificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NotificationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NotificationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NotificationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NotificationType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='NotificationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.notificationCode is not None:
            namespaceprefix_ = self.notificationCode_nsprefix_ + ':' if (UseCapturedNS_ and self.notificationCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotificationCode>%s</%snotificationCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notificationCode), input_name='notificationCode')), namespaceprefix_ , eol_))
        if self.notificationText is not None:
            namespaceprefix_ = self.notificationText_nsprefix_ + ':' if (UseCapturedNS_ and self.notificationText_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotificationText>%s</%snotificationText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notificationText), input_name='notificationText')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='NotificationType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        if self.notificationCode is not None:
            notificationCode_ = self.notificationCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}notificationCode').text = self.gds_format_string(notificationCode_)
        if self.notificationText is not None:
            notificationText_ = self.notificationText
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}notificationText').text = self.gds_format_string(notificationText_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='NotificationType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.notificationCode is not None:
            showIndent(outfile, level)
            outfile.write('notificationCode=%s,\n' % self.gds_encode(quote_python(self.notificationCode)))
        if self.notificationText is not None:
            showIndent(outfile, level)
            outfile.write('notificationText=%s,\n' % self.gds_encode(quote_python(self.notificationText)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'notificationCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notificationCode')
            value_ = self.gds_validate_string(value_, node, 'notificationCode')
            self.notificationCode = value_
            self.notificationCode_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.notificationCode)
        elif nodeName_ == 'notificationText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notificationText')
            value_ = self.gds_validate_string(value_, node, 'notificationText')
            self.notificationText = value_
            self.notificationText_nsprefix_ = child_.prefix
            # validate type SimpleText1024NotBlankType
            self.validate_SimpleText1024NotBlankType(self.notificationText)
# end class NotificationType


class TechnicalValidationResultType(GeneratedsSuper):
    """TechnicalValidationResultType -- Technikai valid
    á
    ci
    ó
    s v
    á
    laszt
    í
    pus
    Technical validation response type
    validationResultCode -- Valid
    á
    ci
    ó
    s eredm
    é
    ny
    Validation result
    validationErrorCode -- Valid
    á
    ci
    ó
    s hibak
    ó
    d
    Validation error code
    message -- Feldolgoz
    á
    si
    ü
    zenet
    Processing message
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, validationResultCode=None, validationErrorCode=None, message=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.validationResultCode = validationResultCode
        self.validate_TechnicalResultCodeType(self.validationResultCode)
        self.validationResultCode_nsprefix_ = None
        self.validationErrorCode = validationErrorCode
        self.validate_SimpleText100NotBlankType(self.validationErrorCode)
        self.validationErrorCode_nsprefix_ = None
        self.message = message
        self.validate_SimpleText1024NotBlankType(self.message)
        self.message_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TechnicalValidationResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TechnicalValidationResultType.subclass:
            return TechnicalValidationResultType.subclass(*args_, **kwargs_)
        else:
            return TechnicalValidationResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validationResultCode(self):
        return self.validationResultCode
    def set_validationResultCode(self, validationResultCode):
        self.validationResultCode = validationResultCode
    def get_validationErrorCode(self):
        return self.validationErrorCode
    def set_validationErrorCode(self, validationErrorCode):
        self.validationErrorCode = validationErrorCode
    def get_message(self):
        return self.message
    def set_message(self, message):
        self.message = message
    def validate_TechnicalResultCodeType(self, value):
        result = True
        # Validate type TechnicalResultCodeType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['CRITICAL', 'ERROR']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TechnicalResultCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TechnicalResultCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TechnicalResultCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText1024NotBlankType(self, value):
        result = True
        # Validate type SimpleText1024NotBlankType, a restriction on AtomicStringType1024.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText1024NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText1024NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText1024NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText1024NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText1024NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.validationResultCode is not None or
            self.validationErrorCode is not None or
            self.message is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='TechnicalValidationResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TechnicalValidationResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TechnicalValidationResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TechnicalValidationResultType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TechnicalValidationResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TechnicalValidationResultType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='TechnicalValidationResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validationResultCode is not None:
            namespaceprefix_ = self.validationResultCode_nsprefix_ + ':' if (UseCapturedNS_ and self.validationResultCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalidationResultCode>%s</%svalidationResultCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.validationResultCode), input_name='validationResultCode')), namespaceprefix_ , eol_))
        if self.validationErrorCode is not None:
            namespaceprefix_ = self.validationErrorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.validationErrorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalidationErrorCode>%s</%svalidationErrorCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.validationErrorCode), input_name='validationErrorCode')), namespaceprefix_ , eol_))
        if self.message is not None:
            namespaceprefix_ = self.message_nsprefix_ + ':' if (UseCapturedNS_ and self.message_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smessage>%s</%smessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.message), input_name='message')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='TechnicalValidationResultType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        if self.validationResultCode is not None:
            validationResultCode_ = self.validationResultCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}validationResultCode').text = self.gds_format_string(validationResultCode_)
        if self.validationErrorCode is not None:
            validationErrorCode_ = self.validationErrorCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}validationErrorCode').text = self.gds_format_string(validationErrorCode_)
        if self.message is not None:
            message_ = self.message
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}message').text = self.gds_format_string(message_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TechnicalValidationResultType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.validationResultCode is not None:
            showIndent(outfile, level)
            outfile.write('validationResultCode=%s,\n' % self.gds_encode(quote_python(self.validationResultCode)))
        if self.validationErrorCode is not None:
            showIndent(outfile, level)
            outfile.write('validationErrorCode=%s,\n' % self.gds_encode(quote_python(self.validationErrorCode)))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % self.gds_encode(quote_python(self.message)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validationResultCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validationResultCode')
            value_ = self.gds_validate_string(value_, node, 'validationResultCode')
            self.validationResultCode = value_
            self.validationResultCode_nsprefix_ = child_.prefix
            # validate type TechnicalResultCodeType
            self.validate_TechnicalResultCodeType(self.validationResultCode)
        elif nodeName_ == 'validationErrorCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validationErrorCode')
            value_ = self.gds_validate_string(value_, node, 'validationErrorCode')
            self.validationErrorCode = value_
            self.validationErrorCode_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.validationErrorCode)
        elif nodeName_ == 'message':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'message')
            value_ = self.gds_validate_string(value_, node, 'message')
            self.message = value_
            self.message_nsprefix_ = child_.prefix
            # validate type SimpleText1024NotBlankType
            self.validate_SimpleText1024NotBlankType(self.message)
# end class TechnicalValidationResultType


class UserHeaderType(GeneratedsSuper):
    """UserHeaderType -- A kérés authentikációs adatai
    Authentication data of the request
    login -- A technikai felhasználó login neve
    Login name of the technical user
    passwordHash -- A technikai felhasználó jelszavának hash értéke
    Hash value of the technical user's password
    taxNumber -- A rendszerben regisztrált adózó adószáma, aki nevében a technikai felhasználó tevékenykedik
    The taxpayer's tax number, whose name the technical user operates in
    requestSignature -- A kérés aláírásának hash értéke
    Hash value of the request's signature
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, login=None, passwordHash=None, taxNumber=None, requestSignature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "common"
        self.login = login
        self.validate_LoginType(self.login)
        self.login_nsprefix_ = "common"
        self.passwordHash = passwordHash
        self.passwordHash_nsprefix_ = "common"
        self.taxNumber = taxNumber
        self.validate_TaxpayerIdType(self.taxNumber)
        self.taxNumber_nsprefix_ = "common"
        self.requestSignature = requestSignature
        self.requestSignature_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UserHeaderType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UserHeaderType.subclass:
            return UserHeaderType.subclass(*args_, **kwargs_)
        else:
            return UserHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_login(self):
        return self.login
    def set_login(self, login):
        self.login = login
    def get_passwordHash(self):
        return self.passwordHash
    def set_passwordHash(self, passwordHash):
        self.passwordHash = passwordHash
    def get_taxNumber(self):
        return self.taxNumber
    def set_taxNumber(self, taxNumber):
        self.taxNumber = taxNumber
    def get_requestSignature(self):
        return self.requestSignature
    def set_requestSignature(self, requestSignature):
        self.requestSignature = requestSignature
    def validate_LoginType(self, value):
        result = True
        # Validate type LoginType, a restriction on AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LoginType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 6:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LoginType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LoginType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LoginType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_LoginType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_LoginType_patterns_, ))
                result = False
        return result
    validate_LoginType_patterns_ = [['^([a-zA-Z0-9]{6,15})$']]
    def validate_TaxpayerIdType(self, value):
        result = True
        # Validate type TaxpayerIdType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxpayerIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TaxpayerIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TaxpayerIdType_patterns_, ))
                result = False
        return result
    validate_TaxpayerIdType_patterns_ = [['^([0-9]{8})$']]
    def _hasContent(self):
        if (
            self.login is not None or
            self.passwordHash is not None or
            self.taxNumber is not None or
            self.requestSignature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='UserHeaderType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UserHeaderType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UserHeaderType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UserHeaderType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UserHeaderType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UserHeaderType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='UserHeaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.login is not None:
            namespaceprefix_ = self.login_nsprefix_ + ':' if (UseCapturedNS_ and self.login_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogin>%s</%slogin>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.login), input_name='login')), namespaceprefix_ , eol_))
        if self.passwordHash is not None:
            namespaceprefix_ = self.passwordHash_nsprefix_ + ':' if (UseCapturedNS_ and self.passwordHash_nsprefix_) else ''
            self.passwordHash.export(outfile, level, namespaceprefix_, namespacedef_='', name_='passwordHash', pretty_print=pretty_print)
        if self.taxNumber is not None:
            namespaceprefix_ = self.taxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.taxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxNumber>%s</%staxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxNumber), input_name='taxNumber')), namespaceprefix_ , eol_))
        if self.requestSignature is not None:
            namespaceprefix_ = self.requestSignature_nsprefix_ + ':' if (UseCapturedNS_ and self.requestSignature_nsprefix_) else ''
            self.requestSignature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='requestSignature', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='UserHeaderType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}' + name_, nsmap=nsmap_)
        if self.login is not None:
            login_ = self.login
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}login').text = self.gds_format_string(login_)
        if self.passwordHash is not None:
            passwordHash_ = self.passwordHash
            passwordHash_.to_etree(element, name_='passwordHash', mapping_=mapping_, nsmap_=nsmap_)
        if self.taxNumber is not None:
            taxNumber_ = self.taxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/NTCA/1.0/common}taxNumber').text = self.gds_format_string(taxNumber_)
        if self.requestSignature is not None:
            requestSignature_ = self.requestSignature
            requestSignature_.to_etree(element, name_='requestSignature', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='UserHeaderType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.login is not None:
            showIndent(outfile, level)
            outfile.write('login=%s,\n' % self.gds_encode(quote_python(self.login)))
        if self.passwordHash is not None:
            showIndent(outfile, level)
            outfile.write('passwordHash=model_.CryptoType(\n')
            self.passwordHash.exportLiteral(outfile, level, name_='passwordHash')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.taxNumber is not None:
            showIndent(outfile, level)
            outfile.write('taxNumber=%s,\n' % self.gds_encode(quote_python(self.taxNumber)))
        if self.requestSignature is not None:
            showIndent(outfile, level)
            outfile.write('requestSignature=model_.CryptoType(\n')
            self.requestSignature.exportLiteral(outfile, level, name_='requestSignature')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'login':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'login')
            value_ = self.gds_validate_string(value_, node, 'login')
            self.login = value_
            self.login_nsprefix_ = child_.prefix
            # validate type LoginType
            self.validate_LoginType(self.login)
        elif nodeName_ == 'passwordHash':
            obj_ = CryptoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.passwordHash = obj_
            obj_.original_tagname_ = 'passwordHash'
        elif nodeName_ == 'taxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxNumber')
            value_ = self.gds_validate_string(value_, node, 'taxNumber')
            self.taxNumber = value_
            self.taxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.taxNumber)
        elif nodeName_ == 'requestSignature':
            obj_ = CryptoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.requestSignature = obj_
            obj_.original_tagname_ = 'requestSignature'
# end class UserHeaderType


class GeneralErrorHeaderResponse(GeneralErrorHeaderResponseType):
    """GeneralErrorHeaderResponse -- Az
    ö
    sszes REST oper
    á
    ci
    ó
    ra vonatkoz
    ó
    hibav
    á
    lasz generikus elementje
    General error response of every REST operation
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = GeneralErrorHeaderResponseType
    def __init__(self, header=None, result=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "tns"
        super(globals().get("GeneralErrorHeaderResponse"), self).__init__(header, result,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralErrorHeaderResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralErrorHeaderResponse.subclass:
            return GeneralErrorHeaderResponse.subclass(*args_, **kwargs_)
        else:
            return GeneralErrorHeaderResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(GeneralErrorHeaderResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='GeneralErrorHeaderResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralErrorHeaderResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeneralErrorHeaderResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralErrorHeaderResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeneralErrorHeaderResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeneralErrorHeaderResponse'):
        super(GeneralErrorHeaderResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralErrorHeaderResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='GeneralErrorHeaderResponse', fromsubclass_=False, pretty_print=True):
        super(GeneralErrorHeaderResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GeneralErrorHeaderResponse', mapping_=None, nsmap_=None):
        element = super(GeneralErrorHeaderResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='GeneralErrorHeaderResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GeneralErrorHeaderResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(GeneralErrorHeaderResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(GeneralErrorHeaderResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(GeneralErrorHeaderResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class GeneralErrorHeaderResponse


class GeneralExceptionResponse(BasicResultType):
    """GeneralExceptionResponse -- Az
    ö
    sszes REST oper
    á
    ci
    ó
    ra vonatkoz
    ó
    kiv
    é
    tel v
    á
    lasz generikus elementje
    General exception response of every REST operation
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicResultType
    def __init__(self, funcCode=None, errorCode=None, message=None, notifications=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "tns"
        super(globals().get("GeneralExceptionResponse"), self).__init__(funcCode, errorCode, message, notifications,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralExceptionResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralExceptionResponse.subclass:
            return GeneralExceptionResponse.subclass(*args_, **kwargs_)
        else:
            return GeneralExceptionResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(GeneralExceptionResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='GeneralExceptionResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralExceptionResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeneralExceptionResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralExceptionResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeneralExceptionResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeneralExceptionResponse'):
        super(GeneralExceptionResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralExceptionResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='GeneralExceptionResponse', fromsubclass_=False, pretty_print=True):
        super(GeneralExceptionResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GeneralExceptionResponse', mapping_=None, nsmap_=None):
        element = super(GeneralExceptionResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='GeneralExceptionResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GeneralExceptionResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(GeneralExceptionResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(GeneralExceptionResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(GeneralExceptionResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class GeneralExceptionResponse


class InvoiceAnnulmentType(GeneratedsSuper):
    """InvoiceAnnulmentType -- Kor
    á
    bbi adatszolg
    á
    ltat
    á
    s technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s
    é
    nek adatai
    Data of technical annulment concerning previous data exchange
    annulmentReference -- A technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    ssel
    é
    rintett sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma
    Sequential number of the invoice or modification document to be annuled
    annulmentTimestamp -- A technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s id
    ő
    b
    é
    lyege a forr
    á
    srendszerben UTC id
    ő
    szerint
    Timestamp of the technical annulment in UTC time
    annulmentCode -- A technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s k
    ó
    dja
    Technical annulment code
    annulmentReason -- A technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s oka
    Technical annulment reason
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, annulmentReference=None, annulmentTimestamp=None, annulmentCode=None, annulmentReason=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.annulmentReference = annulmentReference
        self.validate_SimpleText50NotBlankType(self.annulmentReference)
        self.annulmentReference_nsprefix_ = "common"
        if isinstance(annulmentTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(annulmentTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = annulmentTimestamp
        self.annulmentTimestamp = initvalue_
        self.annulmentTimestamp_nsprefix_ = "base"
        self.annulmentCode = annulmentCode
        self.validate_AnnulmentCodeType(self.annulmentCode)
        self.annulmentCode_nsprefix_ = None
        self.annulmentReason = annulmentReason
        self.validate_SimpleText1024NotBlankType(self.annulmentReason)
        self.annulmentReason_nsprefix_ = "common"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceAnnulmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceAnnulmentType.subclass:
            return InvoiceAnnulmentType.subclass(*args_, **kwargs_)
        else:
            return InvoiceAnnulmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_annulmentReference(self):
        return self.annulmentReference
    def set_annulmentReference(self, annulmentReference):
        self.annulmentReference = annulmentReference
    def get_annulmentTimestamp(self):
        return self.annulmentTimestamp
    def set_annulmentTimestamp(self, annulmentTimestamp):
        self.annulmentTimestamp = annulmentTimestamp
    def get_annulmentCode(self):
        return self.annulmentCode
    def set_annulmentCode(self, annulmentCode):
        self.annulmentCode = annulmentCode
    def get_annulmentReason(self):
        return self.annulmentReason
    def set_annulmentReason(self, annulmentReason):
        self.annulmentReason = annulmentReason
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
        if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceTimestampType_patterns_, ))
                result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def validate_AnnulmentCodeType(self, value):
        result = True
        # Validate type AnnulmentCodeType, a restriction on common:AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['ERRATIC_DATA', 'ERRATIC_INVOICE_NUMBER', 'ERRATIC_INVOICE_ISSUE_DATE', 'ERRATIC_ELECTRONIC_HASH_VALUE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AnnulmentCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on AnnulmentCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on AnnulmentCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText1024NotBlankType(self, value):
        result = True
        # Validate type SimpleText1024NotBlankType, a restriction on AtomicStringType1024.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText1024NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText1024NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText1024NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText1024NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText1024NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.annulmentReference is not None or
            self.annulmentTimestamp is not None or
            self.annulmentCode is not None or
            self.annulmentReason is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceAnnulmentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceAnnulmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceAnnulmentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceAnnulmentType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceAnnulmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceAnnulmentType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceAnnulmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.annulmentReference is not None:
            namespaceprefix_ = self.annulmentReference_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sannulmentReference>%s</%sannulmentReference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.annulmentReference), input_name='annulmentReference')), namespaceprefix_ , eol_))
        if self.annulmentTimestamp is not None:
            namespaceprefix_ = self.annulmentTimestamp_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentTimestamp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sannulmentTimestamp>%s</%sannulmentTimestamp>%s' % (namespaceprefix_ , self.gds_format_datetime(self.annulmentTimestamp, input_name='annulmentTimestamp'), namespaceprefix_ , eol_))
        if self.annulmentCode is not None:
            namespaceprefix_ = self.annulmentCode_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sannulmentCode>%s</%sannulmentCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.annulmentCode), input_name='annulmentCode')), namespaceprefix_ , eol_))
        if self.annulmentReason is not None:
            namespaceprefix_ = self.annulmentReason_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentReason_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sannulmentReason>%s</%sannulmentReason>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.annulmentReason), input_name='annulmentReason')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='InvoiceAnnulmentType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/annul}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/annul}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.annulmentReference is not None:
            annulmentReference_ = self.annulmentReference
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/annul}annulmentReference').text = self.gds_format_string(annulmentReference_)
        if self.annulmentTimestamp is not None:
            annulmentTimestamp_ = self.annulmentTimestamp
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/annul}annulmentTimestamp').text = self.gds_format_datetime(annulmentTimestamp_)
        if self.annulmentCode is not None:
            annulmentCode_ = self.annulmentCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/annul}annulmentCode').text = self.gds_format_string(annulmentCode_)
        if self.annulmentReason is not None:
            annulmentReason_ = self.annulmentReason
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/annul}annulmentReason').text = self.gds_format_string(annulmentReason_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceAnnulmentType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.annulmentReference is not None:
            showIndent(outfile, level)
            outfile.write('annulmentReference=%s,\n' % self.gds_encode(quote_python(self.annulmentReference)))
        if self.annulmentTimestamp is not None:
            showIndent(outfile, level)
            outfile.write('annulmentTimestamp=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.annulmentTimestamp, input_name='annulmentTimestamp'))
        if self.annulmentCode is not None:
            showIndent(outfile, level)
            outfile.write('annulmentCode=%s,\n' % self.gds_encode(quote_python(self.annulmentCode)))
        if self.annulmentReason is not None:
            showIndent(outfile, level)
            outfile.write('annulmentReason=%s,\n' % self.gds_encode(quote_python(self.annulmentReason)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'annulmentReference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'annulmentReference')
            value_ = self.gds_validate_string(value_, node, 'annulmentReference')
            self.annulmentReference = value_
            self.annulmentReference_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.annulmentReference)
        elif nodeName_ == 'annulmentTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.annulmentTimestamp = dval_
            self.annulmentTimestamp_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.annulmentTimestamp)
        elif nodeName_ == 'annulmentCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'annulmentCode')
            value_ = self.gds_validate_string(value_, node, 'annulmentCode')
            self.annulmentCode = value_
            self.annulmentCode_nsprefix_ = child_.prefix
            # validate type AnnulmentCodeType
            self.validate_AnnulmentCodeType(self.annulmentCode)
        elif nodeName_ == 'annulmentReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'annulmentReason')
            value_ = self.gds_validate_string(value_, node, 'annulmentReason')
            self.annulmentReason = value_
            self.annulmentReason_nsprefix_ = child_.prefix
            # validate type SimpleText1024NotBlankType
            self.validate_SimpleText1024NotBlankType(self.annulmentReason)
# end class InvoiceAnnulmentType


class InvoiceAnnulment(InvoiceAnnulmentType):
    """InvoiceAnnulment -- XML root element, a technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s adatait le
    í
    r
    ó
    t
    í
    pus, amelyet BASE64 k
    ó
    doltan tartalmaz az invoiceApi s
    é
    male
    í
    r
    ó
    invoiceAnnulment elementje
    XML root element, technical annulment data type in BASE64 encoding, equivalent with the invoiceApi schema definition's invoiceAnnulment element

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = InvoiceAnnulmentType
    def __init__(self, annulmentReference=None, annulmentTimestamp=None, annulmentCode=None, annulmentReason=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InvoiceAnnulment"), self).__init__(annulmentReference, annulmentTimestamp, annulmentCode, annulmentReason,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceAnnulment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceAnnulment.subclass:
            return InvoiceAnnulment.subclass(*args_, **kwargs_)
        else:
            return InvoiceAnnulment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(InvoiceAnnulment, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='InvoiceAnnulment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceAnnulment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceAnnulment':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceAnnulment')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceAnnulment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceAnnulment'):
        super(InvoiceAnnulment, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceAnnulment')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='InvoiceAnnulment', fromsubclass_=False, pretty_print=True):
        super(InvoiceAnnulment, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceAnnulment', mapping_=None, nsmap_=None):
        element = super(InvoiceAnnulment, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceAnnulment'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InvoiceAnnulment, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(InvoiceAnnulment, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InvoiceAnnulment, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(InvoiceAnnulment, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class InvoiceAnnulment


class AddressType(GeneratedsSuper):
    """AddressType -- C
    í
    m t
    í
    pus, amely vagy egyszer
    ű
    , vagy r
    é
    szletes c
    í
    met tartalmaz
    Format of address_list that includes either a simple or a detailed address_list
    simpleAddress -- Egyszer
    ű
    c
    í
    m
    Simple address_list
    detailedAddress -- R
    é
    szletes c
    í
    m
    Detailed address_list

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, simpleAddress=None, detailedAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.simpleAddress = simpleAddress
        self.simpleAddress_nsprefix_ = None
        self.detailedAddress = detailedAddress
        self.detailedAddress_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_simpleAddress(self):
        return self.simpleAddress
    def set_simpleAddress(self, simpleAddress):
        self.simpleAddress = simpleAddress
    def get_detailedAddress(self):
        return self.detailedAddress
    def set_detailedAddress(self, detailedAddress):
        self.detailedAddress = detailedAddress
    def _hasContent(self):
        if (
            self.simpleAddress is not None or
            self.detailedAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='AddressType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AddressType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddressType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='AddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.simpleAddress is not None:
            namespaceprefix_ = self.simpleAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.simpleAddress_nsprefix_) else ''
            self.simpleAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='simpleAddress', pretty_print=pretty_print)
        if self.detailedAddress is not None:
            namespaceprefix_ = self.detailedAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.detailedAddress_nsprefix_) else ''
            self.detailedAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detailedAddress', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AddressType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/base}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/base}' + name_, nsmap=nsmap_)
        if self.simpleAddress is not None:
            simpleAddress_ = self.simpleAddress
            simpleAddress_.to_etree(element, name_='simpleAddress', mapping_=mapping_, nsmap_=nsmap_)
        if self.detailedAddress is not None:
            detailedAddress_ = self.detailedAddress
            detailedAddress_.to_etree(element, name_='detailedAddress', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AddressType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.simpleAddress is not None:
            showIndent(outfile, level)
            outfile.write('simpleAddress=model_.SimpleAddressType(\n')
            self.simpleAddress.exportLiteral(outfile, level, name_='simpleAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.detailedAddress is not None:
            showIndent(outfile, level)
            outfile.write('detailedAddress=model_.DetailedAddressType(\n')
            self.detailedAddress.exportLiteral(outfile, level, name_='detailedAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'simpleAddress':
            obj_ = SimpleAddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.simpleAddress = obj_
            obj_.original_tagname_ = 'simpleAddress'
        elif nodeName_ == 'detailedAddress':
            obj_ = DetailedAddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.detailedAddress = obj_
            obj_.original_tagname_ = 'detailedAddress'
# end class AddressType


class DetailedAddressType(GeneratedsSuper):
    """DetailedAddressType -- R
    é
    szletes c
    í
    madatok
    Detailed address_list data
    countryCode -- Az orsz
    á
    gk
    ó
    d ISO 3166 alpha-2 szabv
    á
    ny szerint
    ISO 3166 alpha-2 country code
    region -- Tartom
    á
    ny k
    ó
    dja (amennyiben
    é
    rtelmezhet
    ő
    az adott orsz
    á
    gban) az ISO 3166-2 alpha 2 szabv
    á
    ny szerint
    ISO 3166 alpha-2 province code (if appropriate in a given country)
    postalCode -- Ir
    á
    ny
    í
    t
    ó
    sz
    á
    m (amennyiben nem
    é
    rtelmezhet
    ő
    , 0000
    é
    rt
    é
    kkel kell kit
    ö
    lteni)
    ZIP code (If can not be interpreted, need to be filled "0000")
    city -- Telep
    ü
    l
    é
    s
    Settlement
    streetName -- K
    ö
    zter
    ü
    let neve
    Name of public place
    publicPlaceCategory -- K
    ö
    zter
    ü
    let jellege
    Category of public place
    number -- H
    á
    zsz
    á
    m
    House number
    building -- É
    p
    ü
    let
    Building
    staircase -- L
    é
    pcs
    ő
    h
    á
    z
    Staircase
    floor -- Emelet
    Floor
    door -- Ajt
    ó
    Door number
    lotNumber -- Helyrajzi sz
    á
    m
    Lot number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, countryCode=None, region=None, postalCode=None, city=None, streetName=None, publicPlaceCategory=None, number=None, building=None, staircase=None, floor=None, door=None, lotNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.countryCode = countryCode
        self.validate_CountryCodeType(self.countryCode)
        self.countryCode_nsprefix_ = "common"
        self.region = region
        self.validate_SimpleText50NotBlankType(self.region)
        self.region_nsprefix_ = "common"
        self.postalCode = postalCode
        self.validate_PostalCodeType(self.postalCode)
        self.postalCode_nsprefix_ = "common"
        self.city = city
        self.validate_SimpleText255NotBlankType(self.city)
        self.city_nsprefix_ = "common"
        self.streetName = streetName
        self.validate_SimpleText255NotBlankType(self.streetName)
        self.streetName_nsprefix_ = "common"
        self.publicPlaceCategory = publicPlaceCategory
        self.validate_SimpleText50NotBlankType(self.publicPlaceCategory)
        self.publicPlaceCategory_nsprefix_ = "common"
        self.number = number
        self.validate_SimpleText50NotBlankType(self.number)
        self.number_nsprefix_ = "common"
        self.building = building
        self.validate_SimpleText50NotBlankType(self.building)
        self.building_nsprefix_ = "common"
        self.staircase = staircase
        self.validate_SimpleText50NotBlankType(self.staircase)
        self.staircase_nsprefix_ = "common"
        self.floor = floor
        self.validate_SimpleText50NotBlankType(self.floor)
        self.floor_nsprefix_ = "common"
        self.door = door
        self.validate_SimpleText50NotBlankType(self.door)
        self.door_nsprefix_ = "common"
        self.lotNumber = lotNumber
        self.validate_SimpleText50NotBlankType(self.lotNumber)
        self.lotNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailedAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailedAddressType.subclass:
            return DetailedAddressType.subclass(*args_, **kwargs_)
        else:
            return DetailedAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_countryCode(self):
        return self.countryCode
    def set_countryCode(self, countryCode):
        self.countryCode = countryCode
    def get_region(self):
        return self.region
    def set_region(self, region):
        self.region = region
    def get_postalCode(self):
        return self.postalCode
    def set_postalCode(self, postalCode):
        self.postalCode = postalCode
    def get_city(self):
        return self.city
    def set_city(self, city):
        self.city = city
    def get_streetName(self):
        return self.streetName
    def set_streetName(self, streetName):
        self.streetName = streetName
    def get_publicPlaceCategory(self):
        return self.publicPlaceCategory
    def set_publicPlaceCategory(self, publicPlaceCategory):
        self.publicPlaceCategory = publicPlaceCategory
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    def get_building(self):
        return self.building
    def set_building(self, building):
        self.building = building
    def get_staircase(self):
        return self.staircase
    def set_staircase(self, staircase):
        self.staircase = staircase
    def get_floor(self):
        return self.floor
    def set_floor(self, floor):
        self.floor = floor
    def get_door(self):
        return self.door
    def set_door(self, door):
        self.door = door
    def get_lotNumber(self):
        return self.lotNumber
    def set_lotNumber(self, lotNumber):
        self.lotNumber = lotNumber
    def validate_CountryCodeType(self, value):
        result = True
        # Validate type CountryCodeType, a restriction on AtomicStringType2.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on CountryCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CountryCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CountryCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryCodeType_patterns_, ))
                result = False
        return result
    validate_CountryCodeType_patterns_ = [['^([A-Z]{2})$']]
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_PostalCodeType(self, value):
        result = True
        # Validate type PostalCodeType, a restriction on AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PostalCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PostalCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PostalCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PostalCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_PostalCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_PostalCodeType_patterns_, ))
                result = False
        return result
    validate_PostalCodeType_patterns_ = [['^([A-Z0-9][A-Z0-9\\s\\-]{1,8}[A-Z0-9])$']]
    def validate_SimpleText255NotBlankType(self, value):
        result = True
        # Validate type SimpleText255NotBlankType, a restriction on AtomicStringType255.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText255NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText255NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText255NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText255NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText255NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.countryCode is not None or
            self.region is not None or
            self.postalCode is not None or
            self.city is not None or
            self.streetName is not None or
            self.publicPlaceCategory is not None or
            self.number is not None or
            self.building is not None or
            self.staircase is not None or
            self.floor is not None or
            self.door is not None or
            self.lotNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='DetailedAddressType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DetailedAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DetailedAddressType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DetailedAddressType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DetailedAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DetailedAddressType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='DetailedAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.countryCode is not None:
            namespaceprefix_ = self.countryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.countryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountryCode>%s</%scountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.countryCode), input_name='countryCode')), namespaceprefix_ , eol_))
        if self.region is not None:
            namespaceprefix_ = self.region_nsprefix_ + ':' if (UseCapturedNS_ and self.region_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregion>%s</%sregion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.region), input_name='region')), namespaceprefix_ , eol_))
        if self.postalCode is not None:
            namespaceprefix_ = self.postalCode_nsprefix_ + ':' if (UseCapturedNS_ and self.postalCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spostalCode>%s</%spostalCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.postalCode), input_name='postalCode')), namespaceprefix_ , eol_))
        if self.city is not None:
            namespaceprefix_ = self.city_nsprefix_ + ':' if (UseCapturedNS_ and self.city_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scity>%s</%scity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), namespaceprefix_ , eol_))
        if self.streetName is not None:
            namespaceprefix_ = self.streetName_nsprefix_ + ':' if (UseCapturedNS_ and self.streetName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstreetName>%s</%sstreetName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.streetName), input_name='streetName')), namespaceprefix_ , eol_))
        if self.publicPlaceCategory is not None:
            namespaceprefix_ = self.publicPlaceCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.publicPlaceCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublicPlaceCategory>%s</%spublicPlaceCategory>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.publicPlaceCategory), input_name='publicPlaceCategory')), namespaceprefix_ , eol_))
        if self.number is not None:
            namespaceprefix_ = self.number_nsprefix_ + ':' if (UseCapturedNS_ and self.number_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.number), input_name='number')), namespaceprefix_ , eol_))
        if self.building is not None:
            namespaceprefix_ = self.building_nsprefix_ + ':' if (UseCapturedNS_ and self.building_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbuilding>%s</%sbuilding>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.building), input_name='building')), namespaceprefix_ , eol_))
        if self.staircase is not None:
            namespaceprefix_ = self.staircase_nsprefix_ + ':' if (UseCapturedNS_ and self.staircase_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstaircase>%s</%sstaircase>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.staircase), input_name='staircase')), namespaceprefix_ , eol_))
        if self.floor is not None:
            namespaceprefix_ = self.floor_nsprefix_ + ':' if (UseCapturedNS_ and self.floor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfloor>%s</%sfloor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.floor), input_name='floor')), namespaceprefix_ , eol_))
        if self.door is not None:
            namespaceprefix_ = self.door_nsprefix_ + ':' if (UseCapturedNS_ and self.door_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdoor>%s</%sdoor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.door), input_name='door')), namespaceprefix_ , eol_))
        if self.lotNumber is not None:
            namespaceprefix_ = self.lotNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.lotNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slotNumber>%s</%slotNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.lotNumber), input_name='lotNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='DetailedAddressType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/base}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/base}' + name_, nsmap=nsmap_)
        if self.countryCode is not None:
            countryCode_ = self.countryCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}countryCode').text = self.gds_format_string(countryCode_)
        if self.region is not None:
            region_ = self.region
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}region').text = self.gds_format_string(region_)
        if self.postalCode is not None:
            postalCode_ = self.postalCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}postalCode').text = self.gds_format_string(postalCode_)
        if self.city is not None:
            city_ = self.city
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}city').text = self.gds_format_string(city_)
        if self.streetName is not None:
            streetName_ = self.streetName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}streetName').text = self.gds_format_string(streetName_)
        if self.publicPlaceCategory is not None:
            publicPlaceCategory_ = self.publicPlaceCategory
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}publicPlaceCategory').text = self.gds_format_string(publicPlaceCategory_)
        if self.number is not None:
            number_ = self.number
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}number').text = self.gds_format_string(number_)
        if self.building is not None:
            building_ = self.building
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}building').text = self.gds_format_string(building_)
        if self.staircase is not None:
            staircase_ = self.staircase
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}staircase').text = self.gds_format_string(staircase_)
        if self.floor is not None:
            floor_ = self.floor
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}floor').text = self.gds_format_string(floor_)
        if self.door is not None:
            door_ = self.door
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}door').text = self.gds_format_string(door_)
        if self.lotNumber is not None:
            lotNumber_ = self.lotNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}lotNumber').text = self.gds_format_string(lotNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DetailedAddressType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.countryCode is not None:
            showIndent(outfile, level)
            outfile.write('countryCode=%s,\n' % self.gds_encode(quote_python(self.countryCode)))
        if self.region is not None:
            showIndent(outfile, level)
            outfile.write('region=%s,\n' % self.gds_encode(quote_python(self.region)))
        if self.postalCode is not None:
            showIndent(outfile, level)
            outfile.write('postalCode=%s,\n' % self.gds_encode(quote_python(self.postalCode)))
        if self.city is not None:
            showIndent(outfile, level)
            outfile.write('city=%s,\n' % self.gds_encode(quote_python(self.city)))
        if self.streetName is not None:
            showIndent(outfile, level)
            outfile.write('streetName=%s,\n' % self.gds_encode(quote_python(self.streetName)))
        if self.publicPlaceCategory is not None:
            showIndent(outfile, level)
            outfile.write('publicPlaceCategory=%s,\n' % self.gds_encode(quote_python(self.publicPlaceCategory)))
        if self.number is not None:
            showIndent(outfile, level)
            outfile.write('number=%s,\n' % self.gds_encode(quote_python(self.number)))
        if self.building is not None:
            showIndent(outfile, level)
            outfile.write('building=%s,\n' % self.gds_encode(quote_python(self.building)))
        if self.staircase is not None:
            showIndent(outfile, level)
            outfile.write('staircase=%s,\n' % self.gds_encode(quote_python(self.staircase)))
        if self.floor is not None:
            showIndent(outfile, level)
            outfile.write('floor=%s,\n' % self.gds_encode(quote_python(self.floor)))
        if self.door is not None:
            showIndent(outfile, level)
            outfile.write('door=%s,\n' % self.gds_encode(quote_python(self.door)))
        if self.lotNumber is not None:
            showIndent(outfile, level)
            outfile.write('lotNumber=%s,\n' % self.gds_encode(quote_python(self.lotNumber)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'countryCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'countryCode')
            value_ = self.gds_validate_string(value_, node, 'countryCode')
            self.countryCode = value_
            self.countryCode_nsprefix_ = child_.prefix
            # validate type CountryCodeType
            self.validate_CountryCodeType(self.countryCode)
        elif nodeName_ == 'region':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'region')
            value_ = self.gds_validate_string(value_, node, 'region')
            self.region = value_
            self.region_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.region)
        elif nodeName_ == 'postalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalCode')
            value_ = self.gds_validate_string(value_, node, 'postalCode')
            self.postalCode = value_
            self.postalCode_nsprefix_ = child_.prefix
            # validate type PostalCodeType
            self.validate_PostalCodeType(self.postalCode)
        elif nodeName_ == 'city':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'city')
            value_ = self.gds_validate_string(value_, node, 'city')
            self.city = value_
            self.city_nsprefix_ = child_.prefix
            # validate type SimpleText255NotBlankType
            self.validate_SimpleText255NotBlankType(self.city)
        elif nodeName_ == 'streetName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'streetName')
            value_ = self.gds_validate_string(value_, node, 'streetName')
            self.streetName = value_
            self.streetName_nsprefix_ = child_.prefix
            # validate type SimpleText255NotBlankType
            self.validate_SimpleText255NotBlankType(self.streetName)
        elif nodeName_ == 'publicPlaceCategory':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'publicPlaceCategory')
            value_ = self.gds_validate_string(value_, node, 'publicPlaceCategory')
            self.publicPlaceCategory = value_
            self.publicPlaceCategory_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.publicPlaceCategory)
        elif nodeName_ == 'number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'number')
            value_ = self.gds_validate_string(value_, node, 'number')
            self.number = value_
            self.number_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.number)
        elif nodeName_ == 'building':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'building')
            value_ = self.gds_validate_string(value_, node, 'building')
            self.building = value_
            self.building_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.building)
        elif nodeName_ == 'staircase':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'staircase')
            value_ = self.gds_validate_string(value_, node, 'staircase')
            self.staircase = value_
            self.staircase_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.staircase)
        elif nodeName_ == 'floor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'floor')
            value_ = self.gds_validate_string(value_, node, 'floor')
            self.floor = value_
            self.floor_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.floor)
        elif nodeName_ == 'door':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'door')
            value_ = self.gds_validate_string(value_, node, 'door')
            self.door = value_
            self.door_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.door)
        elif nodeName_ == 'lotNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lotNumber')
            value_ = self.gds_validate_string(value_, node, 'lotNumber')
            self.lotNumber = value_
            self.lotNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.lotNumber)
# end class DetailedAddressType


class SimpleAddressType(GeneratedsSuper):
    """SimpleAddressType -- Egyszer
    ű
    c
    í
    mt
    í
    pus
    Simple address_list type
    countryCode -- Az orsz
    á
    gk
    ó
    d az ISO 3166 alpha-2 szabv
    á
    ny szerint
    ISO 3166 alpha-2 country code
    region -- Tartom
    á
    ny k
    ó
    dja (amennyiben
    é
    rtelmezhet
    ő
    az adott orsz
    á
    gban) az ISO 3166-2 alpha 2 szabv
    á
    ny szerint
    ISO 3166 alpha-2 province code (if appropriate in a given country)
    postalCode -- Ir
    á
    ny
    í
    t
    ó
    sz
    á
    m (amennyiben nem
    é
    rtelmezhet
    ő
    , 0000
    é
    rt
    é
    kkel kell kit
    ö
    lteni)
    ZIP code (If can not be interpreted, need to be filled "0000")
    city -- Telep
    ü
    l
    é
    s
    Settlement
    additionalAddressDetail -- Tov
    á
    bbi c
    í
    madatok (pl. k
    ö
    zter
    ü
    let neve
    é
    s jellege, h
    á
    zsz
    á
    m, emelet, ajt
    ó
    , helyrajzi sz
    á
    m, stb.)
    Further address_list data (name and type of public place, house number, floor, door, lot number, etc.)

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, countryCode=None, region=None, postalCode=None, city=None, additionalAddressDetail=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.countryCode = countryCode
        self.validate_CountryCodeType(self.countryCode)
        self.countryCode_nsprefix_ = "common"
        self.region = region
        self.validate_SimpleText50NotBlankType(self.region)
        self.region_nsprefix_ = "common"
        self.postalCode = postalCode
        self.validate_PostalCodeType(self.postalCode)
        self.postalCode_nsprefix_ = "common"
        self.city = city
        self.validate_SimpleText255NotBlankType(self.city)
        self.city_nsprefix_ = "common"
        self.additionalAddressDetail = additionalAddressDetail
        self.validate_SimpleText255NotBlankType(self.additionalAddressDetail)
        self.additionalAddressDetail_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleAddressType.subclass:
            return SimpleAddressType.subclass(*args_, **kwargs_)
        else:
            return SimpleAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_countryCode(self):
        return self.countryCode
    def set_countryCode(self, countryCode):
        self.countryCode = countryCode
    def get_region(self):
        return self.region
    def set_region(self, region):
        self.region = region
    def get_postalCode(self):
        return self.postalCode
    def set_postalCode(self, postalCode):
        self.postalCode = postalCode
    def get_city(self):
        return self.city
    def set_city(self, city):
        self.city = city
    def get_additionalAddressDetail(self):
        return self.additionalAddressDetail
    def set_additionalAddressDetail(self, additionalAddressDetail):
        self.additionalAddressDetail = additionalAddressDetail
    def validate_CountryCodeType(self, value):
        result = True
        # Validate type CountryCodeType, a restriction on AtomicStringType2.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on CountryCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CountryCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CountryCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryCodeType_patterns_, ))
                result = False
        return result
    validate_CountryCodeType_patterns_ = [['^([A-Z]{2})$']]
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_PostalCodeType(self, value):
        result = True
        # Validate type PostalCodeType, a restriction on AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PostalCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PostalCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PostalCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PostalCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_PostalCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_PostalCodeType_patterns_, ))
                result = False
        return result
    validate_PostalCodeType_patterns_ = [['^([A-Z0-9][A-Z0-9\\s\\-]{1,8}[A-Z0-9])$']]
    def validate_SimpleText255NotBlankType(self, value):
        result = True
        # Validate type SimpleText255NotBlankType, a restriction on AtomicStringType255.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText255NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText255NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText255NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText255NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText255NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.countryCode is not None or
            self.region is not None or
            self.postalCode is not None or
            self.city is not None or
            self.additionalAddressDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='SimpleAddressType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimpleAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SimpleAddressType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SimpleAddressType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SimpleAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SimpleAddressType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='SimpleAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.countryCode is not None:
            namespaceprefix_ = self.countryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.countryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountryCode>%s</%scountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.countryCode), input_name='countryCode')), namespaceprefix_ , eol_))
        if self.region is not None:
            namespaceprefix_ = self.region_nsprefix_ + ':' if (UseCapturedNS_ and self.region_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregion>%s</%sregion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.region), input_name='region')), namespaceprefix_ , eol_))
        if self.postalCode is not None:
            namespaceprefix_ = self.postalCode_nsprefix_ + ':' if (UseCapturedNS_ and self.postalCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spostalCode>%s</%spostalCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.postalCode), input_name='postalCode')), namespaceprefix_ , eol_))
        if self.city is not None:
            namespaceprefix_ = self.city_nsprefix_ + ':' if (UseCapturedNS_ and self.city_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scity>%s</%scity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), namespaceprefix_ , eol_))
        if self.additionalAddressDetail is not None:
            namespaceprefix_ = self.additionalAddressDetail_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalAddressDetail_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadditionalAddressDetail>%s</%sadditionalAddressDetail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.additionalAddressDetail), input_name='additionalAddressDetail')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='SimpleAddressType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/base}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/base}' + name_, nsmap=nsmap_)
        if self.countryCode is not None:
            countryCode_ = self.countryCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}countryCode').text = self.gds_format_string(countryCode_)
        if self.region is not None:
            region_ = self.region
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}region').text = self.gds_format_string(region_)
        if self.postalCode is not None:
            postalCode_ = self.postalCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}postalCode').text = self.gds_format_string(postalCode_)
        if self.city is not None:
            city_ = self.city
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}city').text = self.gds_format_string(city_)
        if self.additionalAddressDetail is not None:
            additionalAddressDetail_ = self.additionalAddressDetail
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}additionalAddressDetail').text = self.gds_format_string(additionalAddressDetail_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SimpleAddressType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.countryCode is not None:
            showIndent(outfile, level)
            outfile.write('countryCode=%s,\n' % self.gds_encode(quote_python(self.countryCode)))
        if self.region is not None:
            showIndent(outfile, level)
            outfile.write('region=%s,\n' % self.gds_encode(quote_python(self.region)))
        if self.postalCode is not None:
            showIndent(outfile, level)
            outfile.write('postalCode=%s,\n' % self.gds_encode(quote_python(self.postalCode)))
        if self.city is not None:
            showIndent(outfile, level)
            outfile.write('city=%s,\n' % self.gds_encode(quote_python(self.city)))
        if self.additionalAddressDetail is not None:
            showIndent(outfile, level)
            outfile.write('additionalAddressDetail=%s,\n' % self.gds_encode(quote_python(self.additionalAddressDetail)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'countryCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'countryCode')
            value_ = self.gds_validate_string(value_, node, 'countryCode')
            self.countryCode = value_
            self.countryCode_nsprefix_ = child_.prefix
            # validate type CountryCodeType
            self.validate_CountryCodeType(self.countryCode)
        elif nodeName_ == 'region':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'region')
            value_ = self.gds_validate_string(value_, node, 'region')
            self.region = value_
            self.region_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.region)
        elif nodeName_ == 'postalCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'postalCode')
            value_ = self.gds_validate_string(value_, node, 'postalCode')
            self.postalCode = value_
            self.postalCode_nsprefix_ = child_.prefix
            # validate type PostalCodeType
            self.validate_PostalCodeType(self.postalCode)
        elif nodeName_ == 'city':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'city')
            value_ = self.gds_validate_string(value_, node, 'city')
            self.city = value_
            self.city_nsprefix_ = child_.prefix
            # validate type SimpleText255NotBlankType
            self.validate_SimpleText255NotBlankType(self.city)
        elif nodeName_ == 'additionalAddressDetail':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'additionalAddressDetail')
            value_ = self.gds_validate_string(value_, node, 'additionalAddressDetail')
            self.additionalAddressDetail = value_
            self.additionalAddressDetail_nsprefix_ = child_.prefix
            # validate type SimpleText255NotBlankType
            self.validate_SimpleText255NotBlankType(self.additionalAddressDetail)
# end class SimpleAddressType


class TaxNumberType(GeneratedsSuper):
    """TaxNumberType -- Ad
    ó
    sz
    á
    m t
    í
    pus
    Tax number type
    taxpayerId -- Az ad
    ó
    alany ad
    ó
    t
    ö
    rzssz
    á
    ma. Csoportos ad
    ó
    alany eset
    é
    n csoportazonos
    í
    t
    ó
    sz
    á
    m
    Core tax number of the taxable person. In case of group taxation arrangement the group identification number
    vatCode -- Á
    FA k
    ó
    d az ad
    ó
    alanyis
    á
    g t
    í
    pus
    á
    nak jelz
    é
    s
    é
    re. Egy sz
    á
    mjegy
    VAT code to indicate taxation type of the taxpayer. One digit
    countyCode -- Megyek
    ó
    d, k
    é
    t sz
    á
    mjegy
    County code, two digits

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, taxpayerId=None, vatCode=None, countyCode=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.taxpayerId = taxpayerId
        self.validate_TaxpayerIdType(self.taxpayerId)
        self.taxpayerId_nsprefix_ = "common"
        self.vatCode = vatCode
        self.validate_VatCodeType(self.vatCode)
        self.vatCode_nsprefix_ = "common"
        self.countyCode = countyCode
        self.validate_CountyCodeType(self.countyCode)
        self.countyCode_nsprefix_ = "common"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxNumberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxNumberType.subclass:
            return TaxNumberType.subclass(*args_, **kwargs_)
        else:
            return TaxNumberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_taxpayerId(self):
        return self.taxpayerId
    def set_taxpayerId(self, taxpayerId):
        self.taxpayerId = taxpayerId
    def get_vatCode(self):
        return self.vatCode
    def set_vatCode(self, vatCode):
        self.vatCode = vatCode
    def get_countyCode(self):
        return self.countyCode
    def set_countyCode(self, countyCode):
        self.countyCode = countyCode
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_TaxpayerIdType(self, value):
        result = True
        # Validate type TaxpayerIdType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxpayerIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TaxpayerIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TaxpayerIdType_patterns_, ))
                result = False
        return result
    validate_TaxpayerIdType_patterns_ = [['^([0-9]{8})$']]
    def validate_VatCodeType(self, value):
        result = True
        # Validate type VatCodeType, a restriction on AtomicStringType2.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on VatCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on VatCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on VatCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_VatCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_VatCodeType_patterns_, ))
                result = False
        return result
    validate_VatCodeType_patterns_ = [['^([1-5]{1})$']]
    def validate_CountyCodeType(self, value):
        result = True
        # Validate type CountyCodeType, a restriction on AtomicStringType2.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on CountyCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CountyCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CountyCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountyCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountyCodeType_patterns_, ))
                result = False
        return result
    validate_CountyCodeType_patterns_ = [['^([0-9]{2})$']]
    def _hasContent(self):
        if (
            self.taxpayerId is not None or
            self.vatCode is not None or
            self.countyCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='TaxNumberType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxNumberType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxNumberType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxNumberType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxNumberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxNumberType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='TaxNumberType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.taxpayerId is not None:
            namespaceprefix_ = self.taxpayerId_nsprefix_ + ':' if (UseCapturedNS_ and self.taxpayerId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxpayerId>%s</%staxpayerId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxpayerId), input_name='taxpayerId')), namespaceprefix_ , eol_))
        if self.vatCode is not None:
            namespaceprefix_ = self.vatCode_nsprefix_ + ':' if (UseCapturedNS_ and self.vatCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatCode>%s</%svatCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vatCode), input_name='vatCode')), namespaceprefix_ , eol_))
        if self.countyCode is not None:
            namespaceprefix_ = self.countyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.countyCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountyCode>%s</%scountyCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.countyCode), input_name='countyCode')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='TaxNumberType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/base}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/base}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.taxpayerId is not None:
            taxpayerId_ = self.taxpayerId
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}taxpayerId').text = self.gds_format_string(taxpayerId_)
        if self.vatCode is not None:
            vatCode_ = self.vatCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}vatCode').text = self.gds_format_string(vatCode_)
        if self.countyCode is not None:
            countyCode_ = self.countyCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/base}countyCode').text = self.gds_format_string(countyCode_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TaxNumberType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.taxpayerId is not None:
            showIndent(outfile, level)
            outfile.write('taxpayerId=%s,\n' % self.gds_encode(quote_python(self.taxpayerId)))
        if self.vatCode is not None:
            showIndent(outfile, level)
            outfile.write('vatCode=%s,\n' % self.gds_encode(quote_python(self.vatCode)))
        if self.countyCode is not None:
            showIndent(outfile, level)
            outfile.write('countyCode=%s,\n' % self.gds_encode(quote_python(self.countyCode)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'taxpayerId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxpayerId')
            value_ = self.gds_validate_string(value_, node, 'taxpayerId')
            self.taxpayerId = value_
            self.taxpayerId_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.taxpayerId)
        elif nodeName_ == 'vatCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vatCode')
            value_ = self.gds_validate_string(value_, node, 'vatCode')
            self.vatCode = value_
            self.vatCode_nsprefix_ = child_.prefix
            # validate type VatCodeType
            self.validate_VatCodeType(self.vatCode)
        elif nodeName_ == 'countyCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'countyCode')
            value_ = self.gds_validate_string(value_, node, 'countyCode')
            self.countyCode = value_
            self.countyCode_nsprefix_ = child_.prefix
            # validate type CountyCodeType
            self.validate_CountyCodeType(self.countyCode)
# end class TaxNumberType


class AdditionalQueryParamsType(GeneratedsSuper):
    """AdditionalQueryParamsType -- A sz
    á
    mla lek
    é
    rdez
    é
    s kieg
    é
    sz
    í
    t
    ő
    param
    é
    terei
    Additional params of the invoice query
    taxNumber -- A sz
    á
    mla ki
    á
    ll
    í
    t
    ó
    j
    á
    nak vagy vev
    ő
    j
    é
    nek ad
    ó
    sz
    á
    ma (a keres
    é
    si felt
    é
    tel az invoiceDirection tag
    é
    rt
    é
    k
    é
    t
    ő
    l f
    ü
    gg)
    Tax number of the supplier or the customer of the invoice (the search criteria depends on the value of the invoiceDirection tag)
    groupMemberTaxNumber -- A sz
    á
    mla ki
    á
    ll
    í
    t
    ó
    j
    á
    nak vagy vev
    ő
    j
    é
    nek csoport tag ad
    ó
    sz
    á
    ma (a keres
    é
    si felt
    é
    tel az invoiceDirection tag
    é
    rt
    é
    k
    é
    t
    ő
    l f
    ü
    gg)
    Tax number of group member of the supplier or the customer of the invoice (the search criteria depends on the value of the invoiceDirection tag)
    name -- A sz
    á
    mla ki
    á
    ll
    í
    t
    ó
    j
    á
    nak vagy vev
    ő
    j
    é
    nek keres
    ő
    param
    é
    tere sz
    ó
    eleji egyez
    ő
    s
    é
    gre (a keres
    é
    si felt
    é
    tel az invoiceDirection tag
    é
    rt
    é
    k
    é
    t
    ő
    l f
    ü
    gg)
    Query param of the supplier or the customer of the invoice for leading match pattern (the search criteria depends on the value of the invoiceDirection tag)
    invoiceCategory -- A sz
    á
    mla t
    í
    pusa
    Type of invoice
    paymentMethod -- Fizet
    é
    s m
    ó
    dja
    Method of payment
    invoiceAppearance -- A sz
    á
    mla megjelen
    é
    si form
    á
    ja
    Form of appearance of the invoice
    source -- Az adatszolg
    á
    ltat
    á
    s forr
    á
    sa
    Data exchange source
    currency -- A sz
    á
    mla p
    é
    nzneme
    Currency of the invoice

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, taxNumber=None, groupMemberTaxNumber=None, name=None, invoiceCategory=None, paymentMethod=None, invoiceAppearance=None, source=None, currency=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.taxNumber = taxNumber
        self.validate_TaxpayerIdType(self.taxNumber)
        self.taxNumber_nsprefix_ = "common"
        self.groupMemberTaxNumber = groupMemberTaxNumber
        self.validate_TaxpayerIdType(self.groupMemberTaxNumber)
        self.groupMemberTaxNumber_nsprefix_ = "common"
        self.name = name
        self.validate_QueryNameType(self.name)
        self.name_nsprefix_ = None
        self.invoiceCategory = invoiceCategory
        self.validate_InvoiceCategoryType(self.invoiceCategory)
        self.invoiceCategory_nsprefix_ = "base"
        self.paymentMethod = paymentMethod
        self.validate_PaymentMethodType(self.paymentMethod)
        self.paymentMethod_nsprefix_ = "base"
        self.invoiceAppearance = invoiceAppearance
        self.validate_InvoiceAppearanceType(self.invoiceAppearance)
        self.invoiceAppearance_nsprefix_ = "base"
        self.source = source
        self.validate_SourceType(self.source)
        self.source_nsprefix_ = None
        self.currency = currency
        self.validate_CurrencyType(self.currency)
        self.currency_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalQueryParamsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalQueryParamsType.subclass:
            return AdditionalQueryParamsType.subclass(*args_, **kwargs_)
        else:
            return AdditionalQueryParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_taxNumber(self):
        return self.taxNumber
    def set_taxNumber(self, taxNumber):
        self.taxNumber = taxNumber
    def get_groupMemberTaxNumber(self):
        return self.groupMemberTaxNumber
    def set_groupMemberTaxNumber(self, groupMemberTaxNumber):
        self.groupMemberTaxNumber = groupMemberTaxNumber
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_invoiceCategory(self):
        return self.invoiceCategory
    def set_invoiceCategory(self, invoiceCategory):
        self.invoiceCategory = invoiceCategory
    def get_paymentMethod(self):
        return self.paymentMethod
    def set_paymentMethod(self, paymentMethod):
        self.paymentMethod = paymentMethod
    def get_invoiceAppearance(self):
        return self.invoiceAppearance
    def set_invoiceAppearance(self, invoiceAppearance):
        self.invoiceAppearance = invoiceAppearance
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_currency(self):
        return self.currency
    def set_currency(self, currency):
        self.currency = currency
    def validate_TaxpayerIdType(self, value):
        result = True
        # Validate type TaxpayerIdType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxpayerIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TaxpayerIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TaxpayerIdType_patterns_, ))
                result = False
        return result
    validate_TaxpayerIdType_patterns_ = [['^([0-9]{8})$']]
    def validate_QueryNameType(self, value):
        result = True
        # Validate type QueryNameType, a restriction on common:SimpleText512NotBlankType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) < 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on QueryNameType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on QueryNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on QueryNameType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_QueryNameType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_QueryNameType_patterns_, ))
                result = False
        return result
    validate_QueryNameType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceCategoryType(self, value):
        result = True
        # Validate type InvoiceCategoryType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['NORMAL', 'SIMPLIFIED', 'AGGREGATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvoiceCategoryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on InvoiceCategoryType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on InvoiceCategoryType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_PaymentMethodType(self, value):
        result = True
        # Validate type PaymentMethodType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['TRANSFER', 'CASH', 'CARD', 'VOUCHER', 'OTHER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PaymentMethodType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PaymentMethodType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PaymentMethodType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceAppearanceType(self, value):
        result = True
        # Validate type InvoiceAppearanceType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['PAPER', 'ELECTRONIC', 'EDI', 'UNKNOWN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvoiceAppearanceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on InvoiceAppearanceType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on InvoiceAppearanceType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SourceType(self, value):
        result = True
        # Validate type SourceType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['WEB', 'XML', 'MGM', 'OPG', 'OSZ']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SourceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SourceType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SourceType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_CurrencyType(self, value):
        result = True
        # Validate type CurrencyType, a restriction on AtomicStringType4.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on CurrencyType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CurrencyType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CurrencyType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CurrencyType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CurrencyType_patterns_, ))
                result = False
        return result
    validate_CurrencyType_patterns_ = [['^([A-Z]{3})$']]
    def _hasContent(self):
        if (
            self.taxNumber is not None or
            self.groupMemberTaxNumber is not None or
            self.name is not None or
            self.invoiceCategory is not None or
            self.paymentMethod is not None or
            self.invoiceAppearance is not None or
            self.source is not None or
            self.currency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='AdditionalQueryParamsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdditionalQueryParamsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AdditionalQueryParamsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdditionalQueryParamsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AdditionalQueryParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdditionalQueryParamsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='AdditionalQueryParamsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.taxNumber is not None:
            namespaceprefix_ = self.taxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.taxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxNumber>%s</%staxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxNumber), input_name='taxNumber')), namespaceprefix_ , eol_))
        if self.groupMemberTaxNumber is not None:
            namespaceprefix_ = self.groupMemberTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.groupMemberTaxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroupMemberTaxNumber>%s</%sgroupMemberTaxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.groupMemberTaxNumber), input_name='groupMemberTaxNumber')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.invoiceCategory is not None:
            namespaceprefix_ = self.invoiceCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceCategory>%s</%sinvoiceCategory>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceCategory), input_name='invoiceCategory')), namespaceprefix_ , eol_))
        if self.paymentMethod is not None:
            namespaceprefix_ = self.paymentMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.paymentMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaymentMethod>%s</%spaymentMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.paymentMethod), input_name='paymentMethod')), namespaceprefix_ , eol_))
        if self.invoiceAppearance is not None:
            namespaceprefix_ = self.invoiceAppearance_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceAppearance_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceAppearance>%s</%sinvoiceAppearance>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceAppearance), input_name='invoiceAppearance')), namespaceprefix_ , eol_))
        if self.source is not None:
            namespaceprefix_ = self.source_nsprefix_ + ':' if (UseCapturedNS_ and self.source_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespaceprefix_ , eol_))
        if self.currency is not None:
            namespaceprefix_ = self.currency_nsprefix_ + ':' if (UseCapturedNS_ and self.currency_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrency>%s</%scurrency>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.currency), input_name='currency')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='AdditionalQueryParamsType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.taxNumber is not None:
            taxNumber_ = self.taxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}taxNumber').text = self.gds_format_string(taxNumber_)
        if self.groupMemberTaxNumber is not None:
            groupMemberTaxNumber_ = self.groupMemberTaxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}groupMemberTaxNumber').text = self.gds_format_string(groupMemberTaxNumber_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}name').text = self.gds_format_string(name_)
        if self.invoiceCategory is not None:
            invoiceCategory_ = self.invoiceCategory
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceCategory').text = self.gds_format_string(invoiceCategory_)
        if self.paymentMethod is not None:
            paymentMethod_ = self.paymentMethod
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}paymentMethod').text = self.gds_format_string(paymentMethod_)
        if self.invoiceAppearance is not None:
            invoiceAppearance_ = self.invoiceAppearance
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceAppearance').text = self.gds_format_string(invoiceAppearance_)
        if self.source is not None:
            source_ = self.source
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}source').text = self.gds_format_string(source_)
        if self.currency is not None:
            currency_ = self.currency
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}currency').text = self.gds_format_string(currency_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AdditionalQueryParamsType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.taxNumber is not None:
            showIndent(outfile, level)
            outfile.write('taxNumber=%s,\n' % self.gds_encode(quote_python(self.taxNumber)))
        if self.groupMemberTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('groupMemberTaxNumber=%s,\n' % self.gds_encode(quote_python(self.groupMemberTaxNumber)))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % self.gds_encode(quote_python(self.name)))
        if self.invoiceCategory is not None:
            showIndent(outfile, level)
            outfile.write('invoiceCategory=%s,\n' % self.gds_encode(quote_python(self.invoiceCategory)))
        if self.paymentMethod is not None:
            showIndent(outfile, level)
            outfile.write('paymentMethod=%s,\n' % self.gds_encode(quote_python(self.paymentMethod)))
        if self.invoiceAppearance is not None:
            showIndent(outfile, level)
            outfile.write('invoiceAppearance=%s,\n' % self.gds_encode(quote_python(self.invoiceAppearance)))
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=%s,\n' % self.gds_encode(quote_python(self.source)))
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%s,\n' % self.gds_encode(quote_python(self.currency)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'taxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxNumber')
            value_ = self.gds_validate_string(value_, node, 'taxNumber')
            self.taxNumber = value_
            self.taxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.taxNumber)
        elif nodeName_ == 'groupMemberTaxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'groupMemberTaxNumber')
            value_ = self.gds_validate_string(value_, node, 'groupMemberTaxNumber')
            self.groupMemberTaxNumber = value_
            self.groupMemberTaxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.groupMemberTaxNumber)
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type QueryNameType
            self.validate_QueryNameType(self.name)
        elif nodeName_ == 'invoiceCategory':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceCategory')
            value_ = self.gds_validate_string(value_, node, 'invoiceCategory')
            self.invoiceCategory = value_
            self.invoiceCategory_nsprefix_ = child_.prefix
            # validate type InvoiceCategoryType
            self.validate_InvoiceCategoryType(self.invoiceCategory)
        elif nodeName_ == 'paymentMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paymentMethod')
            value_ = self.gds_validate_string(value_, node, 'paymentMethod')
            self.paymentMethod = value_
            self.paymentMethod_nsprefix_ = child_.prefix
            # validate type PaymentMethodType
            self.validate_PaymentMethodType(self.paymentMethod)
        elif nodeName_ == 'invoiceAppearance':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceAppearance')
            value_ = self.gds_validate_string(value_, node, 'invoiceAppearance')
            self.invoiceAppearance = value_
            self.invoiceAppearance_nsprefix_ = child_.prefix
            # validate type InvoiceAppearanceType
            self.validate_InvoiceAppearanceType(self.invoiceAppearance)
        elif nodeName_ == 'source':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'source')
            value_ = self.gds_validate_string(value_, node, 'source')
            self.source = value_
            self.source_nsprefix_ = child_.prefix
            # validate type SourceType
            self.validate_SourceType(self.source)
        elif nodeName_ == 'currency':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'currency')
            value_ = self.gds_validate_string(value_, node, 'currency')
            self.currency = value_
            self.currency_nsprefix_ = child_.prefix
            # validate type CurrencyType
            self.validate_CurrencyType(self.currency)
# end class AdditionalQueryParamsType


class AnnulmentDataType(GeneratedsSuper):
    """AnnulmentDataType -- Technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s st
    á
    tusz adatai
    Status data of technical annulment
    annulmentVerificationStatus -- Technikai
    é
    rv
    é
    nytelen
    í
    t
    ő
    k
    é
    r
    é
    sek j
    ó
    v
    á
    hagy
    á
    si st
    á
    tusza
    Verification status of technical annulment requests
    annulmentDecisionDate -- A technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s j
    ó
    v
    á
    hagy
    á
    s
    á
    nak vagy elutas
    í
    t
    á
    s
    á
    nak id
    ő
    pontja UTC id
    ő
    ben
    Date of verification or rejection of the technical annulment in UTC time
    annulmentDecisionUser -- A technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    st j
    ó
    v
    á
    hagy
    ó
    vagy elutas
    í
    t
    ó
    felhaszn
    á
    l
    ó
    neve
    Login name of the user deciding over the technical annulment's verification or rejection

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, annulmentVerificationStatus=None, annulmentDecisionDate=None, annulmentDecisionUser=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.annulmentVerificationStatus = annulmentVerificationStatus
        self.validate_AnnulmentVerificationStatusType(self.annulmentVerificationStatus)
        self.annulmentVerificationStatus_nsprefix_ = None
        if isinstance(annulmentDecisionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(annulmentDecisionDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = annulmentDecisionDate
        self.annulmentDecisionDate = initvalue_
        self.annulmentDecisionDate_nsprefix_ = "base"
        self.annulmentDecisionUser = annulmentDecisionUser
        self.validate_LoginType(self.annulmentDecisionUser)
        self.annulmentDecisionUser_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnulmentDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnulmentDataType.subclass:
            return AnnulmentDataType.subclass(*args_, **kwargs_)
        else:
            return AnnulmentDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_annulmentVerificationStatus(self):
        return self.annulmentVerificationStatus
    def set_annulmentVerificationStatus(self, annulmentVerificationStatus):
        self.annulmentVerificationStatus = annulmentVerificationStatus
    def get_annulmentDecisionDate(self):
        return self.annulmentDecisionDate
    def set_annulmentDecisionDate(self, annulmentDecisionDate):
        self.annulmentDecisionDate = annulmentDecisionDate
    def get_annulmentDecisionUser(self):
        return self.annulmentDecisionUser
    def set_annulmentDecisionUser(self, annulmentDecisionUser):
        self.annulmentDecisionUser = annulmentDecisionUser
    def validate_AnnulmentVerificationStatusType(self, value):
        result = True
        # Validate type AnnulmentVerificationStatusType, a restriction on common:AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['NOT_VERIFIABLE', 'VERIFICATION_PENDING', 'VERIFICATION_DONE', 'VERIFICATION_REJECTED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AnnulmentVerificationStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on AnnulmentVerificationStatusType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on AnnulmentVerificationStatusType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.fromisostring('2010-01-01T00:00:00.000000').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceTimestampType_patterns_, ))
                result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def validate_LoginType(self, value):
        result = True
        # Validate type LoginType, a restriction on AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LoginType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 6:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LoginType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LoginType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LoginType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_LoginType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_LoginType_patterns_, ))
                result = False
        return result
    validate_LoginType_patterns_ = [['^([a-zA-Z0-9]{6,15})$']]
    def _hasContent(self):
        if (
            self.annulmentVerificationStatus is not None or
            self.annulmentDecisionDate is not None or
            self.annulmentDecisionUser is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='AnnulmentDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnnulmentDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AnnulmentDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnnulmentDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnnulmentDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnnulmentDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='AnnulmentDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.annulmentVerificationStatus is not None:
            namespaceprefix_ = self.annulmentVerificationStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentVerificationStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sannulmentVerificationStatus>%s</%sannulmentVerificationStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.annulmentVerificationStatus), input_name='annulmentVerificationStatus')), namespaceprefix_ , eol_))
        if self.annulmentDecisionDate is not None:
            namespaceprefix_ = self.annulmentDecisionDate_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentDecisionDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sannulmentDecisionDate>%s</%sannulmentDecisionDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.annulmentDecisionDate, input_name='annulmentDecisionDate'), namespaceprefix_ , eol_))
        if self.annulmentDecisionUser is not None:
            namespaceprefix_ = self.annulmentDecisionUser_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentDecisionUser_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sannulmentDecisionUser>%s</%sannulmentDecisionUser>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.annulmentDecisionUser), input_name='annulmentDecisionUser')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='AnnulmentDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.annulmentVerificationStatus is not None:
            annulmentVerificationStatus_ = self.annulmentVerificationStatus
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}annulmentVerificationStatus').text = self.gds_format_string(annulmentVerificationStatus_)
        if self.annulmentDecisionDate is not None:
            annulmentDecisionDate_ = self.annulmentDecisionDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}annulmentDecisionDate').text = self.gds_format_datetime(annulmentDecisionDate_)
        if self.annulmentDecisionUser is not None:
            annulmentDecisionUser_ = self.annulmentDecisionUser
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}annulmentDecisionUser').text = self.gds_format_string(annulmentDecisionUser_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AnnulmentDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.annulmentVerificationStatus is not None:
            showIndent(outfile, level)
            outfile.write('annulmentVerificationStatus=%s,\n' % self.gds_encode(quote_python(self.annulmentVerificationStatus)))
        if self.annulmentDecisionDate is not None:
            showIndent(outfile, level)
            outfile.write('annulmentDecisionDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.annulmentDecisionDate, input_name='annulmentDecisionDate'))
        if self.annulmentDecisionUser is not None:
            showIndent(outfile, level)
            outfile.write('annulmentDecisionUser=%s,\n' % self.gds_encode(quote_python(self.annulmentDecisionUser)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'annulmentVerificationStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'annulmentVerificationStatus')
            value_ = self.gds_validate_string(value_, node, 'annulmentVerificationStatus')
            self.annulmentVerificationStatus = value_
            self.annulmentVerificationStatus_nsprefix_ = child_.prefix
            # validate type AnnulmentVerificationStatusType
            self.validate_AnnulmentVerificationStatusType(self.annulmentVerificationStatus)
        elif nodeName_ == 'annulmentDecisionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.annulmentDecisionDate = dval_
            self.annulmentDecisionDate_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.annulmentDecisionDate)
        elif nodeName_ == 'annulmentDecisionUser':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'annulmentDecisionUser')
            value_ = self.gds_validate_string(value_, node, 'annulmentDecisionUser')
            self.annulmentDecisionUser = value_
            self.annulmentDecisionUser_nsprefix_ = child_.prefix
            # validate type LoginType
            self.validate_LoginType(self.annulmentDecisionUser)
# end class AnnulmentDataType


class AnnulmentOperationListType(GeneratedsSuper):
    """AnnulmentOperationListType -- A k
    é
    r
    é
    shez tartoz
    ó
    k
    ö
    tegelt technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    sek
    Batch technical annulment operations of the request
    annulmentOperation -- A k
    é
    r
    é
    shez tartoz
    ó
    technikai
    é
    rv
    é
    nytelen
    í
    t
    ő
    m
    ű
    velet
    Technical annulment operation of the request

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, annulmentOperation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if annulmentOperation is None:
            self.annulmentOperation = []
        else:
            self.annulmentOperation = annulmentOperation
        self.annulmentOperation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnulmentOperationListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnulmentOperationListType.subclass:
            return AnnulmentOperationListType.subclass(*args_, **kwargs_)
        else:
            return AnnulmentOperationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_annulmentOperation(self):
        return self.annulmentOperation
    def set_annulmentOperation(self, annulmentOperation):
        self.annulmentOperation = annulmentOperation
    def add_annulmentOperation(self, value):
        self.annulmentOperation.append(value)
    def insert_annulmentOperation_at(self, index, value):
        self.annulmentOperation.insert(index, value)
    def replace_annulmentOperation_at(self, index, value):
        self.annulmentOperation[index] = value
    def _hasContent(self):
        if (
            self.annulmentOperation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='AnnulmentOperationListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnnulmentOperationListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AnnulmentOperationListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnnulmentOperationListType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnnulmentOperationListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnnulmentOperationListType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='AnnulmentOperationListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annulmentOperation_ in self.annulmentOperation:
            namespaceprefix_ = self.annulmentOperation_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentOperation_nsprefix_) else ''
            annulmentOperation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annulmentOperation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AnnulmentOperationListType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        for annulmentOperation_ in self.annulmentOperation:
            annulmentOperation_.to_etree(element, name_='annulmentOperation', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AnnulmentOperationListType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('annulmentOperation=[\n')
        level += 1
        for annulmentOperation_ in self.annulmentOperation:
            showIndent(outfile, level)
            outfile.write('model_.AnnulmentOperationType(\n')
            annulmentOperation_.exportLiteral(outfile, level, name_='AnnulmentOperationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'annulmentOperation':
            obj_ = AnnulmentOperationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annulmentOperation.append(obj_)
            obj_.original_tagname_ = 'annulmentOperation'
# end class AnnulmentOperationListType


class AnnulmentOperationType(GeneratedsSuper):
    """AnnulmentOperationType -- A k
    é
    r
    é
    shez tartoz
    ó
    technikai
    é
    rv
    é
    nytelen
    í
    t
    ő
    m
    ű
    velet
    Technical annulment operation of the request
    index -- A technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s sorsz
    á
    ma a k
    é
    r
    é
    sen bel
    ü
    l
    Sequence number of the technical annulment within the request
    annulmentOperation -- A k
    é
    rt technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s m
    ű
    velet t
    í
    pusa
    Type of the desired technical annulment operation
    invoiceAnnulment -- Technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s adatok BASE64-ben k
    ó
    dolt tartalma
    Technical annulment data in BASE64 encoded form

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, index=None, annulmentOperation=None, invoiceAnnulment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.index = index
        self.validate_InvoiceIndexType(self.index)
        self.index_nsprefix_ = "base"
        self.annulmentOperation = annulmentOperation
        self.validate_ManageAnnulmentOperationType(self.annulmentOperation)
        self.annulmentOperation_nsprefix_ = None
        self.invoiceAnnulment = invoiceAnnulment
        self.invoiceAnnulment_nsprefix_ = "xs"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnulmentOperationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnulmentOperationType.subclass:
            return AnnulmentOperationType.subclass(*args_, **kwargs_)
        else:
            return AnnulmentOperationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_annulmentOperation(self):
        return self.annulmentOperation
    def set_annulmentOperation(self, annulmentOperation):
        self.annulmentOperation = annulmentOperation
    def get_invoiceAnnulment(self):
        return self.invoiceAnnulment
    def set_invoiceAnnulment(self, invoiceAnnulment):
        self.invoiceAnnulment = invoiceAnnulment
    def validate_InvoiceIndexType(self, value):
        result = True
        # Validate type InvoiceIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ManageAnnulmentOperationType(self, value):
        result = True
        # Validate type ManageAnnulmentOperationType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['ANNUL']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ManageAnnulmentOperationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ManageAnnulmentOperationType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ManageAnnulmentOperationType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.index is not None or
            self.annulmentOperation is not None or
            self.invoiceAnnulment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='AnnulmentOperationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnnulmentOperationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AnnulmentOperationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnnulmentOperationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnnulmentOperationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnnulmentOperationType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='AnnulmentOperationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.index is not None:
            namespaceprefix_ = self.index_nsprefix_ + ':' if (UseCapturedNS_ and self.index_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindex>%s</%sindex>%s' % (namespaceprefix_ , self.gds_format_integer(self.index, input_name='index'), namespaceprefix_ , eol_))
        if self.annulmentOperation is not None:
            namespaceprefix_ = self.annulmentOperation_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentOperation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sannulmentOperation>%s</%sannulmentOperation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.annulmentOperation), input_name='annulmentOperation')), namespaceprefix_ , eol_))
        if self.invoiceAnnulment is not None:
            namespaceprefix_ = self.invoiceAnnulment_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceAnnulment_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceAnnulment>%s</%sinvoiceAnnulment>%s' % (namespaceprefix_ , self.gds_format_base64(self.invoiceAnnulment, input_name='invoiceAnnulment'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='AnnulmentOperationType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.index is not None:
            index_ = self.index
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}index').text = self.gds_format_integer(index_)
        if self.annulmentOperation is not None:
            annulmentOperation_ = self.annulmentOperation
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}annulmentOperation').text = self.gds_format_string(annulmentOperation_)
        if self.invoiceAnnulment is not None:
            invoiceAnnulment_ = self.invoiceAnnulment
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceAnnulment').text = self.gds_format_base64(invoiceAnnulment_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AnnulmentOperationType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.index is not None:
            showIndent(outfile, level)
            outfile.write('index=%d,\n' % self.index)
        if self.annulmentOperation is not None:
            showIndent(outfile, level)
            outfile.write('annulmentOperation=%s,\n' % self.gds_encode(quote_python(self.annulmentOperation)))
        if self.invoiceAnnulment is not None:
            showIndent(outfile, level)
            outfile.write('invoiceAnnulment=model_.base64Binary(\n')
            self.invoiceAnnulment.exportLiteral(outfile, level, name_='invoiceAnnulment')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'index' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'index')
            ival_ = self.gds_validate_integer(ival_, node, 'index')
            self.index = ival_
            self.index_nsprefix_ = child_.prefix
            # validate type InvoiceIndexType
            self.validate_InvoiceIndexType(self.index)
        elif nodeName_ == 'annulmentOperation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'annulmentOperation')
            value_ = self.gds_validate_string(value_, node, 'annulmentOperation')
            self.annulmentOperation = value_
            self.annulmentOperation_nsprefix_ = child_.prefix
            # validate type ManageAnnulmentOperationType
            self.validate_ManageAnnulmentOperationType(self.annulmentOperation)
        elif nodeName_ == 'invoiceAnnulment':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'invoiceAnnulment')
            else:
                bval_ = None
            self.invoiceAnnulment = bval_
            self.invoiceAnnulment_nsprefix_ = child_.prefix
# end class AnnulmentOperationType


class AuditDataType(GeneratedsSuper):
    """AuditDataType -- A sz
    á
    mla audit adatai
    Invoice audit data
    insdate -- A besz
    ú
    r
    á
    s id
    ő
    pontja UTC id
    ő
    ben
    Insert date in UTC time
    insCusUser -- A besz
    ú
    r
    á
    st v
    é
    gz
    ő
    technikai felhaszn
    á
    l
    ó
    Inserting technical user name
    source -- Az adatszolg
    á
    ltat
    á
    s forr
    á
    sa
    Data exchange source
    transactionId -- A sz
    á
    mla tranzakci
    ó
    azonos
    í
    t
    ó
    ja, ha az g
    é
    pi interf
    é
    szen ker
    ü
    lt bek
    ü
    ld
    é
    sre
    Transaction ID of the invoice if it was exchanged via M2M interface
    index -- A sz
    á
    mla sorsz
    á
    ma a k
    é
    r
    é
    sen bel
    ü
    l
    Sequence number of the invoice within the request
    batchIndex -- A m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma a k
    ö
    tegen bel
    ü
    l
    Sequence number of the modification document within the batch
    originalRequestVersion -- Az adatszolg
    á
    ltat
    á
    s requestVersion
    é
    rt
    é
    ke
    requestVersion value of the invoice exchange

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, insdate=None, insCusUser=None, source=None, transactionId=None, index=None, batchIndex=None, originalRequestVersion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(insdate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(insdate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = insdate
        self.insdate = initvalue_
        self.insdate_nsprefix_ = "base"
        self.insCusUser = insCusUser
        self.validate_LoginType(self.insCusUser)
        self.insCusUser_nsprefix_ = "common"
        self.source = source
        self.validate_SourceType(self.source)
        self.source_nsprefix_ = None
        self.transactionId = transactionId
        self.validate_EntityIdType(self.transactionId)
        self.transactionId_nsprefix_ = "common"
        self.index = index
        self.validate_InvoiceIndexType(self.index)
        self.index_nsprefix_ = "base"
        self.batchIndex = batchIndex
        self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        self.batchIndex_nsprefix_ = "base"
        self.originalRequestVersion = originalRequestVersion
        self.validate_OriginalRequestVersionType(self.originalRequestVersion)
        self.originalRequestVersion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuditDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuditDataType.subclass:
            return AuditDataType.subclass(*args_, **kwargs_)
        else:
            return AuditDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_insdate(self):
        return self.insdate
    def set_insdate(self, insdate):
        self.insdate = insdate
    def get_insCusUser(self):
        return self.insCusUser
    def set_insCusUser(self, insCusUser):
        self.insCusUser = insCusUser
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_transactionId(self):
        return self.transactionId
    def set_transactionId(self, transactionId):
        self.transactionId = transactionId
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_batchIndex(self):
        return self.batchIndex
    def set_batchIndex(self, batchIndex):
        self.batchIndex = batchIndex
    def get_originalRequestVersion(self):
        return self.originalRequestVersion
    def set_originalRequestVersion(self, originalRequestVersion):
        self.originalRequestVersion = originalRequestVersion
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.fromisostring('2010-01-01T00:00:00.000000').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceTimestampType_patterns_, ))
                result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def validate_LoginType(self, value):
        result = True
        # Validate type LoginType, a restriction on AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LoginType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 6:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LoginType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LoginType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LoginType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_LoginType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_LoginType_patterns_, ))
                result = False
        return result
    validate_LoginType_patterns_ = [['^([a-zA-Z0-9]{6,15})$']]
    def validate_SourceType(self, value):
        result = True
        # Validate type SourceType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['WEB', 'XML', 'MGM', 'OPG', 'OSZ']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SourceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SourceType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SourceType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_EntityIdType(self, value):
        result = True
        # Validate type EntityIdType, a restriction on AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityIdType_patterns_, ))
                result = False
        return result
    validate_EntityIdType_patterns_ = [['^([+a-zA-Z0-9_]{1,30})$']]
    def validate_InvoiceIndexType(self, value):
        result = True
        # Validate type InvoiceIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceUnboundedIndexType(self, value):
        result = True
        # Validate type InvoiceUnboundedIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceUnboundedIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_OriginalRequestVersionType(self, value):
        result = True
        # Validate type OriginalRequestVersionType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['1.0', '1.1', '2.0', '3.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OriginalRequestVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OriginalRequestVersionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on OriginalRequestVersionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.insdate is not None or
            self.insCusUser is not None or
            self.source is not None or
            self.transactionId is not None or
            self.index is not None or
            self.batchIndex is not None or
            self.originalRequestVersion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='AuditDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AuditDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AuditDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AuditDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AuditDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AuditDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='AuditDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.insdate is not None:
            namespaceprefix_ = self.insdate_nsprefix_ + ':' if (UseCapturedNS_ and self.insdate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinsdate>%s</%sinsdate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.insdate, input_name='insdate'), namespaceprefix_ , eol_))
        if self.insCusUser is not None:
            namespaceprefix_ = self.insCusUser_nsprefix_ + ':' if (UseCapturedNS_ and self.insCusUser_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinsCusUser>%s</%sinsCusUser>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.insCusUser), input_name='insCusUser')), namespaceprefix_ , eol_))
        if self.source is not None:
            namespaceprefix_ = self.source_nsprefix_ + ':' if (UseCapturedNS_ and self.source_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespaceprefix_ , eol_))
        if self.transactionId is not None:
            namespaceprefix_ = self.transactionId_nsprefix_ + ':' if (UseCapturedNS_ and self.transactionId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransactionId>%s</%stransactionId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.transactionId), input_name='transactionId')), namespaceprefix_ , eol_))
        if self.index is not None:
            namespaceprefix_ = self.index_nsprefix_ + ':' if (UseCapturedNS_ and self.index_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindex>%s</%sindex>%s' % (namespaceprefix_ , self.gds_format_integer(self.index, input_name='index'), namespaceprefix_ , eol_))
        if self.batchIndex is not None:
            namespaceprefix_ = self.batchIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.batchIndex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbatchIndex>%s</%sbatchIndex>%s' % (namespaceprefix_ , self.gds_format_integer(self.batchIndex, input_name='batchIndex'), namespaceprefix_ , eol_))
        if self.originalRequestVersion is not None:
            namespaceprefix_ = self.originalRequestVersion_nsprefix_ + ':' if (UseCapturedNS_ and self.originalRequestVersion_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalRequestVersion>%s</%soriginalRequestVersion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originalRequestVersion), input_name='originalRequestVersion')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='AuditDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.insdate is not None:
            insdate_ = self.insdate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}insdate').text = self.gds_format_datetime(insdate_)
        if self.insCusUser is not None:
            insCusUser_ = self.insCusUser
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}insCusUser').text = self.gds_format_string(insCusUser_)
        if self.source is not None:
            source_ = self.source
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}source').text = self.gds_format_string(source_)
        if self.transactionId is not None:
            transactionId_ = self.transactionId
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}transactionId').text = self.gds_format_string(transactionId_)
        if self.index is not None:
            index_ = self.index
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}index').text = self.gds_format_integer(index_)
        if self.batchIndex is not None:
            batchIndex_ = self.batchIndex
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}batchIndex').text = self.gds_format_integer(batchIndex_)
        if self.originalRequestVersion is not None:
            originalRequestVersion_ = self.originalRequestVersion
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}originalRequestVersion').text = self.gds_format_string(originalRequestVersion_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AuditDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.insdate is not None:
            showIndent(outfile, level)
            outfile.write('insdate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.insdate, input_name='insdate'))
        if self.insCusUser is not None:
            showIndent(outfile, level)
            outfile.write('insCusUser=%s,\n' % self.gds_encode(quote_python(self.insCusUser)))
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=%s,\n' % self.gds_encode(quote_python(self.source)))
        if self.transactionId is not None:
            showIndent(outfile, level)
            outfile.write('transactionId=%s,\n' % self.gds_encode(quote_python(self.transactionId)))
        if self.index is not None:
            showIndent(outfile, level)
            outfile.write('index=%d,\n' % self.index)
        if self.batchIndex is not None:
            showIndent(outfile, level)
            outfile.write('batchIndex=%d,\n' % self.batchIndex)
        if self.originalRequestVersion is not None:
            showIndent(outfile, level)
            outfile.write('originalRequestVersion=%s,\n' % self.gds_encode(quote_python(self.originalRequestVersion)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'insdate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.insdate = dval_
            self.insdate_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.insdate)
        elif nodeName_ == 'insCusUser':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'insCusUser')
            value_ = self.gds_validate_string(value_, node, 'insCusUser')
            self.insCusUser = value_
            self.insCusUser_nsprefix_ = child_.prefix
            # validate type LoginType
            self.validate_LoginType(self.insCusUser)
        elif nodeName_ == 'source':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'source')
            value_ = self.gds_validate_string(value_, node, 'source')
            self.source = value_
            self.source_nsprefix_ = child_.prefix
            # validate type SourceType
            self.validate_SourceType(self.source)
        elif nodeName_ == 'transactionId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'transactionId')
            value_ = self.gds_validate_string(value_, node, 'transactionId')
            self.transactionId = value_
            self.transactionId_nsprefix_ = child_.prefix
            # validate type EntityIdType
            self.validate_EntityIdType(self.transactionId)
        elif nodeName_ == 'index' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'index')
            ival_ = self.gds_validate_integer(ival_, node, 'index')
            self.index = ival_
            self.index_nsprefix_ = child_.prefix
            # validate type InvoiceIndexType
            self.validate_InvoiceIndexType(self.index)
        elif nodeName_ == 'batchIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'batchIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'batchIndex')
            self.batchIndex = ival_
            self.batchIndex_nsprefix_ = child_.prefix
            # validate type InvoiceUnboundedIndexType
            self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        elif nodeName_ == 'originalRequestVersion':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originalRequestVersion')
            value_ = self.gds_validate_string(value_, node, 'originalRequestVersion')
            self.originalRequestVersion = value_
            self.originalRequestVersion_nsprefix_ = child_.prefix
            # validate type OriginalRequestVersionType
            self.validate_OriginalRequestVersionType(self.originalRequestVersion)
# end class AuditDataType


class BasicOnlineInvoiceRequestType(BasicRequestType):
    """BasicOnlineInvoiceRequestType -- Online Sz
    á
    mla rendszerre specifikus
    á
    ltal
    á
    nos k
    é
    r
    é
    s adatok
    Online Invoice specific basic request data
    software -- A sz
    á
    ml
    á
    z
    ó
    program adatai
    Billing software data

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicRequestType
    def __init__(self, header=None, user=None, software=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BasicOnlineInvoiceRequestType"), self).__init__(header, user, extensiontype_,  **kwargs_)
        self.software = software
        self.software_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasicOnlineInvoiceRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasicOnlineInvoiceRequestType.subclass:
            return BasicOnlineInvoiceRequestType.subclass(*args_, **kwargs_)
        else:
            return BasicOnlineInvoiceRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_software(self):
        return self.software
    def set_software(self, software):
        self.software = software
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.software is not None or
            super(BasicOnlineInvoiceRequestType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicOnlineInvoiceRequestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BasicOnlineInvoiceRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BasicOnlineInvoiceRequestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasicOnlineInvoiceRequestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BasicOnlineInvoiceRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BasicOnlineInvoiceRequestType'):
        super(BasicOnlineInvoiceRequestType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasicOnlineInvoiceRequestType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicOnlineInvoiceRequestType', fromsubclass_=False, pretty_print=True):
        super(BasicOnlineInvoiceRequestType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.software is not None:
            namespaceprefix_ = self.software_nsprefix_ + ':' if (UseCapturedNS_ and self.software_nsprefix_) else ''
            self.software.export(outfile, level, namespaceprefix_, namespacedef_='', name_='software', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BasicOnlineInvoiceRequestType', mapping_=None, nsmap_=None):
        element = super(BasicOnlineInvoiceRequestType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.software is not None:
            software_ = self.software
            software_.to_etree(element, name_='software', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='BasicOnlineInvoiceRequestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BasicOnlineInvoiceRequestType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(BasicOnlineInvoiceRequestType, self)._exportLiteralChildren(outfile, level, name_)
        if self.software is not None:
            showIndent(outfile, level)
            outfile.write('software=model_.SoftwareType(\n')
            self.software.exportLiteral(outfile, level, name_='software')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BasicOnlineInvoiceRequestType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'software':
            obj_ = SoftwareType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.software = obj_
            obj_.original_tagname_ = 'software'
        super(BasicOnlineInvoiceRequestType, self)._buildChildren(child_, node, nodeName_, True)
# end class BasicOnlineInvoiceRequestType


class BasicOnlineInvoiceResponseType(BasicResponseType):
    """BasicOnlineInvoiceResponseType -- Online Sz
    á
    mla rendszerre specifikus
    á
    ltal
    á
    nos v
    á
    lasz adatok
    Online Invoice specific basic response data
    software -- A sz
    á
    ml
    á
    z
    ó
    program adatai
    Billing software data

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicResponseType
    def __init__(self, header=None, result=None, software=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BasicOnlineInvoiceResponseType"), self).__init__(header, result, extensiontype_,  **kwargs_)
        self.software = software
        self.software_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasicOnlineInvoiceResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasicOnlineInvoiceResponseType.subclass:
            return BasicOnlineInvoiceResponseType.subclass(*args_, **kwargs_)
        else:
            return BasicOnlineInvoiceResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_software(self):
        return self.software
    def set_software(self, software):
        self.software = software
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.software is not None or
            super(BasicOnlineInvoiceResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicOnlineInvoiceResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BasicOnlineInvoiceResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BasicOnlineInvoiceResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasicOnlineInvoiceResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BasicOnlineInvoiceResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BasicOnlineInvoiceResponseType'):
        super(BasicOnlineInvoiceResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasicOnlineInvoiceResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BasicOnlineInvoiceResponseType', fromsubclass_=False, pretty_print=True):
        super(BasicOnlineInvoiceResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.software is not None:
            namespaceprefix_ = self.software_nsprefix_ + ':' if (UseCapturedNS_ and self.software_nsprefix_) else ''
            self.software.export(outfile, level, namespaceprefix_, namespacedef_='', name_='software', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BasicOnlineInvoiceResponseType', mapping_=None, nsmap_=None):
        element = super(BasicOnlineInvoiceResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.software is not None:
            software_ = self.software
            software_.to_etree(element, name_='software', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='BasicOnlineInvoiceResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BasicOnlineInvoiceResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(BasicOnlineInvoiceResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.software is not None:
            showIndent(outfile, level)
            outfile.write('software=model_.SoftwareType(\n')
            self.software.exportLiteral(outfile, level, name_='software')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BasicOnlineInvoiceResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'software':
            obj_ = SoftwareType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.software = obj_
            obj_.original_tagname_ = 'software'
        super(BasicOnlineInvoiceResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class BasicOnlineInvoiceResponseType


class BusinessValidationResultType(GeneratedsSuper):
    """BusinessValidationResultType -- Ü
    zleti valid
    á
    ci
    ó
    s v
    á
    laszt
    í
    pus
    Business validation response type
    validationResultCode -- Valid
    á
    ci
    ó
    s eredm
    é
    ny
    Validation result
    validationErrorCode -- Valid
    á
    ci
    ó
    s hibak
    ó
    d
    Validation error code
    message -- Feldolgoz
    á
    si
    ü
    zenet
    Processing message
    pointer -- Feldolgoz
    á
    si kurzor adatok
    Processing cursor data

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, validationResultCode=None, validationErrorCode=None, message=None, pointer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.validationResultCode = validationResultCode
        self.validate_BusinessResultCodeType(self.validationResultCode)
        self.validationResultCode_nsprefix_ = "common"
        self.validationErrorCode = validationErrorCode
        self.validate_SimpleText100NotBlankType(self.validationErrorCode)
        self.validationErrorCode_nsprefix_ = "common"
        self.message = message
        self.validate_SimpleText512NotBlankType(self.message)
        self.message_nsprefix_ = "common"
        self.pointer = pointer
        self.pointer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusinessValidationResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusinessValidationResultType.subclass:
            return BusinessValidationResultType.subclass(*args_, **kwargs_)
        else:
            return BusinessValidationResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_validationResultCode(self):
        return self.validationResultCode
    def set_validationResultCode(self, validationResultCode):
        self.validationResultCode = validationResultCode
    def get_validationErrorCode(self):
        return self.validationErrorCode
    def set_validationErrorCode(self, validationErrorCode):
        self.validationErrorCode = validationErrorCode
    def get_message(self):
        return self.message
    def set_message(self, message):
        self.message = message
    def get_pointer(self):
        return self.pointer
    def set_pointer(self, pointer):
        self.pointer = pointer
    def validate_BusinessResultCodeType(self, value):
        result = True
        # Validate type BusinessResultCodeType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['ERROR', 'WARN', 'INFO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BusinessResultCodeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on BusinessResultCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on BusinessResultCodeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.validationResultCode is not None or
            self.validationErrorCode is not None or
            self.message is not None or
            self.pointer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BusinessValidationResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BusinessValidationResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BusinessValidationResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BusinessValidationResultType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BusinessValidationResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BusinessValidationResultType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BusinessValidationResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.validationResultCode is not None:
            namespaceprefix_ = self.validationResultCode_nsprefix_ + ':' if (UseCapturedNS_ and self.validationResultCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalidationResultCode>%s</%svalidationResultCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.validationResultCode), input_name='validationResultCode')), namespaceprefix_ , eol_))
        if self.validationErrorCode is not None:
            namespaceprefix_ = self.validationErrorCode_nsprefix_ + ':' if (UseCapturedNS_ and self.validationErrorCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalidationErrorCode>%s</%svalidationErrorCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.validationErrorCode), input_name='validationErrorCode')), namespaceprefix_ , eol_))
        if self.message is not None:
            namespaceprefix_ = self.message_nsprefix_ + ':' if (UseCapturedNS_ and self.message_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smessage>%s</%smessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.message), input_name='message')), namespaceprefix_ , eol_))
        if self.pointer is not None:
            namespaceprefix_ = self.pointer_nsprefix_ + ':' if (UseCapturedNS_ and self.pointer_nsprefix_) else ''
            self.pointer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pointer', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BusinessValidationResultType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.validationResultCode is not None:
            validationResultCode_ = self.validationResultCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}validationResultCode').text = self.gds_format_string(validationResultCode_)
        if self.validationErrorCode is not None:
            validationErrorCode_ = self.validationErrorCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}validationErrorCode').text = self.gds_format_string(validationErrorCode_)
        if self.message is not None:
            message_ = self.message
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}message').text = self.gds_format_string(message_)
        if self.pointer is not None:
            pointer_ = self.pointer
            pointer_.to_etree(element, name_='pointer', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='BusinessValidationResultType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.validationResultCode is not None:
            showIndent(outfile, level)
            outfile.write('validationResultCode=%s,\n' % self.gds_encode(quote_python(self.validationResultCode)))
        if self.validationErrorCode is not None:
            showIndent(outfile, level)
            outfile.write('validationErrorCode=%s,\n' % self.gds_encode(quote_python(self.validationErrorCode)))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % self.gds_encode(quote_python(self.message)))
        if self.pointer is not None:
            showIndent(outfile, level)
            outfile.write('pointer=model_.PointerType(\n')
            self.pointer.exportLiteral(outfile, level, name_='pointer')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'validationResultCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validationResultCode')
            value_ = self.gds_validate_string(value_, node, 'validationResultCode')
            self.validationResultCode = value_
            self.validationResultCode_nsprefix_ = child_.prefix
            # validate type BusinessResultCodeType
            self.validate_BusinessResultCodeType(self.validationResultCode)
        elif nodeName_ == 'validationErrorCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'validationErrorCode')
            value_ = self.gds_validate_string(value_, node, 'validationErrorCode')
            self.validationErrorCode = value_
            self.validationErrorCode_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.validationErrorCode)
        elif nodeName_ == 'message':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'message')
            value_ = self.gds_validate_string(value_, node, 'message')
            self.message = value_
            self.message_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.message)
        elif nodeName_ == 'pointer':
            obj_ = PointerType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pointer = obj_
            obj_.original_tagname_ = 'pointer'
# end class BusinessValidationResultType


class DateIntervalParamType(GeneratedsSuper):
    """DateIntervalParamType -- D
    á
    tumos sz
    á
    mla keres
    ő
    param
    é
    ter
    Date query params of invoice
    dateFrom -- D
    á
    tum intervallum nagyobb vagy egyenl
    ő
    param
    é
    tere
    Date interval greater or equals parameter
    dateTo -- D
    á
    tum intervallum kisebb vagy egyenl
    ő
    param
    é
    tere
    Date interval less or equals parameter

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateFrom=None, dateTo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(dateFrom, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateFrom, '%Y-%m-%d').date()
        else:
            initvalue_ = dateFrom
        self.dateFrom = initvalue_
        self.dateFrom_nsprefix_ = "base"
        if isinstance(dateTo, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateTo, '%Y-%m-%d').date()
        else:
            initvalue_ = dateTo
        self.dateTo = initvalue_
        self.dateTo_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateIntervalParamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateIntervalParamType.subclass:
            return DateIntervalParamType.subclass(*args_, **kwargs_)
        else:
            return DateIntervalParamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateFrom(self):
        return self.dateFrom
    def set_dateFrom(self, dateFrom):
        self.dateFrom = dateFrom
    def get_dateTo(self):
        return self.dateTo
    def set_dateTo(self, dateTo):
        self.dateTo = dateTo
    def validate_InvoiceDateType(self, value):
        result = True
        # Validate type InvoiceDateType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.strptime('2010-01-01', '%Y-%m-%d').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceDateType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceDateType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceDateType_patterns_, ))
                result = False
        return result
    validate_InvoiceDateType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2})$']]
    def _hasContent(self):
        if (
            self.dateFrom is not None or
            self.dateTo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='DateIntervalParamType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateIntervalParamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DateIntervalParamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DateIntervalParamType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DateIntervalParamType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DateIntervalParamType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='DateIntervalParamType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateFrom is not None:
            namespaceprefix_ = self.dateFrom_nsprefix_ + ':' if (UseCapturedNS_ and self.dateFrom_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateFrom>%s</%sdateFrom>%s' % (namespaceprefix_ , self.gds_format_date(self.dateFrom, input_name='dateFrom'), namespaceprefix_ , eol_))
        if self.dateTo is not None:
            namespaceprefix_ = self.dateTo_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateTo>%s</%sdateTo>%s' % (namespaceprefix_ , self.gds_format_date(self.dateTo, input_name='dateTo'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='DateIntervalParamType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.dateFrom is not None:
            dateFrom_ = self.dateFrom
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}dateFrom').text = self.gds_format_date(dateFrom_)
        if self.dateTo is not None:
            dateTo_ = self.dateTo
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}dateTo').text = self.gds_format_date(dateTo_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DateIntervalParamType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.dateFrom is not None:
            showIndent(outfile, level)
            outfile.write('dateFrom=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.dateFrom, input_name='dateFrom'))
        if self.dateTo is not None:
            showIndent(outfile, level)
            outfile.write('dateTo=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.dateTo, input_name='dateTo'))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateFrom':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dateFrom = dval_
            self.dateFrom_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.dateFrom)
        elif nodeName_ == 'dateTo':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dateTo = dval_
            self.dateTo_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.dateTo)
# end class DateIntervalParamType


class DateTimeIntervalParamType(GeneratedsSuper):
    """DateTimeIntervalParamType -- Id
    ő
    pontos sz
    á
    mla keres
    ő
    param
    é
    ter
    Datestamp query params of invoice
    dateTimeFrom -- Id
    ő
    pontos intervallum nagyobb vagy egyenl
    ő
    param
    é
    tere UTC id
    ő
    szerint
    Datetime interval greater or equals parameter
    dateTimeTo -- Id
    ő
    pontos intervallum kisebb vagy egyenl
    ő
    param
    é
    tere UTC id
    ő
    szerint
    Datetime interval less or equals parameter

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateTimeFrom=None, dateTimeTo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(dateTimeFrom, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateTimeFrom, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateTimeFrom
        self.dateTimeFrom = initvalue_
        self.dateTimeFrom_nsprefix_ = "base"
        if isinstance(dateTimeTo, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateTimeTo, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateTimeTo
        self.dateTimeTo = initvalue_
        self.dateTimeTo_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateTimeIntervalParamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateTimeIntervalParamType.subclass:
            return DateTimeIntervalParamType.subclass(*args_, **kwargs_)
        else:
            return DateTimeIntervalParamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateTimeFrom(self):
        return self.dateTimeFrom
    def set_dateTimeFrom(self, dateTimeFrom):
        self.dateTimeFrom = dateTimeFrom
    def get_dateTimeTo(self):
        return self.dateTimeTo
    def set_dateTimeTo(self, dateTimeTo):
        self.dateTimeTo = dateTimeTo
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.fromisostring('2010-01-01T00:00:00.000000').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceTimestampType_patterns_, ))
                result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def _hasContent(self):
        if (
            self.dateTimeFrom is not None or
            self.dateTimeTo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='DateTimeIntervalParamType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateTimeIntervalParamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DateTimeIntervalParamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DateTimeIntervalParamType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DateTimeIntervalParamType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DateTimeIntervalParamType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='DateTimeIntervalParamType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTimeFrom is not None:
            namespaceprefix_ = self.dateTimeFrom_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTimeFrom_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateTimeFrom>%s</%sdateTimeFrom>%s' % (namespaceprefix_ , self.gds_format_datetime(self.dateTimeFrom, input_name='dateTimeFrom'), namespaceprefix_ , eol_))
        if self.dateTimeTo is not None:
            namespaceprefix_ = self.dateTimeTo_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTimeTo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdateTimeTo>%s</%sdateTimeTo>%s' % (namespaceprefix_ , self.gds_format_datetime(self.dateTimeTo, input_name='dateTimeTo'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='DateTimeIntervalParamType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.dateTimeFrom is not None:
            dateTimeFrom_ = self.dateTimeFrom
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}dateTimeFrom').text = self.gds_format_datetime(dateTimeFrom_)
        if self.dateTimeTo is not None:
            dateTimeTo_ = self.dateTimeTo
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}dateTimeTo').text = self.gds_format_datetime(dateTimeTo_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DateTimeIntervalParamType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.dateTimeFrom is not None:
            showIndent(outfile, level)
            outfile.write('dateTimeFrom=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.dateTimeFrom, input_name='dateTimeFrom'))
        if self.dateTimeTo is not None:
            showIndent(outfile, level)
            outfile.write('dateTimeTo=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.dateTimeTo, input_name='dateTimeTo'))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateTimeFrom':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTimeFrom = dval_
            self.dateTimeFrom_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.dateTimeFrom)
        elif nodeName_ == 'dateTimeTo':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dateTimeTo = dval_
            self.dateTimeTo_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.dateTimeTo)
# end class DateTimeIntervalParamType


class GeneralErrorResponseType(GeneralErrorHeaderResponseType):
    """GeneralErrorResponseType -- Online Sz
    á
    mla rendszerre specifikus
    á
    ltal
    á
    nos hibav
    á
    lasz t
    í
    pus
    Online Invoice specific general error response type
    software -- A sz
    á
    ml
    á
    z
    ó
    program adatai
    Billing software data
    technicalValidationMessages -- Technikai valid
    á
    ci
    ó
    s
    ü
    zenetek
    Technical validation messages

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = GeneralErrorHeaderResponseType
    def __init__(self, header=None, result=None, software=None, technicalValidationMessages=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("GeneralErrorResponseType"), self).__init__(header, result, extensiontype_,  **kwargs_)
        self.software = software
        self.software_nsprefix_ = None
        if technicalValidationMessages is None:
            self.technicalValidationMessages = []
        else:
            self.technicalValidationMessages = technicalValidationMessages
        self.technicalValidationMessages_nsprefix_ = "common"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralErrorResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralErrorResponseType.subclass:
            return GeneralErrorResponseType.subclass(*args_, **kwargs_)
        else:
            return GeneralErrorResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_software(self):
        return self.software
    def set_software(self, software):
        self.software = software
    def get_technicalValidationMessages(self):
        return self.technicalValidationMessages
    def set_technicalValidationMessages(self, technicalValidationMessages):
        self.technicalValidationMessages = technicalValidationMessages
    def add_technicalValidationMessages(self, value):
        self.technicalValidationMessages.append(value)
    def insert_technicalValidationMessages_at(self, index, value):
        self.technicalValidationMessages.insert(index, value)
    def replace_technicalValidationMessages_at(self, index, value):
        self.technicalValidationMessages[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.software is not None or
            self.technicalValidationMessages or
            super(GeneralErrorResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='GeneralErrorResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralErrorResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeneralErrorResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralErrorResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeneralErrorResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeneralErrorResponseType'):
        super(GeneralErrorResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralErrorResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='GeneralErrorResponseType', fromsubclass_=False, pretty_print=True):
        super(GeneralErrorResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.software is not None:
            namespaceprefix_ = self.software_nsprefix_ + ':' if (UseCapturedNS_ and self.software_nsprefix_) else ''
            self.software.export(outfile, level, namespaceprefix_, namespacedef_='', name_='software', pretty_print=pretty_print)
        for technicalValidationMessages_ in self.technicalValidationMessages:
            namespaceprefix_ = self.technicalValidationMessages_nsprefix_ + ':' if (UseCapturedNS_ and self.technicalValidationMessages_nsprefix_) else ''
            technicalValidationMessages_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='technicalValidationMessages', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GeneralErrorResponseType', mapping_=None, nsmap_=None):
        element = super(GeneralErrorResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.software is not None:
            software_ = self.software
            software_.to_etree(element, name_='software', mapping_=mapping_, nsmap_=nsmap_)
        for technicalValidationMessages_ in self.technicalValidationMessages:
            technicalValidationMessages_.to_etree(element, name_='technicalValidationMessages', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='GeneralErrorResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GeneralErrorResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(GeneralErrorResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.software is not None:
            showIndent(outfile, level)
            outfile.write('software=model_.SoftwareType(\n')
            self.software.exportLiteral(outfile, level, name_='software')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('technicalValidationMessages=[\n')
        level += 1
        for technicalValidationMessages_ in self.technicalValidationMessages:
            showIndent(outfile, level)
            outfile.write('model_.TechnicalValidationResultType(\n')
            technicalValidationMessages_.exportLiteral(outfile, level, name_='TechnicalValidationResultType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(GeneralErrorResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'software':
            obj_ = SoftwareType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.software = obj_
            obj_.original_tagname_ = 'software'
        elif nodeName_ == 'technicalValidationMessages':
            obj_ = TechnicalValidationResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.technicalValidationMessages.append(obj_)
            obj_.original_tagname_ = 'technicalValidationMessages'
        super(GeneralErrorResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class GeneralErrorResponseType


class InvoiceChainDigestResultType(GeneratedsSuper):
    """InvoiceChainDigestResultType -- Sz
    á
    mlal
    á
    nc kivonat lek
    é
    rdez
    é
    s eredm
    é
    nyei
    Invoice chain digest query result
    currentPage -- A jelenleg lek
    é
    rdezett lapsz
    á
    m
    The currently queried page count
    availablePage -- A lek
    é
    rdez
    é
    s eredm
    é
    nye szerint el
    é
    rhet
    ő
    utols
    ó
    lapsz
    á
    m
    The highest available page count matching the query
    invoiceChainElement -- Sz
    á
    mlal
    á
    nc elem
    Invoice chain element

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, currentPage=None, availablePage=None, invoiceChainElement=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currentPage = currentPage
        self.validate_ResponsePageType(self.currentPage)
        self.currentPage_nsprefix_ = "common"
        self.availablePage = availablePage
        self.validate_ResponsePageType(self.availablePage)
        self.availablePage_nsprefix_ = "common"
        if invoiceChainElement is None:
            self.invoiceChainElement = []
        else:
            self.invoiceChainElement = invoiceChainElement
        self.invoiceChainElement_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceChainDigestResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceChainDigestResultType.subclass:
            return InvoiceChainDigestResultType.subclass(*args_, **kwargs_)
        else:
            return InvoiceChainDigestResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_currentPage(self):
        return self.currentPage
    def set_currentPage(self, currentPage):
        self.currentPage = currentPage
    def get_availablePage(self):
        return self.availablePage
    def set_availablePage(self, availablePage):
        self.availablePage = availablePage
    def get_invoiceChainElement(self):
        return self.invoiceChainElement
    def set_invoiceChainElement(self, invoiceChainElement):
        self.invoiceChainElement = invoiceChainElement
    def add_invoiceChainElement(self, value):
        self.invoiceChainElement.append(value)
    def insert_invoiceChainElement_at(self, index, value):
        self.invoiceChainElement.insert(index, value)
    def replace_invoiceChainElement_at(self, index, value):
        self.invoiceChainElement[index] = value
    def validate_ResponsePageType(self, value):
        result = True
        # Validate type ResponsePageType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ResponsePageType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.currentPage is not None or
            self.availablePage is not None or
            self.invoiceChainElement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceChainDigestResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceChainDigestResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceChainDigestResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceChainDigestResultType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceChainDigestResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceChainDigestResultType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceChainDigestResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currentPage is not None:
            namespaceprefix_ = self.currentPage_nsprefix_ + ':' if (UseCapturedNS_ and self.currentPage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentPage>%s</%scurrentPage>%s' % (namespaceprefix_ , self.gds_format_integer(self.currentPage, input_name='currentPage'), namespaceprefix_ , eol_))
        if self.availablePage is not None:
            namespaceprefix_ = self.availablePage_nsprefix_ + ':' if (UseCapturedNS_ and self.availablePage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailablePage>%s</%savailablePage>%s' % (namespaceprefix_ , self.gds_format_integer(self.availablePage, input_name='availablePage'), namespaceprefix_ , eol_))
        for invoiceChainElement_ in self.invoiceChainElement:
            namespaceprefix_ = self.invoiceChainElement_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceChainElement_nsprefix_) else ''
            invoiceChainElement_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceChainElement', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceChainDigestResultType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.currentPage is not None:
            currentPage_ = self.currentPage
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}currentPage').text = self.gds_format_integer(currentPage_)
        if self.availablePage is not None:
            availablePage_ = self.availablePage
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}availablePage').text = self.gds_format_integer(availablePage_)
        for invoiceChainElement_ in self.invoiceChainElement:
            invoiceChainElement_.to_etree(element, name_='invoiceChainElement', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceChainDigestResultType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.currentPage is not None:
            showIndent(outfile, level)
            outfile.write('currentPage=%d,\n' % self.currentPage)
        if self.availablePage is not None:
            showIndent(outfile, level)
            outfile.write('availablePage=%d,\n' % self.availablePage)
        showIndent(outfile, level)
        outfile.write('invoiceChainElement=[\n')
        level += 1
        for invoiceChainElement_ in self.invoiceChainElement:
            showIndent(outfile, level)
            outfile.write('model_.InvoiceChainElementType(\n')
            invoiceChainElement_.exportLiteral(outfile, level, name_='InvoiceChainElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currentPage' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'currentPage')
            ival_ = self.gds_validate_integer(ival_, node, 'currentPage')
            self.currentPage = ival_
            self.currentPage_nsprefix_ = child_.prefix
            # validate type ResponsePageType
            self.validate_ResponsePageType(self.currentPage)
        elif nodeName_ == 'availablePage' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'availablePage')
            ival_ = self.gds_validate_integer(ival_, node, 'availablePage')
            self.availablePage = ival_
            self.availablePage_nsprefix_ = child_.prefix
            # validate type ResponsePageType
            self.validate_ResponsePageType(self.availablePage)
        elif nodeName_ == 'invoiceChainElement':
            obj_ = InvoiceChainElementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceChainElement.append(obj_)
            obj_.original_tagname_ = 'invoiceChainElement'
# end class InvoiceChainDigestResultType


class InvoiceChainDigestType(GeneratedsSuper):
    """InvoiceChainDigestType -- Sz
    á
    mlal
    á
    nc kivonat adatok
    Invoice chain digest data
    invoiceNumber -- Sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma -
    Á
    FA tv. 169.
    §
    b) vagy 170.
    §
    (1) bek. b) pont
    Sequential number of the original invoice or modification document - section 169 (b) or section 170 (1) b) of the VAT law
    batchIndex -- A m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma a k
    ö
    tegen bel
    ü
    l
    Sequence number of the modification document within the batch
    invoiceOperation -- Sz
    á
    mlam
    ű
    velet t
    í
    pus
    Invoice operation type
    supplierTaxNumber -- A kibocs
    á
    t
    ó
    ad
    ó
    sz
    á
    ma
    The supplier's tax number
    customerTaxNumber -- A vev
    ő
    ad
    ó
    sz
    á
    ma
    The buyer's tax number
    insDate -- A besz
    ú
    r
    á
    s id
    ő
    pontja UTC id
    ő
    ben
    Insert date in UTC time
    originalRequestVersion -- Az adatszolg
    á
    ltat
    á
    s requestVersion
    é
    rt
    é
    ke
    requestVersion value of the invoice exchange

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceNumber=None, batchIndex=None, invoiceOperation=None, supplierTaxNumber=None, customerTaxNumber=None, insDate=None, originalRequestVersion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceNumber = invoiceNumber
        self.validate_SimpleText50NotBlankType(self.invoiceNumber)
        self.invoiceNumber_nsprefix_ = "common"
        self.batchIndex = batchIndex
        self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        self.batchIndex_nsprefix_ = "base"
        self.invoiceOperation = invoiceOperation
        self.validate_ManageInvoiceOperationType(self.invoiceOperation)
        self.invoiceOperation_nsprefix_ = None
        self.supplierTaxNumber = supplierTaxNumber
        self.validate_TaxpayerIdType(self.supplierTaxNumber)
        self.supplierTaxNumber_nsprefix_ = "common"
        self.customerTaxNumber = customerTaxNumber
        self.validate_TaxpayerIdType(self.customerTaxNumber)
        self.customerTaxNumber_nsprefix_ = "common"
        if isinstance(insDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(insDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = insDate
        self.insDate = initvalue_
        self.insDate_nsprefix_ = "base"
        self.originalRequestVersion = originalRequestVersion
        self.validate_OriginalRequestVersionType(self.originalRequestVersion)
        self.originalRequestVersion_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceChainDigestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceChainDigestType.subclass:
            return InvoiceChainDigestType.subclass(*args_, **kwargs_)
        else:
            return InvoiceChainDigestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceNumber(self):
        return self.invoiceNumber
    def set_invoiceNumber(self, invoiceNumber):
        self.invoiceNumber = invoiceNumber
    def get_batchIndex(self):
        return self.batchIndex
    def set_batchIndex(self, batchIndex):
        self.batchIndex = batchIndex
    def get_invoiceOperation(self):
        return self.invoiceOperation
    def set_invoiceOperation(self, invoiceOperation):
        self.invoiceOperation = invoiceOperation
    def get_supplierTaxNumber(self):
        return self.supplierTaxNumber
    def set_supplierTaxNumber(self, supplierTaxNumber):
        self.supplierTaxNumber = supplierTaxNumber
    def get_customerTaxNumber(self):
        return self.customerTaxNumber
    def set_customerTaxNumber(self, customerTaxNumber):
        self.customerTaxNumber = customerTaxNumber
    def get_insDate(self):
        return self.insDate
    def set_insDate(self, insDate):
        self.insDate = insDate
    def get_originalRequestVersion(self):
        return self.originalRequestVersion
    def set_originalRequestVersion(self, originalRequestVersion):
        self.originalRequestVersion = originalRequestVersion
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceUnboundedIndexType(self, value):
        result = True
        # Validate type InvoiceUnboundedIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceUnboundedIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ManageInvoiceOperationType(self, value):
        result = True
        # Validate type ManageInvoiceOperationType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['CREATE', 'MODIFY', 'STORNO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ManageInvoiceOperationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ManageInvoiceOperationType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ManageInvoiceOperationType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_TaxpayerIdType(self, value):
        result = True
        # Validate type TaxpayerIdType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxpayerIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TaxpayerIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TaxpayerIdType_patterns_, ))
                result = False
        return result
    validate_TaxpayerIdType_patterns_ = [['^([0-9]{8})$']]
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.fromisostring('2010-01-01T00:00:00.000000').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceTimestampType_patterns_, ))
                result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def validate_OriginalRequestVersionType(self, value):
        result = True
        # Validate type OriginalRequestVersionType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['1.0', '1.1', '2.0', '3.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OriginalRequestVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OriginalRequestVersionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on OriginalRequestVersionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.invoiceNumber is not None or
            self.batchIndex is not None or
            self.invoiceOperation is not None or
            self.supplierTaxNumber is not None or
            self.customerTaxNumber is not None or
            self.insDate is not None or
            self.originalRequestVersion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceChainDigestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceChainDigestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceChainDigestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceChainDigestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceChainDigestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceChainDigestType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceChainDigestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceNumber is not None:
            namespaceprefix_ = self.invoiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceNumber>%s</%sinvoiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceNumber), input_name='invoiceNumber')), namespaceprefix_ , eol_))
        if self.batchIndex is not None:
            namespaceprefix_ = self.batchIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.batchIndex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbatchIndex>%s</%sbatchIndex>%s' % (namespaceprefix_ , self.gds_format_integer(self.batchIndex, input_name='batchIndex'), namespaceprefix_ , eol_))
        if self.invoiceOperation is not None:
            namespaceprefix_ = self.invoiceOperation_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceOperation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceOperation>%s</%sinvoiceOperation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceOperation), input_name='invoiceOperation')), namespaceprefix_ , eol_))
        if self.supplierTaxNumber is not None:
            namespaceprefix_ = self.supplierTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierTaxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssupplierTaxNumber>%s</%ssupplierTaxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.supplierTaxNumber), input_name='supplierTaxNumber')), namespaceprefix_ , eol_))
        if self.customerTaxNumber is not None:
            namespaceprefix_ = self.customerTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.customerTaxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerTaxNumber>%s</%scustomerTaxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.customerTaxNumber), input_name='customerTaxNumber')), namespaceprefix_ , eol_))
        if self.insDate is not None:
            namespaceprefix_ = self.insDate_nsprefix_ + ':' if (UseCapturedNS_ and self.insDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinsDate>%s</%sinsDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.insDate, input_name='insDate'), namespaceprefix_ , eol_))
        if self.originalRequestVersion is not None:
            namespaceprefix_ = self.originalRequestVersion_nsprefix_ + ':' if (UseCapturedNS_ and self.originalRequestVersion_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalRequestVersion>%s</%soriginalRequestVersion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originalRequestVersion), input_name='originalRequestVersion')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='InvoiceChainDigestType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.invoiceNumber is not None:
            invoiceNumber_ = self.invoiceNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceNumber').text = self.gds_format_string(invoiceNumber_)
        if self.batchIndex is not None:
            batchIndex_ = self.batchIndex
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}batchIndex').text = self.gds_format_integer(batchIndex_)
        if self.invoiceOperation is not None:
            invoiceOperation_ = self.invoiceOperation
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceOperation').text = self.gds_format_string(invoiceOperation_)
        if self.supplierTaxNumber is not None:
            supplierTaxNumber_ = self.supplierTaxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}supplierTaxNumber').text = self.gds_format_string(supplierTaxNumber_)
        if self.customerTaxNumber is not None:
            customerTaxNumber_ = self.customerTaxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}customerTaxNumber').text = self.gds_format_string(customerTaxNumber_)
        if self.insDate is not None:
            insDate_ = self.insDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}insDate').text = self.gds_format_datetime(insDate_)
        if self.originalRequestVersion is not None:
            originalRequestVersion_ = self.originalRequestVersion
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}originalRequestVersion').text = self.gds_format_string(originalRequestVersion_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceChainDigestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('invoiceNumber=%s,\n' % self.gds_encode(quote_python(self.invoiceNumber)))
        if self.batchIndex is not None:
            showIndent(outfile, level)
            outfile.write('batchIndex=%d,\n' % self.batchIndex)
        if self.invoiceOperation is not None:
            showIndent(outfile, level)
            outfile.write('invoiceOperation=%s,\n' % self.gds_encode(quote_python(self.invoiceOperation)))
        if self.supplierTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('supplierTaxNumber=%s,\n' % self.gds_encode(quote_python(self.supplierTaxNumber)))
        if self.customerTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('customerTaxNumber=%s,\n' % self.gds_encode(quote_python(self.customerTaxNumber)))
        if self.insDate is not None:
            showIndent(outfile, level)
            outfile.write('insDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.insDate, input_name='insDate'))
        if self.originalRequestVersion is not None:
            showIndent(outfile, level)
            outfile.write('originalRequestVersion=%s,\n' % self.gds_encode(quote_python(self.originalRequestVersion)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceNumber')
            value_ = self.gds_validate_string(value_, node, 'invoiceNumber')
            self.invoiceNumber = value_
            self.invoiceNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.invoiceNumber)
        elif nodeName_ == 'batchIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'batchIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'batchIndex')
            self.batchIndex = ival_
            self.batchIndex_nsprefix_ = child_.prefix
            # validate type InvoiceUnboundedIndexType
            self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        elif nodeName_ == 'invoiceOperation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceOperation')
            value_ = self.gds_validate_string(value_, node, 'invoiceOperation')
            self.invoiceOperation = value_
            self.invoiceOperation_nsprefix_ = child_.prefix
            # validate type ManageInvoiceOperationType
            self.validate_ManageInvoiceOperationType(self.invoiceOperation)
        elif nodeName_ == 'supplierTaxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'supplierTaxNumber')
            value_ = self.gds_validate_string(value_, node, 'supplierTaxNumber')
            self.supplierTaxNumber = value_
            self.supplierTaxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.supplierTaxNumber)
        elif nodeName_ == 'customerTaxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerTaxNumber')
            value_ = self.gds_validate_string(value_, node, 'customerTaxNumber')
            self.customerTaxNumber = value_
            self.customerTaxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.customerTaxNumber)
        elif nodeName_ == 'insDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.insDate = dval_
            self.insDate_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.insDate)
        elif nodeName_ == 'originalRequestVersion':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originalRequestVersion')
            value_ = self.gds_validate_string(value_, node, 'originalRequestVersion')
            self.originalRequestVersion = value_
            self.originalRequestVersion_nsprefix_ = child_.prefix
            # validate type OriginalRequestVersionType
            self.validate_OriginalRequestVersionType(self.originalRequestVersion)
# end class InvoiceChainDigestType


class InvoiceChainElementType(GeneratedsSuper):
    """InvoiceChainElementType -- Sz
    á
    mlal
    á
    nc elem
    Invoice chain element
    invoiceChainDigest -- Sz
    á
    mlal
    á
    nc kivonat adatok
    Invoice chain digest data
    invoiceLines -- A sz
    á
    ml
    á
    n vagy m
    ó
    dos
    í
    t
    ó
    okiraton szerepl
    ő
    t
    é
    telek kivonatos adatai
    Product/service digest data appearing on the invoice or the modification document
    invoiceReferenceData -- A m
    ó
    dos
    í
    t
    á
    s vagy
    é
    rv
    é
    nytelen
    í
    t
    é
    s adatai
    Modification or cancellation data

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceChainDigest=None, invoiceLines=None, invoiceReferenceData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceChainDigest = invoiceChainDigest
        self.invoiceChainDigest_nsprefix_ = None
        self.invoiceLines = invoiceLines
        self.invoiceLines_nsprefix_ = None
        self.invoiceReferenceData = invoiceReferenceData
        self.invoiceReferenceData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceChainElementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceChainElementType.subclass:
            return InvoiceChainElementType.subclass(*args_, **kwargs_)
        else:
            return InvoiceChainElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceChainDigest(self):
        return self.invoiceChainDigest
    def set_invoiceChainDigest(self, invoiceChainDigest):
        self.invoiceChainDigest = invoiceChainDigest
    def get_invoiceLines(self):
        return self.invoiceLines
    def set_invoiceLines(self, invoiceLines):
        self.invoiceLines = invoiceLines
    def get_invoiceReferenceData(self):
        return self.invoiceReferenceData
    def set_invoiceReferenceData(self, invoiceReferenceData):
        self.invoiceReferenceData = invoiceReferenceData
    def _hasContent(self):
        if (
            self.invoiceChainDigest is not None or
            self.invoiceLines is not None or
            self.invoiceReferenceData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceChainElementType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceChainElementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceChainElementType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceChainElementType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceChainElementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceChainElementType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceChainElementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceChainDigest is not None:
            namespaceprefix_ = self.invoiceChainDigest_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceChainDigest_nsprefix_) else ''
            self.invoiceChainDigest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceChainDigest', pretty_print=pretty_print)
        if self.invoiceLines is not None:
            namespaceprefix_ = self.invoiceLines_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceLines_nsprefix_) else ''
            self.invoiceLines.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceLines', pretty_print=pretty_print)
        if self.invoiceReferenceData is not None:
            namespaceprefix_ = self.invoiceReferenceData_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceReferenceData_nsprefix_) else ''
            self.invoiceReferenceData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceReferenceData', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceChainElementType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.invoiceChainDigest is not None:
            invoiceChainDigest_ = self.invoiceChainDigest
            invoiceChainDigest_.to_etree(element, name_='invoiceChainDigest', mapping_=mapping_, nsmap_=nsmap_)
        if self.invoiceLines is not None:
            invoiceLines_ = self.invoiceLines
            invoiceLines_.to_etree(element, name_='invoiceLines', mapping_=mapping_, nsmap_=nsmap_)
        if self.invoiceReferenceData is not None:
            invoiceReferenceData_ = self.invoiceReferenceData
            invoiceReferenceData_.to_etree(element, name_='invoiceReferenceData', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceChainElementType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceChainDigest is not None:
            showIndent(outfile, level)
            outfile.write('invoiceChainDigest=model_.InvoiceChainDigestType(\n')
            self.invoiceChainDigest.exportLiteral(outfile, level, name_='invoiceChainDigest')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.invoiceLines is not None:
            showIndent(outfile, level)
            outfile.write('invoiceLines=model_.InvoiceLinesType(\n')
            self.invoiceLines.exportLiteral(outfile, level, name_='invoiceLines')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.invoiceReferenceData is not None:
            showIndent(outfile, level)
            outfile.write('invoiceReferenceData=model_.InvoiceReferenceDataType(\n')
            self.invoiceReferenceData.exportLiteral(outfile, level, name_='invoiceReferenceData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceChainDigest':
            obj_ = InvoiceChainDigestType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceChainDigest = obj_
            obj_.original_tagname_ = 'invoiceChainDigest'
        elif nodeName_ == 'invoiceLines':
            obj_ = InvoiceLinesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceLines = obj_
            obj_.original_tagname_ = 'invoiceLines'
        elif nodeName_ == 'invoiceReferenceData':
            obj_ = InvoiceReferenceDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceReferenceData = obj_
            obj_.original_tagname_ = 'invoiceReferenceData'
# end class InvoiceChainElementType


class InvoiceChainQueryType(GeneratedsSuper):
    """InvoiceChainQueryType -- Sz
    á
    mlal
    á
    nc kivonat lek
    é
    rdez
    é
    s sz
    á
    mlasz
    á
    m param
    é
    tere
    Invoice number param of the invoice chain digest query
    invoiceNumber -- Sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma
    Sequential number of the original or modification invoice
    invoiceDirection -- Kimen
    ő
    vagy bej
    ö
    v
    ő
    sz
    á
    mla keres
    é
    si param
    é
    tere
    Inbound or outbound invoice query parameter
    taxNumber -- A sz
    á
    mla ki
    á
    ll
    í
    t
    ó
    j
    á
    nak vagy vev
    ő
    j
    é
    nek ad
    ó
    sz
    á
    ma (a keres
    é
    si felt
    é
    tel az invoiceDirection tag
    é
    rt
    é
    k
    é
    t
    ő
    l f
    ü
    gg)
    Tax number of the supplier or the customer of the invoice (the search criteria depends on the value of the invoiceDirection tag)

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceNumber=None, invoiceDirection=None, taxNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceNumber = invoiceNumber
        self.validate_SimpleText50NotBlankType(self.invoiceNumber)
        self.invoiceNumber_nsprefix_ = "common"
        self.invoiceDirection = invoiceDirection
        self.validate_InvoiceDirectionType(self.invoiceDirection)
        self.invoiceDirection_nsprefix_ = None
        self.taxNumber = taxNumber
        self.validate_TaxpayerIdType(self.taxNumber)
        self.taxNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceChainQueryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceChainQueryType.subclass:
            return InvoiceChainQueryType.subclass(*args_, **kwargs_)
        else:
            return InvoiceChainQueryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceNumber(self):
        return self.invoiceNumber
    def set_invoiceNumber(self, invoiceNumber):
        self.invoiceNumber = invoiceNumber
    def get_invoiceDirection(self):
        return self.invoiceDirection
    def set_invoiceDirection(self, invoiceDirection):
        self.invoiceDirection = invoiceDirection
    def get_taxNumber(self):
        return self.taxNumber
    def set_taxNumber(self, taxNumber):
        self.taxNumber = taxNumber
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceDirectionType(self, value):
        result = True
        # Validate type InvoiceDirectionType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['INBOUND', 'OUTBOUND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvoiceDirectionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on InvoiceDirectionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on InvoiceDirectionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_TaxpayerIdType(self, value):
        result = True
        # Validate type TaxpayerIdType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxpayerIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TaxpayerIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TaxpayerIdType_patterns_, ))
                result = False
        return result
    validate_TaxpayerIdType_patterns_ = [['^([0-9]{8})$']]
    def _hasContent(self):
        if (
            self.invoiceNumber is not None or
            self.invoiceDirection is not None or
            self.taxNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceChainQueryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceChainQueryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceChainQueryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceChainQueryType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceChainQueryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceChainQueryType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceChainQueryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceNumber is not None:
            namespaceprefix_ = self.invoiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceNumber>%s</%sinvoiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceNumber), input_name='invoiceNumber')), namespaceprefix_ , eol_))
        if self.invoiceDirection is not None:
            namespaceprefix_ = self.invoiceDirection_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDirection_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceDirection>%s</%sinvoiceDirection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceDirection), input_name='invoiceDirection')), namespaceprefix_ , eol_))
        if self.taxNumber is not None:
            namespaceprefix_ = self.taxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.taxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxNumber>%s</%staxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxNumber), input_name='taxNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='InvoiceChainQueryType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.invoiceNumber is not None:
            invoiceNumber_ = self.invoiceNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceNumber').text = self.gds_format_string(invoiceNumber_)
        if self.invoiceDirection is not None:
            invoiceDirection_ = self.invoiceDirection
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceDirection').text = self.gds_format_string(invoiceDirection_)
        if self.taxNumber is not None:
            taxNumber_ = self.taxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}taxNumber').text = self.gds_format_string(taxNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceChainQueryType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('invoiceNumber=%s,\n' % self.gds_encode(quote_python(self.invoiceNumber)))
        if self.invoiceDirection is not None:
            showIndent(outfile, level)
            outfile.write('invoiceDirection=%s,\n' % self.gds_encode(quote_python(self.invoiceDirection)))
        if self.taxNumber is not None:
            showIndent(outfile, level)
            outfile.write('taxNumber=%s,\n' % self.gds_encode(quote_python(self.taxNumber)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceNumber')
            value_ = self.gds_validate_string(value_, node, 'invoiceNumber')
            self.invoiceNumber = value_
            self.invoiceNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.invoiceNumber)
        elif nodeName_ == 'invoiceDirection':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceDirection')
            value_ = self.gds_validate_string(value_, node, 'invoiceDirection')
            self.invoiceDirection = value_
            self.invoiceDirection_nsprefix_ = child_.prefix
            # validate type InvoiceDirectionType
            self.validate_InvoiceDirectionType(self.invoiceDirection)
        elif nodeName_ == 'taxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxNumber')
            value_ = self.gds_validate_string(value_, node, 'taxNumber')
            self.taxNumber = value_
            self.taxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.taxNumber)
# end class InvoiceChainQueryType


class InvoiceDataResultType(GeneratedsSuper):
    """InvoiceDataResultType -- Sz
    á
    mlasz
    á
    mra t
    ö
    rt
    é
    n
    ő
    lek
    é
    rdez
    é
    s eredm
    é
    nye
    Invoice number based query result
    invoiceData -- Sz
    á
    mla adatok BASE64-ben k
    ó
    dolt tartalma
    Invoice data in BASE64 encoded form
    auditData -- A sz
    á
    mla audit adatai
    Invoice audit data
    compressedContentIndicator -- Jel
    ö
    li, ha az invoice tartalm
    á
    t a BASE64 dek
    ó
    dol
    á
    st k
    ö
    vet
    ő
    en m
    é
    g ki kell t
    ö
    m
    ö
    r
    í
    teni az olvas
    á
    shoz
    Indicates if the content of the invoice needs to be decompressed to be read following the BASE64 decoding
    electronicInvoiceHash -- Elektronikus sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat
    á
    llom
    á
    ny hash lenyomata
    Electronic invoice or modification document file hash value

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceData=None, auditData=None, compressedContentIndicator=None, electronicInvoiceHash=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceData = invoiceData
        self.invoiceData_nsprefix_ = "xs"
        self.auditData = auditData
        self.auditData_nsprefix_ = None
        self.compressedContentIndicator = compressedContentIndicator
        self.compressedContentIndicator_nsprefix_ = "xs"
        self.electronicInvoiceHash = electronicInvoiceHash
        self.electronicInvoiceHash_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceDataResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceDataResultType.subclass:
            return InvoiceDataResultType.subclass(*args_, **kwargs_)
        else:
            return InvoiceDataResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceData(self):
        return self.invoiceData
    def set_invoiceData(self, invoiceData):
        self.invoiceData = invoiceData
    def get_auditData(self):
        return self.auditData
    def set_auditData(self, auditData):
        self.auditData = auditData
    def get_compressedContentIndicator(self):
        return self.compressedContentIndicator
    def set_compressedContentIndicator(self, compressedContentIndicator):
        self.compressedContentIndicator = compressedContentIndicator
    def get_electronicInvoiceHash(self):
        return self.electronicInvoiceHash
    def set_electronicInvoiceHash(self, electronicInvoiceHash):
        self.electronicInvoiceHash = electronicInvoiceHash
    def _hasContent(self):
        if (
            self.invoiceData is not None or
            self.auditData is not None or
            self.compressedContentIndicator is not None or
            self.electronicInvoiceHash is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='InvoiceDataResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceDataResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceDataResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceDataResultType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceDataResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceDataResultType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='InvoiceDataResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceData is not None:
            namespaceprefix_ = self.invoiceData_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceData_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceData>%s</%sinvoiceData>%s' % (namespaceprefix_ , self.gds_format_base64(self.invoiceData, input_name='invoiceData'), namespaceprefix_ , eol_))
        if self.auditData is not None:
            namespaceprefix_ = self.auditData_nsprefix_ + ':' if (UseCapturedNS_ and self.auditData_nsprefix_) else ''
            self.auditData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='auditData', pretty_print=pretty_print)
        if self.compressedContentIndicator is not None:
            namespaceprefix_ = self.compressedContentIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.compressedContentIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompressedContentIndicator>%s</%scompressedContentIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.compressedContentIndicator, input_name='compressedContentIndicator'), namespaceprefix_ , eol_))
        if self.electronicInvoiceHash is not None:
            namespaceprefix_ = self.electronicInvoiceHash_nsprefix_ + ':' if (UseCapturedNS_ and self.electronicInvoiceHash_nsprefix_) else ''
            self.electronicInvoiceHash.export(outfile, level, namespaceprefix_, namespacedef_='', name_='electronicInvoiceHash', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceDataResultType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.invoiceData is not None:
            invoiceData_ = self.invoiceData
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceData').text = self.gds_format_base64(invoiceData_)
        if self.auditData is not None:
            auditData_ = self.auditData
            auditData_.to_etree(element, name_='auditData', mapping_=mapping_, nsmap_=nsmap_)
        if self.compressedContentIndicator is not None:
            compressedContentIndicator_ = self.compressedContentIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}compressedContentIndicator').text = self.gds_format_boolean(compressedContentIndicator_)
        if self.electronicInvoiceHash is not None:
            electronicInvoiceHash_ = self.electronicInvoiceHash
            electronicInvoiceHash_.to_etree(element, name_='electronicInvoiceHash', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceDataResultType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceData is not None:
            showIndent(outfile, level)
            outfile.write('invoiceData=model_.base64Binary(\n')
            self.invoiceData.exportLiteral(outfile, level, name_='invoiceData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.auditData is not None:
            showIndent(outfile, level)
            outfile.write('auditData=model_.AuditDataType(\n')
            self.auditData.exportLiteral(outfile, level, name_='auditData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.compressedContentIndicator is not None:
            showIndent(outfile, level)
            outfile.write('compressedContentIndicator=%s,\n' % self.compressedContentIndicator)
        if self.electronicInvoiceHash is not None:
            showIndent(outfile, level)
            outfile.write('electronicInvoiceHash=model_.CryptoType(\n')
            self.electronicInvoiceHash.exportLiteral(outfile, level, name_='electronicInvoiceHash')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceData':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'invoiceData')
            else:
                bval_ = None
            self.invoiceData = bval_
            self.invoiceData_nsprefix_ = child_.prefix
        elif nodeName_ == 'auditData':
            obj_ = AuditDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.auditData = obj_
            obj_.original_tagname_ = 'auditData'
        elif nodeName_ == 'compressedContentIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'compressedContentIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'compressedContentIndicator')
            self.compressedContentIndicator = ival_
            self.compressedContentIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'electronicInvoiceHash':
            obj_ = CryptoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electronicInvoiceHash = obj_
            obj_.original_tagname_ = 'electronicInvoiceHash'
# end class InvoiceDataResultType


class InvoiceDigestResultType(GeneratedsSuper):
    """InvoiceDigestResultType -- Sz
    á
    mla lek
    é
    rdez
    é
    si eredm
    é
    nyek
    Invoice query results
    currentPage -- A jelenleg lek
    é
    rdezett lapsz
    á
    m
    The currently queried page count
    availablePage -- A lek
    é
    rdez
    é
    s eredm
    é
    nye szerint el
    é
    rhet
    ő
    utols
    ó
    lapsz
    á
    m
    The highest available page count matching the query
    invoiceDigest -- Sz
    á
    mla kivonat lek
    é
    rdez
    é
    si eredm
    é
    ny
    Invoice digest query result

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, currentPage=None, availablePage=None, invoiceDigest=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currentPage = currentPage
        self.validate_ResponsePageType(self.currentPage)
        self.currentPage_nsprefix_ = "common"
        self.availablePage = availablePage
        self.validate_ResponsePageType(self.availablePage)
        self.availablePage_nsprefix_ = "common"
        if invoiceDigest is None:
            self.invoiceDigest = []
        else:
            self.invoiceDigest = invoiceDigest
        self.invoiceDigest_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceDigestResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceDigestResultType.subclass:
            return InvoiceDigestResultType.subclass(*args_, **kwargs_)
        else:
            return InvoiceDigestResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_currentPage(self):
        return self.currentPage
    def set_currentPage(self, currentPage):
        self.currentPage = currentPage
    def get_availablePage(self):
        return self.availablePage
    def set_availablePage(self, availablePage):
        self.availablePage = availablePage
    def get_invoiceDigest(self):
        return self.invoiceDigest
    def set_invoiceDigest(self, invoiceDigest):
        self.invoiceDigest = invoiceDigest
    def add_invoiceDigest(self, value):
        self.invoiceDigest.append(value)
    def insert_invoiceDigest_at(self, index, value):
        self.invoiceDigest.insert(index, value)
    def replace_invoiceDigest_at(self, index, value):
        self.invoiceDigest[index] = value
    def validate_ResponsePageType(self, value):
        result = True
        # Validate type ResponsePageType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ResponsePageType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.currentPage is not None or
            self.availablePage is not None or
            self.invoiceDigest
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceDigestResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceDigestResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceDigestResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceDigestResultType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceDigestResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceDigestResultType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceDigestResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currentPage is not None:
            namespaceprefix_ = self.currentPage_nsprefix_ + ':' if (UseCapturedNS_ and self.currentPage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentPage>%s</%scurrentPage>%s' % (namespaceprefix_ , self.gds_format_integer(self.currentPage, input_name='currentPage'), namespaceprefix_ , eol_))
        if self.availablePage is not None:
            namespaceprefix_ = self.availablePage_nsprefix_ + ':' if (UseCapturedNS_ and self.availablePage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailablePage>%s</%savailablePage>%s' % (namespaceprefix_ , self.gds_format_integer(self.availablePage, input_name='availablePage'), namespaceprefix_ , eol_))
        for invoiceDigest_ in self.invoiceDigest:
            namespaceprefix_ = self.invoiceDigest_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDigest_nsprefix_) else ''
            invoiceDigest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceDigest', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceDigestResultType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.currentPage is not None:
            currentPage_ = self.currentPage
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}currentPage').text = self.gds_format_integer(currentPage_)
        if self.availablePage is not None:
            availablePage_ = self.availablePage
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}availablePage').text = self.gds_format_integer(availablePage_)
        for invoiceDigest_ in self.invoiceDigest:
            invoiceDigest_.to_etree(element, name_='invoiceDigest', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceDigestResultType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.currentPage is not None:
            showIndent(outfile, level)
            outfile.write('currentPage=%d,\n' % self.currentPage)
        if self.availablePage is not None:
            showIndent(outfile, level)
            outfile.write('availablePage=%d,\n' % self.availablePage)
        showIndent(outfile, level)
        outfile.write('invoiceDigest=[\n')
        level += 1
        for invoiceDigest_ in self.invoiceDigest:
            showIndent(outfile, level)
            outfile.write('model_.InvoiceDigestType(\n')
            invoiceDigest_.exportLiteral(outfile, level, name_='InvoiceDigestType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currentPage' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'currentPage')
            ival_ = self.gds_validate_integer(ival_, node, 'currentPage')
            self.currentPage = ival_
            self.currentPage_nsprefix_ = child_.prefix
            # validate type ResponsePageType
            self.validate_ResponsePageType(self.currentPage)
        elif nodeName_ == 'availablePage' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'availablePage')
            ival_ = self.gds_validate_integer(ival_, node, 'availablePage')
            self.availablePage = ival_
            self.availablePage_nsprefix_ = child_.prefix
            # validate type ResponsePageType
            self.validate_ResponsePageType(self.availablePage)
        elif nodeName_ == 'invoiceDigest':
            obj_ = InvoiceDigestType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceDigest.append(obj_)
            obj_.original_tagname_ = 'invoiceDigest'
# end class InvoiceDigestResultType


class InvoiceDigestType(GeneratedsSuper):
    """InvoiceDigestType -- Kivonatos lek
    é
    rdez
    é
    si eredm
    é
    ny
    Digest query result
    invoiceNumber -- Sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma -
    Á
    FA tv. 169.
    §
    b) vagy 170.
    §
    (1) bek. b) pont
    Sequential number of the original invoice or modification document - section 169 (b) or section 170 (1) b) of the VAT law
    batchIndex -- A m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma a k
    ö
    tegen bel
    ü
    l
    Sequence number of the modification document within the batch
    invoiceOperation -- Sz
    á
    mlam
    ű
    velet t
    í
    pus
    Invoice operation type
    invoiceCategory -- A sz
    á
    mla t
    í
    pusa
    Type of invoice
    invoiceIssueDate -- Sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat ki
    á
    ll
    í
    t
    á
    s
    á
    nak d
    á
    tuma
    Invoice or modification document issue date
    supplierTaxNumber -- A kibocs
    á
    t
    ó
    ad
    ó
    sz
    á
    ma
    The supplier's tax number
    supplierGroupMemberTaxNumber -- A kibocs
    á
    t
    ó
    csoporttag sz
    á
    ma
    The supplier's group tax number
    supplierName -- Az elad
    ó
    (sz
    á
    ll
    í
    t
    ó
    ) neve
    Name of the seller (supplier)
    customerTaxNumber -- A vev
    ő
    ad
    ó
    sz
    á
    ma
    The buyer's tax number
    customerGroupMemberTaxNumber -- A vev
    ő
    csoporttag sz
    á
    ma
    The buyer's group tax number
    customerName -- A vev
    ő
    neve
    Name of the customer
    paymentMethod -- Fizet
    é
    s m
    ó
    dja
    Method of payment
    paymentDate -- Fizet
    é
    si hat
    á
    rid
    ő
    Deadline for payment
    invoiceAppearance -- A sz
    á
    mla megjelen
    é
    si form
    á
    ja
    Form of appearance of the invoice
    source -- Az adatszolg
    á
    ltat
    á
    s forr
    á
    sa
    Data exchange source
    invoiceDeliveryDate -- Sz
    á
    mla teljes
    í
    t
    é
    si d
    á
    tuma
    Invoice delivery date
    currency -- A sz
    á
    mla p
    é
    nzneme
    Currency of the invoice
    invoiceNetAmount -- A sz
    á
    mla nett
    ó
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben
    Invoice net amount expressed in the currency of the invoice
    invoiceNetAmountHUF -- A sz
    á
    mla nett
    ó
    ö
    sszege forintban
    Invoice net amount expressed in HUF
    invoiceVatAmount -- A sz
    á
    mla
    Á
    FA
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben
    Invoice VAT amount expressed in the currency of the invoice
    invoiceVatAmountHUF -- A sz
    á
    mla
    Á
    FA
    ö
    sszege forintban
    Invoice VAT amount expressed in HUF
    transactionId -- Az adatszolg
    á
    ltat
    á
    s tranzakci
    ó
    azonos
    í
    t
    ó
    ja
    Transaction identifier of the data exchange
    index -- A sz
    á
    mla sorsz
    á
    ma a k
    é
    r
    é
    sen bel
    ü
    l
    Sequence number of the invoice within the request
    originalInvoiceNumber -- Az eredeti sz
    á
    mla sorsz
    á
    ma, melyre a m
    ó
    dos
    í
    t
    á
    s vonatkozik
    Sequence number of the original invoice, on which the modification occurs
    modificationIndex -- A sz
    á
    ml
    á
    ra vonatkoz
    ó
    m
    ó
    dos
    í
    t
    ó
    okirat egyedi sorsz
    á
    ma
    The unique sequence number referring to the original invoice
    insDate -- A besz
    ú
    r
    á
    s id
    ő
    pontja UTC id
    ő
    ben
    Insert date in UTC time
    completenessIndicator -- Jel
    ö
    li, ha az adatszolg
    á
    ltat
    á
    s maga a sz
    á
    mla (a sz
    á
    ml
    á
    n nem szerepel t
    ö
    bb adat)
    Indicates whether the data exchange is identical with the invoice (the invoice does not contain any more data)

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceNumber=None, batchIndex=None, invoiceOperation=None, invoiceCategory=None, invoiceIssueDate=None, supplierTaxNumber=None, supplierGroupMemberTaxNumber=None, supplierName=None, customerTaxNumber=None, customerGroupMemberTaxNumber=None, customerName=None, paymentMethod=None, paymentDate=None, invoiceAppearance=None, source=None, invoiceDeliveryDate=None, currency=None, invoiceNetAmount=None, invoiceNetAmountHUF=None, invoiceVatAmount=None, invoiceVatAmountHUF=None, transactionId=None, index=None, originalInvoiceNumber=None, modificationIndex=None, insDate=None, completenessIndicator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceNumber = invoiceNumber
        self.validate_SimpleText50NotBlankType(self.invoiceNumber)
        self.invoiceNumber_nsprefix_ = "common"
        self.batchIndex = batchIndex
        self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        self.batchIndex_nsprefix_ = "base"
        self.invoiceOperation = invoiceOperation
        self.validate_ManageInvoiceOperationType(self.invoiceOperation)
        self.invoiceOperation_nsprefix_ = None
        self.invoiceCategory = invoiceCategory
        self.validate_InvoiceCategoryType(self.invoiceCategory)
        self.invoiceCategory_nsprefix_ = "base"
        if isinstance(invoiceIssueDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(invoiceIssueDate, '%Y-%m-%d').date()
        else:
            initvalue_ = invoiceIssueDate
        self.invoiceIssueDate = initvalue_
        self.invoiceIssueDate_nsprefix_ = "base"
        self.supplierTaxNumber = supplierTaxNumber
        self.validate_TaxpayerIdType(self.supplierTaxNumber)
        self.supplierTaxNumber_nsprefix_ = "common"
        self.supplierGroupMemberTaxNumber = supplierGroupMemberTaxNumber
        self.validate_TaxpayerIdType(self.supplierGroupMemberTaxNumber)
        self.supplierGroupMemberTaxNumber_nsprefix_ = "common"
        self.supplierName = supplierName
        self.validate_SimpleText512NotBlankType(self.supplierName)
        self.supplierName_nsprefix_ = "common"
        self.customerTaxNumber = customerTaxNumber
        self.validate_TaxpayerIdType(self.customerTaxNumber)
        self.customerTaxNumber_nsprefix_ = "common"
        self.customerGroupMemberTaxNumber = customerGroupMemberTaxNumber
        self.validate_TaxpayerIdType(self.customerGroupMemberTaxNumber)
        self.customerGroupMemberTaxNumber_nsprefix_ = "common"
        self.customerName = customerName
        self.validate_SimpleText512NotBlankType(self.customerName)
        self.customerName_nsprefix_ = "common"
        self.paymentMethod = paymentMethod
        self.validate_PaymentMethodType(self.paymentMethod)
        self.paymentMethod_nsprefix_ = "base"
        if isinstance(paymentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(paymentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = paymentDate
        self.paymentDate = initvalue_
        self.paymentDate_nsprefix_ = "base"
        self.invoiceAppearance = invoiceAppearance
        self.validate_InvoiceAppearanceType(self.invoiceAppearance)
        self.invoiceAppearance_nsprefix_ = "base"
        self.source = source
        self.validate_SourceType(self.source)
        self.source_nsprefix_ = None
        if isinstance(invoiceDeliveryDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(invoiceDeliveryDate, '%Y-%m-%d').date()
        else:
            initvalue_ = invoiceDeliveryDate
        self.invoiceDeliveryDate = initvalue_
        self.invoiceDeliveryDate_nsprefix_ = "base"
        self.currency = currency
        self.validate_CurrencyType(self.currency)
        self.currency_nsprefix_ = "common"
        self.invoiceNetAmount = invoiceNetAmount
        self.validate_MonetaryType(self.invoiceNetAmount)
        self.invoiceNetAmount_nsprefix_ = "base"
        self.invoiceNetAmountHUF = invoiceNetAmountHUF
        self.validate_MonetaryType(self.invoiceNetAmountHUF)
        self.invoiceNetAmountHUF_nsprefix_ = "base"
        self.invoiceVatAmount = invoiceVatAmount
        self.validate_MonetaryType(self.invoiceVatAmount)
        self.invoiceVatAmount_nsprefix_ = "base"
        self.invoiceVatAmountHUF = invoiceVatAmountHUF
        self.validate_MonetaryType(self.invoiceVatAmountHUF)
        self.invoiceVatAmountHUF_nsprefix_ = "base"
        self.transactionId = transactionId
        self.validate_EntityIdType(self.transactionId)
        self.transactionId_nsprefix_ = "common"
        self.index = index
        self.validate_InvoiceIndexType(self.index)
        self.index_nsprefix_ = "base"
        self.originalInvoiceNumber = originalInvoiceNumber
        self.validate_SimpleText50NotBlankType(self.originalInvoiceNumber)
        self.originalInvoiceNumber_nsprefix_ = "common"
        self.modificationIndex = modificationIndex
        self.validate_InvoiceUnboundedIndexType(self.modificationIndex)
        self.modificationIndex_nsprefix_ = "base"
        if isinstance(insDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(insDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = insDate
        self.insDate = initvalue_
        self.insDate_nsprefix_ = "base"
        self.completenessIndicator = completenessIndicator
        self.completenessIndicator_nsprefix_ = "xs"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceDigestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceDigestType.subclass:
            return InvoiceDigestType.subclass(*args_, **kwargs_)
        else:
            return InvoiceDigestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceNumber(self):
        return self.invoiceNumber
    def set_invoiceNumber(self, invoiceNumber):
        self.invoiceNumber = invoiceNumber
    def get_batchIndex(self):
        return self.batchIndex
    def set_batchIndex(self, batchIndex):
        self.batchIndex = batchIndex
    def get_invoiceOperation(self):
        return self.invoiceOperation
    def set_invoiceOperation(self, invoiceOperation):
        self.invoiceOperation = invoiceOperation
    def get_invoiceCategory(self):
        return self.invoiceCategory
    def set_invoiceCategory(self, invoiceCategory):
        self.invoiceCategory = invoiceCategory
    def get_invoiceIssueDate(self):
        return self.invoiceIssueDate
    def set_invoiceIssueDate(self, invoiceIssueDate):
        self.invoiceIssueDate = invoiceIssueDate
    def get_supplierTaxNumber(self):
        return self.supplierTaxNumber
    def set_supplierTaxNumber(self, supplierTaxNumber):
        self.supplierTaxNumber = supplierTaxNumber
    def get_supplierGroupMemberTaxNumber(self):
        return self.supplierGroupMemberTaxNumber
    def set_supplierGroupMemberTaxNumber(self, supplierGroupMemberTaxNumber):
        self.supplierGroupMemberTaxNumber = supplierGroupMemberTaxNumber
    def get_supplierName(self):
        return self.supplierName
    def set_supplierName(self, supplierName):
        self.supplierName = supplierName
    def get_customerTaxNumber(self):
        return self.customerTaxNumber
    def set_customerTaxNumber(self, customerTaxNumber):
        self.customerTaxNumber = customerTaxNumber
    def get_customerGroupMemberTaxNumber(self):
        return self.customerGroupMemberTaxNumber
    def set_customerGroupMemberTaxNumber(self, customerGroupMemberTaxNumber):
        self.customerGroupMemberTaxNumber = customerGroupMemberTaxNumber
    def get_customerName(self):
        return self.customerName
    def set_customerName(self, customerName):
        self.customerName = customerName
    def get_paymentMethod(self):
        return self.paymentMethod
    def set_paymentMethod(self, paymentMethod):
        self.paymentMethod = paymentMethod
    def get_paymentDate(self):
        return self.paymentDate
    def set_paymentDate(self, paymentDate):
        self.paymentDate = paymentDate
    def get_invoiceAppearance(self):
        return self.invoiceAppearance
    def set_invoiceAppearance(self, invoiceAppearance):
        self.invoiceAppearance = invoiceAppearance
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_invoiceDeliveryDate(self):
        return self.invoiceDeliveryDate
    def set_invoiceDeliveryDate(self, invoiceDeliveryDate):
        self.invoiceDeliveryDate = invoiceDeliveryDate
    def get_currency(self):
        return self.currency
    def set_currency(self, currency):
        self.currency = currency
    def get_invoiceNetAmount(self):
        return self.invoiceNetAmount
    def set_invoiceNetAmount(self, invoiceNetAmount):
        self.invoiceNetAmount = invoiceNetAmount
    def get_invoiceNetAmountHUF(self):
        return self.invoiceNetAmountHUF
    def set_invoiceNetAmountHUF(self, invoiceNetAmountHUF):
        self.invoiceNetAmountHUF = invoiceNetAmountHUF
    def get_invoiceVatAmount(self):
        return self.invoiceVatAmount
    def set_invoiceVatAmount(self, invoiceVatAmount):
        self.invoiceVatAmount = invoiceVatAmount
    def get_invoiceVatAmountHUF(self):
        return self.invoiceVatAmountHUF
    def set_invoiceVatAmountHUF(self, invoiceVatAmountHUF):
        self.invoiceVatAmountHUF = invoiceVatAmountHUF
    def get_transactionId(self):
        return self.transactionId
    def set_transactionId(self, transactionId):
        self.transactionId = transactionId
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_originalInvoiceNumber(self):
        return self.originalInvoiceNumber
    def set_originalInvoiceNumber(self, originalInvoiceNumber):
        self.originalInvoiceNumber = originalInvoiceNumber
    def get_modificationIndex(self):
        return self.modificationIndex
    def set_modificationIndex(self, modificationIndex):
        self.modificationIndex = modificationIndex
    def get_insDate(self):
        return self.insDate
    def set_insDate(self, insDate):
        self.insDate = insDate
    def get_completenessIndicator(self):
        return self.completenessIndicator
    def set_completenessIndicator(self, completenessIndicator):
        self.completenessIndicator = completenessIndicator
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceUnboundedIndexType(self, value):
        result = True
        # Validate type InvoiceUnboundedIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceUnboundedIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ManageInvoiceOperationType(self, value):
        result = True
        # Validate type ManageInvoiceOperationType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['CREATE', 'MODIFY', 'STORNO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ManageInvoiceOperationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ManageInvoiceOperationType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ManageInvoiceOperationType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceCategoryType(self, value):
        result = True
        # Validate type InvoiceCategoryType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['NORMAL', 'SIMPLIFIED', 'AGGREGATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvoiceCategoryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on InvoiceCategoryType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on InvoiceCategoryType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceDateType(self, value):
        result = True
        # Validate type InvoiceDateType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.strptime('2010-01-01', '%Y-%m-%d').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceDateType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceDateType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceDateType_patterns_, ))
                result = False
        return result
    validate_InvoiceDateType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2})$']]
    def validate_TaxpayerIdType(self, value):
        result = True
        # Validate type TaxpayerIdType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxpayerIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TaxpayerIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TaxpayerIdType_patterns_, ))
                result = False
        return result
    validate_TaxpayerIdType_patterns_ = [['^([0-9]{8})$']]
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_PaymentMethodType(self, value):
        result = True
        # Validate type PaymentMethodType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['TRANSFER', 'CASH', 'CARD', 'VOUCHER', 'OTHER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PaymentMethodType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PaymentMethodType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PaymentMethodType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceAppearanceType(self, value):
        result = True
        # Validate type InvoiceAppearanceType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['PAPER', 'ELECTRONIC', 'EDI', 'UNKNOWN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvoiceAppearanceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on InvoiceAppearanceType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on InvoiceAppearanceType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SourceType(self, value):
        result = True
        # Validate type SourceType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['WEB', 'XML', 'MGM', 'OPG', 'OSZ']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SourceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SourceType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SourceType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_CurrencyType(self, value):
        result = True
        # Validate type CurrencyType, a restriction on AtomicStringType4.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on CurrencyType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CurrencyType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CurrencyType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CurrencyType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CurrencyType_patterns_, ))
                result = False
        return result
    validate_CurrencyType_patterns_ = [['^([A-Z]{3})$']]
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_EntityIdType(self, value):
        result = True
        # Validate type EntityIdType, a restriction on AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityIdType_patterns_, ))
                result = False
        return result
    validate_EntityIdType_patterns_ = [['^([+a-zA-Z0-9_]{1,30})$']]
    def validate_InvoiceIndexType(self, value):
        result = True
        # Validate type InvoiceIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.fromisostring('2010-01-01T00:00:00.000000').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceTimestampType_patterns_, ))
                result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def _hasContent(self):
        if (
            self.invoiceNumber is not None or
            self.batchIndex is not None or
            self.invoiceOperation is not None or
            self.invoiceCategory is not None or
            self.invoiceIssueDate is not None or
            self.supplierTaxNumber is not None or
            self.supplierGroupMemberTaxNumber is not None or
            self.supplierName is not None or
            self.customerTaxNumber is not None or
            self.customerGroupMemberTaxNumber is not None or
            self.customerName is not None or
            self.paymentMethod is not None or
            self.paymentDate is not None or
            self.invoiceAppearance is not None or
            self.source is not None or
            self.invoiceDeliveryDate is not None or
            self.currency is not None or
            self.invoiceNetAmount is not None or
            self.invoiceNetAmountHUF is not None or
            self.invoiceVatAmount is not None or
            self.invoiceVatAmountHUF is not None or
            self.transactionId is not None or
            self.index is not None or
            self.originalInvoiceNumber is not None or
            self.modificationIndex is not None or
            self.insDate is not None or
            self.completenessIndicator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='InvoiceDigestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceDigestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceDigestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceDigestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceDigestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceDigestType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='InvoiceDigestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceNumber is not None:
            namespaceprefix_ = self.invoiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceNumber>%s</%sinvoiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceNumber), input_name='invoiceNumber')), namespaceprefix_ , eol_))
        if self.batchIndex is not None:
            namespaceprefix_ = self.batchIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.batchIndex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbatchIndex>%s</%sbatchIndex>%s' % (namespaceprefix_ , self.gds_format_integer(self.batchIndex, input_name='batchIndex'), namespaceprefix_ , eol_))
        if self.invoiceOperation is not None:
            namespaceprefix_ = self.invoiceOperation_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceOperation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceOperation>%s</%sinvoiceOperation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceOperation), input_name='invoiceOperation')), namespaceprefix_ , eol_))
        if self.invoiceCategory is not None:
            namespaceprefix_ = self.invoiceCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceCategory>%s</%sinvoiceCategory>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceCategory), input_name='invoiceCategory')), namespaceprefix_ , eol_))
        if self.invoiceIssueDate is not None:
            namespaceprefix_ = self.invoiceIssueDate_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceIssueDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceIssueDate>%s</%sinvoiceIssueDate>%s' % (namespaceprefix_ , self.gds_format_date(self.invoiceIssueDate, input_name='invoiceIssueDate'), namespaceprefix_ , eol_))
        if self.supplierTaxNumber is not None:
            namespaceprefix_ = self.supplierTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierTaxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssupplierTaxNumber>%s</%ssupplierTaxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.supplierTaxNumber), input_name='supplierTaxNumber')), namespaceprefix_ , eol_))
        if self.supplierGroupMemberTaxNumber is not None:
            namespaceprefix_ = self.supplierGroupMemberTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierGroupMemberTaxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssupplierGroupMemberTaxNumber>%s</%ssupplierGroupMemberTaxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.supplierGroupMemberTaxNumber), input_name='supplierGroupMemberTaxNumber')), namespaceprefix_ , eol_))
        if self.supplierName is not None:
            namespaceprefix_ = self.supplierName_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssupplierName>%s</%ssupplierName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.supplierName), input_name='supplierName')), namespaceprefix_ , eol_))
        if self.customerTaxNumber is not None:
            namespaceprefix_ = self.customerTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.customerTaxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerTaxNumber>%s</%scustomerTaxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.customerTaxNumber), input_name='customerTaxNumber')), namespaceprefix_ , eol_))
        if self.customerGroupMemberTaxNumber is not None:
            namespaceprefix_ = self.customerGroupMemberTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.customerGroupMemberTaxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerGroupMemberTaxNumber>%s</%scustomerGroupMemberTaxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.customerGroupMemberTaxNumber), input_name='customerGroupMemberTaxNumber')), namespaceprefix_ , eol_))
        if self.customerName is not None:
            namespaceprefix_ = self.customerName_nsprefix_ + ':' if (UseCapturedNS_ and self.customerName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerName>%s</%scustomerName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.customerName), input_name='customerName')), namespaceprefix_ , eol_))
        if self.paymentMethod is not None:
            namespaceprefix_ = self.paymentMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.paymentMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaymentMethod>%s</%spaymentMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.paymentMethod), input_name='paymentMethod')), namespaceprefix_ , eol_))
        if self.paymentDate is not None:
            namespaceprefix_ = self.paymentDate_nsprefix_ + ':' if (UseCapturedNS_ and self.paymentDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaymentDate>%s</%spaymentDate>%s' % (namespaceprefix_ , self.gds_format_date(self.paymentDate, input_name='paymentDate'), namespaceprefix_ , eol_))
        if self.invoiceAppearance is not None:
            namespaceprefix_ = self.invoiceAppearance_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceAppearance_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceAppearance>%s</%sinvoiceAppearance>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceAppearance), input_name='invoiceAppearance')), namespaceprefix_ , eol_))
        if self.source is not None:
            namespaceprefix_ = self.source_nsprefix_ + ':' if (UseCapturedNS_ and self.source_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespaceprefix_ , eol_))
        if self.invoiceDeliveryDate is not None:
            namespaceprefix_ = self.invoiceDeliveryDate_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDeliveryDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceDeliveryDate>%s</%sinvoiceDeliveryDate>%s' % (namespaceprefix_ , self.gds_format_date(self.invoiceDeliveryDate, input_name='invoiceDeliveryDate'), namespaceprefix_ , eol_))
        if self.currency is not None:
            namespaceprefix_ = self.currency_nsprefix_ + ':' if (UseCapturedNS_ and self.currency_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrency>%s</%scurrency>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.currency), input_name='currency')), namespaceprefix_ , eol_))
        if self.invoiceNetAmount is not None:
            namespaceprefix_ = self.invoiceNetAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNetAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceNetAmount>%s</%sinvoiceNetAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.invoiceNetAmount, input_name='invoiceNetAmount'), namespaceprefix_ , eol_))
        if self.invoiceNetAmountHUF is not None:
            namespaceprefix_ = self.invoiceNetAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNetAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceNetAmountHUF>%s</%sinvoiceNetAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.invoiceNetAmountHUF, input_name='invoiceNetAmountHUF'), namespaceprefix_ , eol_))
        if self.invoiceVatAmount is not None:
            namespaceprefix_ = self.invoiceVatAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceVatAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceVatAmount>%s</%sinvoiceVatAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.invoiceVatAmount, input_name='invoiceVatAmount'), namespaceprefix_ , eol_))
        if self.invoiceVatAmountHUF is not None:
            namespaceprefix_ = self.invoiceVatAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceVatAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceVatAmountHUF>%s</%sinvoiceVatAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.invoiceVatAmountHUF, input_name='invoiceVatAmountHUF'), namespaceprefix_ , eol_))
        if self.transactionId is not None:
            namespaceprefix_ = self.transactionId_nsprefix_ + ':' if (UseCapturedNS_ and self.transactionId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransactionId>%s</%stransactionId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.transactionId), input_name='transactionId')), namespaceprefix_ , eol_))
        if self.index is not None:
            namespaceprefix_ = self.index_nsprefix_ + ':' if (UseCapturedNS_ and self.index_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindex>%s</%sindex>%s' % (namespaceprefix_ , self.gds_format_integer(self.index, input_name='index'), namespaceprefix_ , eol_))
        if self.originalInvoiceNumber is not None:
            namespaceprefix_ = self.originalInvoiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.originalInvoiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalInvoiceNumber>%s</%soriginalInvoiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originalInvoiceNumber), input_name='originalInvoiceNumber')), namespaceprefix_ , eol_))
        if self.modificationIndex is not None:
            namespaceprefix_ = self.modificationIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.modificationIndex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodificationIndex>%s</%smodificationIndex>%s' % (namespaceprefix_ , self.gds_format_integer(self.modificationIndex, input_name='modificationIndex'), namespaceprefix_ , eol_))
        if self.insDate is not None:
            namespaceprefix_ = self.insDate_nsprefix_ + ':' if (UseCapturedNS_ and self.insDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinsDate>%s</%sinsDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.insDate, input_name='insDate'), namespaceprefix_ , eol_))
        if self.completenessIndicator is not None:
            namespaceprefix_ = self.completenessIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.completenessIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompletenessIndicator>%s</%scompletenessIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.completenessIndicator, input_name='completenessIndicator'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='InvoiceDigestType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.invoiceNumber is not None:
            invoiceNumber_ = self.invoiceNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceNumber').text = self.gds_format_string(invoiceNumber_)
        if self.batchIndex is not None:
            batchIndex_ = self.batchIndex
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}batchIndex').text = self.gds_format_integer(batchIndex_)
        if self.invoiceOperation is not None:
            invoiceOperation_ = self.invoiceOperation
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceOperation').text = self.gds_format_string(invoiceOperation_)
        if self.invoiceCategory is not None:
            invoiceCategory_ = self.invoiceCategory
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceCategory').text = self.gds_format_string(invoiceCategory_)
        if self.invoiceIssueDate is not None:
            invoiceIssueDate_ = self.invoiceIssueDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceIssueDate').text = self.gds_format_date(invoiceIssueDate_)
        if self.supplierTaxNumber is not None:
            supplierTaxNumber_ = self.supplierTaxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}supplierTaxNumber').text = self.gds_format_string(supplierTaxNumber_)
        if self.supplierGroupMemberTaxNumber is not None:
            supplierGroupMemberTaxNumber_ = self.supplierGroupMemberTaxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}supplierGroupMemberTaxNumber').text = self.gds_format_string(supplierGroupMemberTaxNumber_)
        if self.supplierName is not None:
            supplierName_ = self.supplierName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}supplierName').text = self.gds_format_string(supplierName_)
        if self.customerTaxNumber is not None:
            customerTaxNumber_ = self.customerTaxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}customerTaxNumber').text = self.gds_format_string(customerTaxNumber_)
        if self.customerGroupMemberTaxNumber is not None:
            customerGroupMemberTaxNumber_ = self.customerGroupMemberTaxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}customerGroupMemberTaxNumber').text = self.gds_format_string(customerGroupMemberTaxNumber_)
        if self.customerName is not None:
            customerName_ = self.customerName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}customerName').text = self.gds_format_string(customerName_)
        if self.paymentMethod is not None:
            paymentMethod_ = self.paymentMethod
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}paymentMethod').text = self.gds_format_string(paymentMethod_)
        if self.paymentDate is not None:
            paymentDate_ = self.paymentDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}paymentDate').text = self.gds_format_date(paymentDate_)
        if self.invoiceAppearance is not None:
            invoiceAppearance_ = self.invoiceAppearance
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceAppearance').text = self.gds_format_string(invoiceAppearance_)
        if self.source is not None:
            source_ = self.source
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}source').text = self.gds_format_string(source_)
        if self.invoiceDeliveryDate is not None:
            invoiceDeliveryDate_ = self.invoiceDeliveryDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceDeliveryDate').text = self.gds_format_date(invoiceDeliveryDate_)
        if self.currency is not None:
            currency_ = self.currency
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}currency').text = self.gds_format_string(currency_)
        if self.invoiceNetAmount is not None:
            invoiceNetAmount_ = self.invoiceNetAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceNetAmount').text = self.gds_format_decimal(invoiceNetAmount_)
        if self.invoiceNetAmountHUF is not None:
            invoiceNetAmountHUF_ = self.invoiceNetAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceNetAmountHUF').text = self.gds_format_decimal(invoiceNetAmountHUF_)
        if self.invoiceVatAmount is not None:
            invoiceVatAmount_ = self.invoiceVatAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceVatAmount').text = self.gds_format_decimal(invoiceVatAmount_)
        if self.invoiceVatAmountHUF is not None:
            invoiceVatAmountHUF_ = self.invoiceVatAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceVatAmountHUF').text = self.gds_format_decimal(invoiceVatAmountHUF_)
        if self.transactionId is not None:
            transactionId_ = self.transactionId
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}transactionId').text = self.gds_format_string(transactionId_)
        if self.index is not None:
            index_ = self.index
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}index').text = self.gds_format_integer(index_)
        if self.originalInvoiceNumber is not None:
            originalInvoiceNumber_ = self.originalInvoiceNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}originalInvoiceNumber').text = self.gds_format_string(originalInvoiceNumber_)
        if self.modificationIndex is not None:
            modificationIndex_ = self.modificationIndex
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}modificationIndex').text = self.gds_format_integer(modificationIndex_)
        if self.insDate is not None:
            insDate_ = self.insDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}insDate').text = self.gds_format_datetime(insDate_)
        if self.completenessIndicator is not None:
            completenessIndicator_ = self.completenessIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}completenessIndicator').text = self.gds_format_boolean(completenessIndicator_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceDigestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('invoiceNumber=%s,\n' % self.gds_encode(quote_python(self.invoiceNumber)))
        if self.batchIndex is not None:
            showIndent(outfile, level)
            outfile.write('batchIndex=%d,\n' % self.batchIndex)
        if self.invoiceOperation is not None:
            showIndent(outfile, level)
            outfile.write('invoiceOperation=%s,\n' % self.gds_encode(quote_python(self.invoiceOperation)))
        if self.invoiceCategory is not None:
            showIndent(outfile, level)
            outfile.write('invoiceCategory=%s,\n' % self.gds_encode(quote_python(self.invoiceCategory)))
        if self.invoiceIssueDate is not None:
            showIndent(outfile, level)
            outfile.write('invoiceIssueDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.invoiceIssueDate, input_name='invoiceIssueDate'))
        if self.supplierTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('supplierTaxNumber=%s,\n' % self.gds_encode(quote_python(self.supplierTaxNumber)))
        if self.supplierGroupMemberTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('supplierGroupMemberTaxNumber=%s,\n' % self.gds_encode(quote_python(self.supplierGroupMemberTaxNumber)))
        if self.supplierName is not None:
            showIndent(outfile, level)
            outfile.write('supplierName=%s,\n' % self.gds_encode(quote_python(self.supplierName)))
        if self.customerTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('customerTaxNumber=%s,\n' % self.gds_encode(quote_python(self.customerTaxNumber)))
        if self.customerGroupMemberTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('customerGroupMemberTaxNumber=%s,\n' % self.gds_encode(quote_python(self.customerGroupMemberTaxNumber)))
        if self.customerName is not None:
            showIndent(outfile, level)
            outfile.write('customerName=%s,\n' % self.gds_encode(quote_python(self.customerName)))
        if self.paymentMethod is not None:
            showIndent(outfile, level)
            outfile.write('paymentMethod=%s,\n' % self.gds_encode(quote_python(self.paymentMethod)))
        if self.paymentDate is not None:
            showIndent(outfile, level)
            outfile.write('paymentDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.paymentDate, input_name='paymentDate'))
        if self.invoiceAppearance is not None:
            showIndent(outfile, level)
            outfile.write('invoiceAppearance=%s,\n' % self.gds_encode(quote_python(self.invoiceAppearance)))
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=%s,\n' % self.gds_encode(quote_python(self.source)))
        if self.invoiceDeliveryDate is not None:
            showIndent(outfile, level)
            outfile.write('invoiceDeliveryDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.invoiceDeliveryDate, input_name='invoiceDeliveryDate'))
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%s,\n' % self.gds_encode(quote_python(self.currency)))
        if self.invoiceNetAmount is not None:
            showIndent(outfile, level)
            outfile.write('invoiceNetAmount=%f,\n' % self.invoiceNetAmount)
        if self.invoiceNetAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('invoiceNetAmountHUF=%f,\n' % self.invoiceNetAmountHUF)
        if self.invoiceVatAmount is not None:
            showIndent(outfile, level)
            outfile.write('invoiceVatAmount=%f,\n' % self.invoiceVatAmount)
        if self.invoiceVatAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('invoiceVatAmountHUF=%f,\n' % self.invoiceVatAmountHUF)
        if self.transactionId is not None:
            showIndent(outfile, level)
            outfile.write('transactionId=%s,\n' % self.gds_encode(quote_python(self.transactionId)))
        if self.index is not None:
            showIndent(outfile, level)
            outfile.write('index=%d,\n' % self.index)
        if self.originalInvoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('originalInvoiceNumber=%s,\n' % self.gds_encode(quote_python(self.originalInvoiceNumber)))
        if self.modificationIndex is not None:
            showIndent(outfile, level)
            outfile.write('modificationIndex=%d,\n' % self.modificationIndex)
        if self.insDate is not None:
            showIndent(outfile, level)
            outfile.write('insDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.insDate, input_name='insDate'))
        if self.completenessIndicator is not None:
            showIndent(outfile, level)
            outfile.write('completenessIndicator=%s,\n' % self.completenessIndicator)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceNumber')
            value_ = self.gds_validate_string(value_, node, 'invoiceNumber')
            self.invoiceNumber = value_
            self.invoiceNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.invoiceNumber)
        elif nodeName_ == 'batchIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'batchIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'batchIndex')
            self.batchIndex = ival_
            self.batchIndex_nsprefix_ = child_.prefix
            # validate type InvoiceUnboundedIndexType
            self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        elif nodeName_ == 'invoiceOperation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceOperation')
            value_ = self.gds_validate_string(value_, node, 'invoiceOperation')
            self.invoiceOperation = value_
            self.invoiceOperation_nsprefix_ = child_.prefix
            # validate type ManageInvoiceOperationType
            self.validate_ManageInvoiceOperationType(self.invoiceOperation)
        elif nodeName_ == 'invoiceCategory':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceCategory')
            value_ = self.gds_validate_string(value_, node, 'invoiceCategory')
            self.invoiceCategory = value_
            self.invoiceCategory_nsprefix_ = child_.prefix
            # validate type InvoiceCategoryType
            self.validate_InvoiceCategoryType(self.invoiceCategory)
        elif nodeName_ == 'invoiceIssueDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.invoiceIssueDate = dval_
            self.invoiceIssueDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.invoiceIssueDate)
        elif nodeName_ == 'supplierTaxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'supplierTaxNumber')
            value_ = self.gds_validate_string(value_, node, 'supplierTaxNumber')
            self.supplierTaxNumber = value_
            self.supplierTaxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.supplierTaxNumber)
        elif nodeName_ == 'supplierGroupMemberTaxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'supplierGroupMemberTaxNumber')
            value_ = self.gds_validate_string(value_, node, 'supplierGroupMemberTaxNumber')
            self.supplierGroupMemberTaxNumber = value_
            self.supplierGroupMemberTaxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.supplierGroupMemberTaxNumber)
        elif nodeName_ == 'supplierName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'supplierName')
            value_ = self.gds_validate_string(value_, node, 'supplierName')
            self.supplierName = value_
            self.supplierName_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.supplierName)
        elif nodeName_ == 'customerTaxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerTaxNumber')
            value_ = self.gds_validate_string(value_, node, 'customerTaxNumber')
            self.customerTaxNumber = value_
            self.customerTaxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.customerTaxNumber)
        elif nodeName_ == 'customerGroupMemberTaxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerGroupMemberTaxNumber')
            value_ = self.gds_validate_string(value_, node, 'customerGroupMemberTaxNumber')
            self.customerGroupMemberTaxNumber = value_
            self.customerGroupMemberTaxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.customerGroupMemberTaxNumber)
        elif nodeName_ == 'customerName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerName')
            value_ = self.gds_validate_string(value_, node, 'customerName')
            self.customerName = value_
            self.customerName_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.customerName)
        elif nodeName_ == 'paymentMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paymentMethod')
            value_ = self.gds_validate_string(value_, node, 'paymentMethod')
            self.paymentMethod = value_
            self.paymentMethod_nsprefix_ = child_.prefix
            # validate type PaymentMethodType
            self.validate_PaymentMethodType(self.paymentMethod)
        elif nodeName_ == 'paymentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.paymentDate = dval_
            self.paymentDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.paymentDate)
        elif nodeName_ == 'invoiceAppearance':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceAppearance')
            value_ = self.gds_validate_string(value_, node, 'invoiceAppearance')
            self.invoiceAppearance = value_
            self.invoiceAppearance_nsprefix_ = child_.prefix
            # validate type InvoiceAppearanceType
            self.validate_InvoiceAppearanceType(self.invoiceAppearance)
        elif nodeName_ == 'source':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'source')
            value_ = self.gds_validate_string(value_, node, 'source')
            self.source = value_
            self.source_nsprefix_ = child_.prefix
            # validate type SourceType
            self.validate_SourceType(self.source)
        elif nodeName_ == 'invoiceDeliveryDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.invoiceDeliveryDate = dval_
            self.invoiceDeliveryDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.invoiceDeliveryDate)
        elif nodeName_ == 'currency':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'currency')
            value_ = self.gds_validate_string(value_, node, 'currency')
            self.currency = value_
            self.currency_nsprefix_ = child_.prefix
            # validate type CurrencyType
            self.validate_CurrencyType(self.currency)
        elif nodeName_ == 'invoiceNetAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'invoiceNetAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'invoiceNetAmount')
            self.invoiceNetAmount = fval_
            self.invoiceNetAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.invoiceNetAmount)
        elif nodeName_ == 'invoiceNetAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'invoiceNetAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'invoiceNetAmountHUF')
            self.invoiceNetAmountHUF = fval_
            self.invoiceNetAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.invoiceNetAmountHUF)
        elif nodeName_ == 'invoiceVatAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'invoiceVatAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'invoiceVatAmount')
            self.invoiceVatAmount = fval_
            self.invoiceVatAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.invoiceVatAmount)
        elif nodeName_ == 'invoiceVatAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'invoiceVatAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'invoiceVatAmountHUF')
            self.invoiceVatAmountHUF = fval_
            self.invoiceVatAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.invoiceVatAmountHUF)
        elif nodeName_ == 'transactionId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'transactionId')
            value_ = self.gds_validate_string(value_, node, 'transactionId')
            self.transactionId = value_
            self.transactionId_nsprefix_ = child_.prefix
            # validate type EntityIdType
            self.validate_EntityIdType(self.transactionId)
        elif nodeName_ == 'index' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'index')
            ival_ = self.gds_validate_integer(ival_, node, 'index')
            self.index = ival_
            self.index_nsprefix_ = child_.prefix
            # validate type InvoiceIndexType
            self.validate_InvoiceIndexType(self.index)
        elif nodeName_ == 'originalInvoiceNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originalInvoiceNumber')
            value_ = self.gds_validate_string(value_, node, 'originalInvoiceNumber')
            self.originalInvoiceNumber = value_
            self.originalInvoiceNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.originalInvoiceNumber)
        elif nodeName_ == 'modificationIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'modificationIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'modificationIndex')
            self.modificationIndex = ival_
            self.modificationIndex_nsprefix_ = child_.prefix
            # validate type InvoiceUnboundedIndexType
            self.validate_InvoiceUnboundedIndexType(self.modificationIndex)
        elif nodeName_ == 'insDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.insDate = dval_
            self.insDate_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.insDate)
        elif nodeName_ == 'completenessIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'completenessIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'completenessIndicator')
            self.completenessIndicator = ival_
            self.completenessIndicator_nsprefix_ = child_.prefix
# end class InvoiceDigestType


class InvoiceLinesType(GeneratedsSuper):
    """InvoiceLinesType -- A sz
    á
    ml
    á
    n vagy m
    ó
    dos
    í
    t
    ó
    okiraton szerepl
    ő
    t
    é
    telek kivonatos adatai
    Product/service digest data appearing on the invoice or the modification document
    maxLineNumber -- A sorok sz
    á
    ma k
    ö
    z
    ü
    l a legmagasabb, amit a sz
    á
    mla tartalmaz
    The highest line number value the invoice contains
    newCreatedLines -- A m
    ó
    dos
    í
    t
    ó
    okirat
    á
    ltal
    ú
    jk
    é
    nt l
    é
    trehozott sz
    á
    mlasorok
    New invoice lines created by the modification document

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, maxLineNumber=None, newCreatedLines=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.maxLineNumber = maxLineNumber
        self.validate_LineNumberType(self.maxLineNumber)
        self.maxLineNumber_nsprefix_ = "base"
        if newCreatedLines is None:
            self.newCreatedLines = []
        else:
            self.newCreatedLines = newCreatedLines
        self.newCreatedLines_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceLinesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceLinesType.subclass:
            return InvoiceLinesType.subclass(*args_, **kwargs_)
        else:
            return InvoiceLinesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_maxLineNumber(self):
        return self.maxLineNumber
    def set_maxLineNumber(self, maxLineNumber):
        self.maxLineNumber = maxLineNumber
    def get_newCreatedLines(self):
        return self.newCreatedLines
    def set_newCreatedLines(self, newCreatedLines):
        self.newCreatedLines = newCreatedLines
    def add_newCreatedLines(self, value):
        self.newCreatedLines.append(value)
    def insert_newCreatedLines_at(self, index, value):
        self.newCreatedLines.insert(index, value)
    def replace_newCreatedLines_at(self, index, value):
        self.newCreatedLines[index] = value
    def validate_LineNumberType(self, value):
        result = True
        # Validate type LineNumberType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.maxLineNumber is not None or
            self.newCreatedLines
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceLinesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceLinesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceLinesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceLinesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceLinesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceLinesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceLinesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.maxLineNumber is not None:
            namespaceprefix_ = self.maxLineNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.maxLineNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxLineNumber>%s</%smaxLineNumber>%s' % (namespaceprefix_ , self.gds_format_integer(self.maxLineNumber, input_name='maxLineNumber'), namespaceprefix_ , eol_))
        for newCreatedLines_ in self.newCreatedLines:
            namespaceprefix_ = self.newCreatedLines_nsprefix_ + ':' if (UseCapturedNS_ and self.newCreatedLines_nsprefix_) else ''
            newCreatedLines_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='newCreatedLines', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceLinesType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.maxLineNumber is not None:
            maxLineNumber_ = self.maxLineNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}maxLineNumber').text = self.gds_format_integer(maxLineNumber_)
        for newCreatedLines_ in self.newCreatedLines:
            newCreatedLines_.to_etree(element, name_='newCreatedLines', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceLinesType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.maxLineNumber is not None:
            showIndent(outfile, level)
            outfile.write('maxLineNumber=%d,\n' % self.maxLineNumber)
        showIndent(outfile, level)
        outfile.write('newCreatedLines=[\n')
        level += 1
        for newCreatedLines_ in self.newCreatedLines:
            showIndent(outfile, level)
            outfile.write('model_.NewCreatedLinesType(\n')
            newCreatedLines_.exportLiteral(outfile, level, name_='NewCreatedLinesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'maxLineNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'maxLineNumber')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'maxLineNumber')
            self.maxLineNumber = ival_
            self.maxLineNumber_nsprefix_ = child_.prefix
            # validate type LineNumberType
            self.validate_LineNumberType(self.maxLineNumber)
        elif nodeName_ == 'newCreatedLines':
            obj_ = NewCreatedLinesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.newCreatedLines.append(obj_)
            obj_.original_tagname_ = 'newCreatedLines'
# end class InvoiceLinesType


class InvoiceNumberQueryType(GeneratedsSuper):
    """InvoiceNumberQueryType -- Sz
    á
    mla lek
    é
    rdez
    é
    s sz
    á
    mlasz
    á
    m param
    é
    tere
    Invoice number param of the Invoice query
    invoiceNumber -- Sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma
    Sequential number of the original or modification invoice
    invoiceDirection -- Kimen
    ő
    vagy bej
    ö
    v
    ő
    sz
    á
    mla keres
    é
    si param
    é
    tere
    Inbound or outbound invoice query parameter
    batchIndex -- A m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma a k
    ö
    tegen bel
    ü
    l
    Sequence number of the modification document within the batch
    supplierTaxNumber -- Vev
    ő
    oldali lek
    é
    rdez
    é
    s eset
    é
    n a sz
    á
    mla ki
    á
    ll
    í
    t
    ó
    j
    á
    nak ad
    ó
    sz
    á
    ma, ha t
    ö
    bb
    é
    rv
    é
    nyes sz
    á
    mla is megtal
    á
    lhat
    ó
    azonos sorsz
    á
    mmal
    The supplier's tax number in case of querying as customer, if the query result found more than one valid invoices with the same invoice number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceNumber=None, invoiceDirection=None, batchIndex=None, supplierTaxNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceNumber = invoiceNumber
        self.validate_SimpleText50NotBlankType(self.invoiceNumber)
        self.invoiceNumber_nsprefix_ = "common"
        self.invoiceDirection = invoiceDirection
        self.validate_InvoiceDirectionType(self.invoiceDirection)
        self.invoiceDirection_nsprefix_ = None
        self.batchIndex = batchIndex
        self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        self.batchIndex_nsprefix_ = "base"
        self.supplierTaxNumber = supplierTaxNumber
        self.validate_TaxpayerIdType(self.supplierTaxNumber)
        self.supplierTaxNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceNumberQueryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceNumberQueryType.subclass:
            return InvoiceNumberQueryType.subclass(*args_, **kwargs_)
        else:
            return InvoiceNumberQueryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceNumber(self):
        return self.invoiceNumber
    def set_invoiceNumber(self, invoiceNumber):
        self.invoiceNumber = invoiceNumber
    def get_invoiceDirection(self):
        return self.invoiceDirection
    def set_invoiceDirection(self, invoiceDirection):
        self.invoiceDirection = invoiceDirection
    def get_batchIndex(self):
        return self.batchIndex
    def set_batchIndex(self, batchIndex):
        self.batchIndex = batchIndex
    def get_supplierTaxNumber(self):
        return self.supplierTaxNumber
    def set_supplierTaxNumber(self, supplierTaxNumber):
        self.supplierTaxNumber = supplierTaxNumber
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceDirectionType(self, value):
        result = True
        # Validate type InvoiceDirectionType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['INBOUND', 'OUTBOUND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvoiceDirectionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on InvoiceDirectionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on InvoiceDirectionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceUnboundedIndexType(self, value):
        result = True
        # Validate type InvoiceUnboundedIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceUnboundedIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_TaxpayerIdType(self, value):
        result = True
        # Validate type TaxpayerIdType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxpayerIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TaxpayerIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TaxpayerIdType_patterns_, ))
                result = False
        return result
    validate_TaxpayerIdType_patterns_ = [['^([0-9]{8})$']]
    def _hasContent(self):
        if (
            self.invoiceNumber is not None or
            self.invoiceDirection is not None or
            self.batchIndex is not None or
            self.supplierTaxNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='InvoiceNumberQueryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceNumberQueryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceNumberQueryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceNumberQueryType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceNumberQueryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceNumberQueryType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='InvoiceNumberQueryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceNumber is not None:
            namespaceprefix_ = self.invoiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceNumber>%s</%sinvoiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceNumber), input_name='invoiceNumber')), namespaceprefix_ , eol_))
        if self.invoiceDirection is not None:
            namespaceprefix_ = self.invoiceDirection_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDirection_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceDirection>%s</%sinvoiceDirection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceDirection), input_name='invoiceDirection')), namespaceprefix_ , eol_))
        if self.batchIndex is not None:
            namespaceprefix_ = self.batchIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.batchIndex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbatchIndex>%s</%sbatchIndex>%s' % (namespaceprefix_ , self.gds_format_integer(self.batchIndex, input_name='batchIndex'), namespaceprefix_ , eol_))
        if self.supplierTaxNumber is not None:
            namespaceprefix_ = self.supplierTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierTaxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssupplierTaxNumber>%s</%ssupplierTaxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.supplierTaxNumber), input_name='supplierTaxNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='InvoiceNumberQueryType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.invoiceNumber is not None:
            invoiceNumber_ = self.invoiceNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceNumber').text = self.gds_format_string(invoiceNumber_)
        if self.invoiceDirection is not None:
            invoiceDirection_ = self.invoiceDirection
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceDirection').text = self.gds_format_string(invoiceDirection_)
        if self.batchIndex is not None:
            batchIndex_ = self.batchIndex
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}batchIndex').text = self.gds_format_integer(batchIndex_)
        if self.supplierTaxNumber is not None:
            supplierTaxNumber_ = self.supplierTaxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}supplierTaxNumber').text = self.gds_format_string(supplierTaxNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceNumberQueryType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('invoiceNumber=%s,\n' % self.gds_encode(quote_python(self.invoiceNumber)))
        if self.invoiceDirection is not None:
            showIndent(outfile, level)
            outfile.write('invoiceDirection=%s,\n' % self.gds_encode(quote_python(self.invoiceDirection)))
        if self.batchIndex is not None:
            showIndent(outfile, level)
            outfile.write('batchIndex=%d,\n' % self.batchIndex)
        if self.supplierTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('supplierTaxNumber=%s,\n' % self.gds_encode(quote_python(self.supplierTaxNumber)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceNumber')
            value_ = self.gds_validate_string(value_, node, 'invoiceNumber')
            self.invoiceNumber = value_
            self.invoiceNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.invoiceNumber)
        elif nodeName_ == 'invoiceDirection':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceDirection')
            value_ = self.gds_validate_string(value_, node, 'invoiceDirection')
            self.invoiceDirection = value_
            self.invoiceDirection_nsprefix_ = child_.prefix
            # validate type InvoiceDirectionType
            self.validate_InvoiceDirectionType(self.invoiceDirection)
        elif nodeName_ == 'batchIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'batchIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'batchIndex')
            self.batchIndex = ival_
            self.batchIndex_nsprefix_ = child_.prefix
            # validate type InvoiceUnboundedIndexType
            self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        elif nodeName_ == 'supplierTaxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'supplierTaxNumber')
            value_ = self.gds_validate_string(value_, node, 'supplierTaxNumber')
            self.supplierTaxNumber = value_
            self.supplierTaxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.supplierTaxNumber)
# end class InvoiceNumberQueryType


class InvoiceOperationListType(GeneratedsSuper):
    """InvoiceOperationListType -- A k
    é
    r
    é
    shez tartoz
    ó
    k
    ö
    tegelt sz
    á
    mlam
    ű
    veletek
    Batch invoice operations of the request
    compressedContent -- T
    ö
    m
    ö
    r
    í
    tett tartalom jelz
    é
    se a feldolgoz
    á
    si folyamat sz
    á
    m
    á
    ra
    Compressed content indicator for the processing flow
    invoiceOperation -- A k
    é
    r
    é
    shez tartoz
    ó
    sz
    á
    mlam
    ű
    velet
    Invoice operation of the request

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, compressedContent=None, invoiceOperation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.compressedContent = compressedContent
        self.compressedContent_nsprefix_ = "xs"
        if invoiceOperation is None:
            self.invoiceOperation = []
        else:
            self.invoiceOperation = invoiceOperation
        self.invoiceOperation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceOperationListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceOperationListType.subclass:
            return InvoiceOperationListType.subclass(*args_, **kwargs_)
        else:
            return InvoiceOperationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_compressedContent(self):
        return self.compressedContent
    def set_compressedContent(self, compressedContent):
        self.compressedContent = compressedContent
    def get_invoiceOperation(self):
        return self.invoiceOperation
    def set_invoiceOperation(self, invoiceOperation):
        self.invoiceOperation = invoiceOperation
    def add_invoiceOperation(self, value):
        self.invoiceOperation.append(value)
    def insert_invoiceOperation_at(self, index, value):
        self.invoiceOperation.insert(index, value)
    def replace_invoiceOperation_at(self, index, value):
        self.invoiceOperation[index] = value
    def _hasContent(self):
        if (
            self.compressedContent is not None or
            self.invoiceOperation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceOperationListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceOperationListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceOperationListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceOperationListType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceOperationListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceOperationListType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceOperationListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.compressedContent is not None:
            namespaceprefix_ = self.compressedContent_nsprefix_ + ':' if (UseCapturedNS_ and self.compressedContent_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompressedContent>%s</%scompressedContent>%s' % (namespaceprefix_ , self.gds_format_boolean(self.compressedContent, input_name='compressedContent'), namespaceprefix_ , eol_))
        for invoiceOperation_ in self.invoiceOperation:
            namespaceprefix_ = self.invoiceOperation_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceOperation_nsprefix_) else ''
            invoiceOperation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceOperation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceOperationListType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.compressedContent is not None:
            compressedContent_ = self.compressedContent
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}compressedContent').text = self.gds_format_boolean(compressedContent_)
        for invoiceOperation_ in self.invoiceOperation:
            invoiceOperation_.to_etree(element, name_='invoiceOperation', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceOperationListType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.compressedContent is not None:
            showIndent(outfile, level)
            outfile.write('compressedContent=%s,\n' % self.compressedContent)
        showIndent(outfile, level)
        outfile.write('invoiceOperation=[\n')
        level += 1
        for invoiceOperation_ in self.invoiceOperation:
            showIndent(outfile, level)
            outfile.write('model_.InvoiceOperationType(\n')
            invoiceOperation_.exportLiteral(outfile, level, name_='InvoiceOperationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'compressedContent':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'compressedContent')
            ival_ = self.gds_validate_boolean(ival_, node, 'compressedContent')
            self.compressedContent = ival_
            self.compressedContent_nsprefix_ = child_.prefix
        elif nodeName_ == 'invoiceOperation':
            obj_ = InvoiceOperationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceOperation.append(obj_)
            obj_.original_tagname_ = 'invoiceOperation'
# end class InvoiceOperationListType


class InvoiceOperationType(GeneratedsSuper):
    """InvoiceOperationType -- A k
    é
    r
    é
    shez tartoz
    ó
    sz
    á
    mlam
    ű
    velet
    Invoice operation of the request
    index -- A sz
    á
    mla sorsz
    á
    ma a k
    é
    r
    é
    sen bel
    ü
    l
    Sequence number of the invoice within the request
    invoiceOperation -- A k
    é
    rt sz
    á
    mla m
    ű
    velet t
    í
    pusa
    Type of the desired invoice operation
    invoiceData -- Sz
    á
    mla adatok BASE64-ben k
    ó
    dolt tartalma
    Invoice data in BASE64 encoded form
    electronicInvoiceHash -- Elektronikus sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat
    á
    llom
    á
    ny hash lenyomata
    Electronic invoice or modification document file hash value

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, index=None, invoiceOperation=None, invoiceData=None, electronicInvoiceHash=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.index = index
        self.validate_InvoiceIndexType(self.index)
        self.index_nsprefix_ = "base"
        self.invoiceOperation = invoiceOperation
        self.validate_ManageInvoiceOperationType(self.invoiceOperation)
        self.invoiceOperation_nsprefix_ = None
        self.invoiceData = invoiceData
        self.invoiceData_nsprefix_ = "xs"
        self.electronicInvoiceHash = electronicInvoiceHash
        self.electronicInvoiceHash_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceOperationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceOperationType.subclass:
            return InvoiceOperationType.subclass(*args_, **kwargs_)
        else:
            return InvoiceOperationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_invoiceOperation(self):
        return self.invoiceOperation
    def set_invoiceOperation(self, invoiceOperation):
        self.invoiceOperation = invoiceOperation
    def get_invoiceData(self):
        return self.invoiceData
    def set_invoiceData(self, invoiceData):
        self.invoiceData = invoiceData
    def get_electronicInvoiceHash(self):
        return self.electronicInvoiceHash
    def set_electronicInvoiceHash(self, electronicInvoiceHash):
        self.electronicInvoiceHash = electronicInvoiceHash
    def validate_InvoiceIndexType(self, value):
        result = True
        # Validate type InvoiceIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ManageInvoiceOperationType(self, value):
        result = True
        # Validate type ManageInvoiceOperationType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['CREATE', 'MODIFY', 'STORNO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ManageInvoiceOperationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ManageInvoiceOperationType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ManageInvoiceOperationType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.index is not None or
            self.invoiceOperation is not None or
            self.invoiceData is not None or
            self.electronicInvoiceHash is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='InvoiceOperationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceOperationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceOperationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceOperationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceOperationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceOperationType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='InvoiceOperationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.index is not None:
            namespaceprefix_ = self.index_nsprefix_ + ':' if (UseCapturedNS_ and self.index_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindex>%s</%sindex>%s' % (namespaceprefix_ , self.gds_format_integer(self.index, input_name='index'), namespaceprefix_ , eol_))
        if self.invoiceOperation is not None:
            namespaceprefix_ = self.invoiceOperation_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceOperation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceOperation>%s</%sinvoiceOperation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceOperation), input_name='invoiceOperation')), namespaceprefix_ , eol_))
        if self.invoiceData is not None:
            namespaceprefix_ = self.invoiceData_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceData_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceData>%s</%sinvoiceData>%s' % (namespaceprefix_ , self.gds_format_base64(self.invoiceData, input_name='invoiceData'), namespaceprefix_ , eol_))
        if self.electronicInvoiceHash is not None:
            namespaceprefix_ = self.electronicInvoiceHash_nsprefix_ + ':' if (UseCapturedNS_ and self.electronicInvoiceHash_nsprefix_) else ''
            self.electronicInvoiceHash.export(outfile, level, namespaceprefix_, namespacedef_='', name_='electronicInvoiceHash', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceOperationType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.index is not None:
            index_ = self.index
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}index').text = self.gds_format_integer(index_)
        if self.invoiceOperation is not None:
            invoiceOperation_ = self.invoiceOperation
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceOperation').text = self.gds_format_string(invoiceOperation_)
        if self.invoiceData is not None:
            invoiceData_ = self.invoiceData
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceData').text = self.gds_format_base64(invoiceData_)
        if self.electronicInvoiceHash is not None:
            electronicInvoiceHash_ = self.electronicInvoiceHash
            electronicInvoiceHash_.to_etree(element, name_='electronicInvoiceHash', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceOperationType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.index is not None:
            showIndent(outfile, level)
            outfile.write('index=%d,\n' % self.index)
        if self.invoiceOperation is not None:
            showIndent(outfile, level)
            outfile.write('invoiceOperation=%s,\n' % self.gds_encode(quote_python(self.invoiceOperation)))
        if self.invoiceData is not None:
            showIndent(outfile, level)
            outfile.write('invoiceData=model_.base64Binary(\n')
            self.invoiceData.exportLiteral(outfile, level, name_='invoiceData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.electronicInvoiceHash is not None:
            showIndent(outfile, level)
            outfile.write('electronicInvoiceHash=model_.CryptoType(\n')
            self.electronicInvoiceHash.exportLiteral(outfile, level, name_='electronicInvoiceHash')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'index' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'index')
            ival_ = self.gds_validate_integer(ival_, node, 'index')
            self.index = ival_
            self.index_nsprefix_ = child_.prefix
            # validate type InvoiceIndexType
            self.validate_InvoiceIndexType(self.index)
        elif nodeName_ == 'invoiceOperation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceOperation')
            value_ = self.gds_validate_string(value_, node, 'invoiceOperation')
            self.invoiceOperation = value_
            self.invoiceOperation_nsprefix_ = child_.prefix
            # validate type ManageInvoiceOperationType
            self.validate_ManageInvoiceOperationType(self.invoiceOperation)
        elif nodeName_ == 'invoiceData':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'invoiceData')
            else:
                bval_ = None
            self.invoiceData = bval_
            self.invoiceData_nsprefix_ = child_.prefix
        elif nodeName_ == 'electronicInvoiceHash':
            obj_ = CryptoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.electronicInvoiceHash = obj_
            obj_.original_tagname_ = 'electronicInvoiceHash'
# end class InvoiceOperationType


class InvoiceQueryParamsType(GeneratedsSuper):
    """InvoiceQueryParamsType -- Sz
    á
    mla lek
    é
    rdez
    é
    si param
    é
    terek
    Invoice query parameters
    mandatoryQueryParams -- A sz
    á
    mla lek
    é
    rdez
    é
    s k
    ö
    telez
    ő
    param
    é
    terei
    Mandatory params of the invoice query
    additionalQueryParams -- A sz
    á
    mla lek
    é
    rdez
    é
    s kieg
    é
    sz
    í
    t
    ő
    param
    é
    terei
    Additional params of the invoice query
    relationalQueryParams -- A sz
    á
    mla lek
    é
    rdez
    é
    s rel
    á
    ci
    ó
    s param
    é
    terei
    Relational params of the invoice query
    transactionQueryParams -- A sz
    á
    mla lek
    é
    rdez
    é
    s tranzakci
    ó
    s param
    é
    terei
    Transactional params of the invoice query

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, mandatoryQueryParams=None, additionalQueryParams=None, relationalQueryParams=None, transactionQueryParams=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mandatoryQueryParams = mandatoryQueryParams
        self.mandatoryQueryParams_nsprefix_ = None
        self.additionalQueryParams = additionalQueryParams
        self.additionalQueryParams_nsprefix_ = None
        self.relationalQueryParams = relationalQueryParams
        self.relationalQueryParams_nsprefix_ = None
        self.transactionQueryParams = transactionQueryParams
        self.transactionQueryParams_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceQueryParamsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceQueryParamsType.subclass:
            return InvoiceQueryParamsType.subclass(*args_, **kwargs_)
        else:
            return InvoiceQueryParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mandatoryQueryParams(self):
        return self.mandatoryQueryParams
    def set_mandatoryQueryParams(self, mandatoryQueryParams):
        self.mandatoryQueryParams = mandatoryQueryParams
    def get_additionalQueryParams(self):
        return self.additionalQueryParams
    def set_additionalQueryParams(self, additionalQueryParams):
        self.additionalQueryParams = additionalQueryParams
    def get_relationalQueryParams(self):
        return self.relationalQueryParams
    def set_relationalQueryParams(self, relationalQueryParams):
        self.relationalQueryParams = relationalQueryParams
    def get_transactionQueryParams(self):
        return self.transactionQueryParams
    def set_transactionQueryParams(self, transactionQueryParams):
        self.transactionQueryParams = transactionQueryParams
    def _hasContent(self):
        if (
            self.mandatoryQueryParams is not None or
            self.additionalQueryParams is not None or
            self.relationalQueryParams is not None or
            self.transactionQueryParams is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceQueryParamsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceQueryParamsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceQueryParamsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceQueryParamsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceQueryParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceQueryParamsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceQueryParamsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mandatoryQueryParams is not None:
            namespaceprefix_ = self.mandatoryQueryParams_nsprefix_ + ':' if (UseCapturedNS_ and self.mandatoryQueryParams_nsprefix_) else ''
            self.mandatoryQueryParams.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mandatoryQueryParams', pretty_print=pretty_print)
        if self.additionalQueryParams is not None:
            namespaceprefix_ = self.additionalQueryParams_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalQueryParams_nsprefix_) else ''
            self.additionalQueryParams.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalQueryParams', pretty_print=pretty_print)
        if self.relationalQueryParams is not None:
            namespaceprefix_ = self.relationalQueryParams_nsprefix_ + ':' if (UseCapturedNS_ and self.relationalQueryParams_nsprefix_) else ''
            self.relationalQueryParams.export(outfile, level, namespaceprefix_, namespacedef_='', name_='relationalQueryParams', pretty_print=pretty_print)
        if self.transactionQueryParams is not None:
            namespaceprefix_ = self.transactionQueryParams_nsprefix_ + ':' if (UseCapturedNS_ and self.transactionQueryParams_nsprefix_) else ''
            self.transactionQueryParams.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transactionQueryParams', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceQueryParamsType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.mandatoryQueryParams is not None:
            mandatoryQueryParams_ = self.mandatoryQueryParams
            mandatoryQueryParams_.to_etree(element, name_='mandatoryQueryParams', mapping_=mapping_, nsmap_=nsmap_)
        if self.additionalQueryParams is not None:
            additionalQueryParams_ = self.additionalQueryParams
            additionalQueryParams_.to_etree(element, name_='additionalQueryParams', mapping_=mapping_, nsmap_=nsmap_)
        if self.relationalQueryParams is not None:
            relationalQueryParams_ = self.relationalQueryParams
            relationalQueryParams_.to_etree(element, name_='relationalQueryParams', mapping_=mapping_, nsmap_=nsmap_)
        if self.transactionQueryParams is not None:
            transactionQueryParams_ = self.transactionQueryParams
            transactionQueryParams_.to_etree(element, name_='transactionQueryParams', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceQueryParamsType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.mandatoryQueryParams is not None:
            showIndent(outfile, level)
            outfile.write('mandatoryQueryParams=model_.MandatoryQueryParamsType(\n')
            self.mandatoryQueryParams.exportLiteral(outfile, level, name_='mandatoryQueryParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.additionalQueryParams is not None:
            showIndent(outfile, level)
            outfile.write('additionalQueryParams=model_.AdditionalQueryParamsType(\n')
            self.additionalQueryParams.exportLiteral(outfile, level, name_='additionalQueryParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.relationalQueryParams is not None:
            showIndent(outfile, level)
            outfile.write('relationalQueryParams=model_.RelationalQueryParamsType(\n')
            self.relationalQueryParams.exportLiteral(outfile, level, name_='relationalQueryParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.transactionQueryParams is not None:
            showIndent(outfile, level)
            outfile.write('transactionQueryParams=model_.TransactionQueryParamsType(\n')
            self.transactionQueryParams.exportLiteral(outfile, level, name_='transactionQueryParams')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mandatoryQueryParams':
            obj_ = MandatoryQueryParamsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mandatoryQueryParams = obj_
            obj_.original_tagname_ = 'mandatoryQueryParams'
        elif nodeName_ == 'additionalQueryParams':
            obj_ = AdditionalQueryParamsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalQueryParams = obj_
            obj_.original_tagname_ = 'additionalQueryParams'
        elif nodeName_ == 'relationalQueryParams':
            obj_ = RelationalQueryParamsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.relationalQueryParams = obj_
            obj_.original_tagname_ = 'relationalQueryParams'
        elif nodeName_ == 'transactionQueryParams':
            obj_ = TransactionQueryParamsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transactionQueryParams = obj_
            obj_.original_tagname_ = 'transactionQueryParams'
# end class InvoiceQueryParamsType


class InvoiceReferenceDataType(GeneratedsSuper):
    """InvoiceReferenceDataType -- A m
    ó
    dos
    í
    t
    á
    s vagy
    é
    rv
    é
    nytelen
    í
    t
    é
    s adatai
    Modification or cancellation data
    originalInvoiceNumber -- Az eredeti sz
    á
    mla sorsz
    á
    ma, melyre a m
    ó
    dos
    í
    t
    á
    s vonatkozik  -
    Á
    FA tv. 170.
    §
    (1) c)
    Sequence number of the original invoice, on which the modification occurs - section 170 (1) c) of the VAT law
    modifyWithoutMaster -- Annak jelz
    é
    se, hogy a m
    ó
    dos
    í
    t
    á
    s olyan alapsz
    á
    ml
    á
    ra hivatkozik, amelyr
    ő
    l nem t
    ö
    rt
    é
    nt
    é
    s nem is fog t
    ö
    rt
    é
    nni adatszolg
    á
    ltat
    á
    s
    Indicates whether the modification references to an original invoice which is not and will not be exchanged
    modificationTimestamp -- A m
    ó
    dos
    í
    t
    ó
    okirat k
    é
    sz
    í
    t
    é
    s
    é
    nek id
    ő
    b
    é
    lyege a forr
    á
    srendszerben UTC id
    ő
    ben
    Creation date timestamp of the modification document in UTC time
    modificationIndex -- A sz
    á
    ml
    á
    ra vonatkoz
    ó
    m
    ó
    dos
    í
    t
    ó
    okirat egyedi sorsz
    á
    ma
    The unique sequence number referring to the original invoice

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, originalInvoiceNumber=None, modifyWithoutMaster=None, modificationTimestamp=None, modificationIndex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.originalInvoiceNumber = originalInvoiceNumber
        self.validate_SimpleText50NotBlankType(self.originalInvoiceNumber)
        self.originalInvoiceNumber_nsprefix_ = "common"
        self.modifyWithoutMaster = modifyWithoutMaster
        self.modifyWithoutMaster_nsprefix_ = "xs"
        if isinstance(modificationTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modificationTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modificationTimestamp
        self.modificationTimestamp = initvalue_
        self.modificationTimestamp_nsprefix_ = "base"
        self.modificationIndex = modificationIndex
        self.validate_InvoiceUnboundedIndexType(self.modificationIndex)
        self.modificationIndex_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceReferenceDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceReferenceDataType.subclass:
            return InvoiceReferenceDataType.subclass(*args_, **kwargs_)
        else:
            return InvoiceReferenceDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalInvoiceNumber(self):
        return self.originalInvoiceNumber
    def set_originalInvoiceNumber(self, originalInvoiceNumber):
        self.originalInvoiceNumber = originalInvoiceNumber
    def get_modifyWithoutMaster(self):
        return self.modifyWithoutMaster
    def set_modifyWithoutMaster(self, modifyWithoutMaster):
        self.modifyWithoutMaster = modifyWithoutMaster
    def get_modificationTimestamp(self):
        return self.modificationTimestamp
    def set_modificationTimestamp(self, modificationTimestamp):
        self.modificationTimestamp = modificationTimestamp
    def get_modificationIndex(self):
        return self.modificationIndex
    def set_modificationIndex(self, modificationIndex):
        self.modificationIndex = modificationIndex
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.fromisostring('2010-01-01T00:00:00.000000').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceTimestampType_patterns_, ))
                result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def validate_InvoiceUnboundedIndexType(self, value):
        result = True
        # Validate type InvoiceUnboundedIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceUnboundedIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.originalInvoiceNumber is not None or
            self.modifyWithoutMaster is not None or
            self.modificationTimestamp is not None or
            self.modificationIndex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='InvoiceReferenceDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceReferenceDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceReferenceDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceReferenceDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceReferenceDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceReferenceDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='InvoiceReferenceDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalInvoiceNumber is not None:
            namespaceprefix_ = self.originalInvoiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.originalInvoiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalInvoiceNumber>%s</%soriginalInvoiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originalInvoiceNumber), input_name='originalInvoiceNumber')), namespaceprefix_ , eol_))
        if self.modifyWithoutMaster is not None:
            namespaceprefix_ = self.modifyWithoutMaster_nsprefix_ + ':' if (UseCapturedNS_ and self.modifyWithoutMaster_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodifyWithoutMaster>%s</%smodifyWithoutMaster>%s' % (namespaceprefix_ , self.gds_format_boolean(self.modifyWithoutMaster, input_name='modifyWithoutMaster'), namespaceprefix_ , eol_))
        if self.modificationTimestamp is not None:
            namespaceprefix_ = self.modificationTimestamp_nsprefix_ + ':' if (UseCapturedNS_ and self.modificationTimestamp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodificationTimestamp>%s</%smodificationTimestamp>%s' % (namespaceprefix_ , self.gds_format_datetime(self.modificationTimestamp, input_name='modificationTimestamp'), namespaceprefix_ , eol_))
        if self.modificationIndex is not None:
            namespaceprefix_ = self.modificationIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.modificationIndex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodificationIndex>%s</%smodificationIndex>%s' % (namespaceprefix_ , self.gds_format_integer(self.modificationIndex, input_name='modificationIndex'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='InvoiceReferenceDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.originalInvoiceNumber is not None:
            originalInvoiceNumber_ = self.originalInvoiceNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}originalInvoiceNumber').text = self.gds_format_string(originalInvoiceNumber_)
        if self.modifyWithoutMaster is not None:
            modifyWithoutMaster_ = self.modifyWithoutMaster
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}modifyWithoutMaster').text = self.gds_format_boolean(modifyWithoutMaster_)
        if self.modificationTimestamp is not None:
            modificationTimestamp_ = self.modificationTimestamp
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}modificationTimestamp').text = self.gds_format_datetime(modificationTimestamp_)
        if self.modificationIndex is not None:
            modificationIndex_ = self.modificationIndex
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}modificationIndex').text = self.gds_format_integer(modificationIndex_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceReferenceDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.originalInvoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('originalInvoiceNumber=%s,\n' % self.gds_encode(quote_python(self.originalInvoiceNumber)))
        if self.modifyWithoutMaster is not None:
            showIndent(outfile, level)
            outfile.write('modifyWithoutMaster=%s,\n' % self.modifyWithoutMaster)
        if self.modificationTimestamp is not None:
            showIndent(outfile, level)
            outfile.write('modificationTimestamp=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.modificationTimestamp, input_name='modificationTimestamp'))
        if self.modificationIndex is not None:
            showIndent(outfile, level)
            outfile.write('modificationIndex=%d,\n' % self.modificationIndex)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalInvoiceNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originalInvoiceNumber')
            value_ = self.gds_validate_string(value_, node, 'originalInvoiceNumber')
            self.originalInvoiceNumber = value_
            self.originalInvoiceNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.originalInvoiceNumber)
        elif nodeName_ == 'modifyWithoutMaster':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'modifyWithoutMaster')
            ival_ = self.gds_validate_boolean(ival_, node, 'modifyWithoutMaster')
            self.modifyWithoutMaster = ival_
            self.modifyWithoutMaster_nsprefix_ = child_.prefix
        elif nodeName_ == 'modificationTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.modificationTimestamp = dval_
            self.modificationTimestamp_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.modificationTimestamp)
        elif nodeName_ == 'modificationIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'modificationIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'modificationIndex')
            self.modificationIndex = ival_
            self.modificationIndex_nsprefix_ = child_.prefix
            # validate type InvoiceUnboundedIndexType
            self.validate_InvoiceUnboundedIndexType(self.modificationIndex)
# end class InvoiceReferenceDataType


class ManageAnnulmentRequestType(BasicOnlineInvoiceRequestType):
    """ManageAnnulmentRequestType -- A POST /manageAnnulment REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s t
    í
    pusa
    Request type of the POST /manageAnnulment REST operation
    exchangeToken -- A tranzakci
    ó
    hoz kiadott egyedi
    é
    s dek
    ó
    dolt token
    The decoded unique token issued for the current transaction
    annulmentOperations -- A k
    é
    r
    é
    shez tartoz
    ó
    k
    ö
    tegelt technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    sek
    Batch technical annulment operations of the request

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceRequestType
    def __init__(self, header=None, user=None, software=None, exchangeToken=None, annulmentOperations=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ManageAnnulmentRequestType"), self).__init__(header, user, software, extensiontype_,  **kwargs_)
        self.exchangeToken = exchangeToken
        self.validate_SimpleText50NotBlankType(self.exchangeToken)
        self.exchangeToken_nsprefix_ = "common"
        self.annulmentOperations = annulmentOperations
        self.annulmentOperations_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManageAnnulmentRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManageAnnulmentRequestType.subclass:
            return ManageAnnulmentRequestType.subclass(*args_, **kwargs_)
        else:
            return ManageAnnulmentRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exchangeToken(self):
        return self.exchangeToken
    def set_exchangeToken(self, exchangeToken):
        self.exchangeToken = exchangeToken
    def get_annulmentOperations(self):
        return self.annulmentOperations
    def set_annulmentOperations(self, annulmentOperations):
        self.annulmentOperations = annulmentOperations
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.exchangeToken is not None or
            self.annulmentOperations is not None or
            super(ManageAnnulmentRequestType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ManageAnnulmentRequestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ManageAnnulmentRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ManageAnnulmentRequestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageAnnulmentRequestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ManageAnnulmentRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ManageAnnulmentRequestType'):
        super(ManageAnnulmentRequestType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageAnnulmentRequestType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ManageAnnulmentRequestType', fromsubclass_=False, pretty_print=True):
        super(ManageAnnulmentRequestType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.exchangeToken is not None:
            namespaceprefix_ = self.exchangeToken_nsprefix_ + ':' if (UseCapturedNS_ and self.exchangeToken_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexchangeToken>%s</%sexchangeToken>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.exchangeToken), input_name='exchangeToken')), namespaceprefix_ , eol_))
        if self.annulmentOperations is not None:
            namespaceprefix_ = self.annulmentOperations_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentOperations_nsprefix_) else ''
            self.annulmentOperations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annulmentOperations', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ManageAnnulmentRequestType', mapping_=None, nsmap_=None):
        element = super(ManageAnnulmentRequestType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.exchangeToken is not None:
            exchangeToken_ = self.exchangeToken
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}exchangeToken').text = self.gds_format_string(exchangeToken_)
        if self.annulmentOperations is not None:
            annulmentOperations_ = self.annulmentOperations
            annulmentOperations_.to_etree(element, name_='annulmentOperations', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ManageAnnulmentRequestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ManageAnnulmentRequestType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(ManageAnnulmentRequestType, self)._exportLiteralChildren(outfile, level, name_)
        if self.exchangeToken is not None:
            showIndent(outfile, level)
            outfile.write('exchangeToken=%s,\n' % self.gds_encode(quote_python(self.exchangeToken)))
        if self.annulmentOperations is not None:
            showIndent(outfile, level)
            outfile.write('annulmentOperations=model_.AnnulmentOperationListType(\n')
            self.annulmentOperations.exportLiteral(outfile, level, name_='annulmentOperations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ManageAnnulmentRequestType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'exchangeToken':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'exchangeToken')
            value_ = self.gds_validate_string(value_, node, 'exchangeToken')
            self.exchangeToken = value_
            self.exchangeToken_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.exchangeToken)
        elif nodeName_ == 'annulmentOperations':
            obj_ = AnnulmentOperationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annulmentOperations = obj_
            obj_.original_tagname_ = 'annulmentOperations'
        super(ManageAnnulmentRequestType, self)._buildChildren(child_, node, nodeName_, True)
# end class ManageAnnulmentRequestType


class ManageInvoiceRequestType(BasicOnlineInvoiceRequestType):
    """ManageInvoiceRequestType -- A POST /manageInvoice REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s t
    í
    pusa
    Request type of the POST /manageInvoice REST operation
    exchangeToken -- A tranzakci
    ó
    hoz kiadott egyedi
    é
    s dek
    ó
    dolt token
    The decoded unique token issued for the current transaction
    invoiceOperations -- A k
    é
    r
    é
    shez tartoz
    ó
    k
    ö
    tegelt sz
    á
    mlam
    ű
    veletek
    Batch invoice operations of the request

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceRequestType
    def __init__(self, header=None, user=None, software=None, exchangeToken=None, invoiceOperations=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ManageInvoiceRequestType"), self).__init__(header, user, software, extensiontype_,  **kwargs_)
        self.exchangeToken = exchangeToken
        self.validate_SimpleText50NotBlankType(self.exchangeToken)
        self.exchangeToken_nsprefix_ = "common"
        self.invoiceOperations = invoiceOperations
        self.invoiceOperations_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManageInvoiceRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManageInvoiceRequestType.subclass:
            return ManageInvoiceRequestType.subclass(*args_, **kwargs_)
        else:
            return ManageInvoiceRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exchangeToken(self):
        return self.exchangeToken
    def set_exchangeToken(self, exchangeToken):
        self.exchangeToken = exchangeToken
    def get_invoiceOperations(self):
        return self.invoiceOperations
    def set_invoiceOperations(self, invoiceOperations):
        self.invoiceOperations = invoiceOperations
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.exchangeToken is not None or
            self.invoiceOperations is not None or
            super(ManageInvoiceRequestType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ManageInvoiceRequestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ManageInvoiceRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ManageInvoiceRequestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageInvoiceRequestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ManageInvoiceRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ManageInvoiceRequestType'):
        super(ManageInvoiceRequestType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageInvoiceRequestType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ManageInvoiceRequestType', fromsubclass_=False, pretty_print=True):
        super(ManageInvoiceRequestType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.exchangeToken is not None:
            namespaceprefix_ = self.exchangeToken_nsprefix_ + ':' if (UseCapturedNS_ and self.exchangeToken_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexchangeToken>%s</%sexchangeToken>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.exchangeToken), input_name='exchangeToken')), namespaceprefix_ , eol_))
        if self.invoiceOperations is not None:
            namespaceprefix_ = self.invoiceOperations_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceOperations_nsprefix_) else ''
            self.invoiceOperations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceOperations', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ManageInvoiceRequestType', mapping_=None, nsmap_=None):
        element = super(ManageInvoiceRequestType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.exchangeToken is not None:
            exchangeToken_ = self.exchangeToken
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}exchangeToken').text = self.gds_format_string(exchangeToken_)
        if self.invoiceOperations is not None:
            invoiceOperations_ = self.invoiceOperations
            invoiceOperations_.to_etree(element, name_='invoiceOperations', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ManageInvoiceRequestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ManageInvoiceRequestType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(ManageInvoiceRequestType, self)._exportLiteralChildren(outfile, level, name_)
        if self.exchangeToken is not None:
            showIndent(outfile, level)
            outfile.write('exchangeToken=%s,\n' % self.gds_encode(quote_python(self.exchangeToken)))
        if self.invoiceOperations is not None:
            showIndent(outfile, level)
            outfile.write('invoiceOperations=model_.InvoiceOperationListType(\n')
            self.invoiceOperations.exportLiteral(outfile, level, name_='invoiceOperations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ManageInvoiceRequestType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'exchangeToken':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'exchangeToken')
            value_ = self.gds_validate_string(value_, node, 'exchangeToken')
            self.exchangeToken = value_
            self.exchangeToken_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.exchangeToken)
        elif nodeName_ == 'invoiceOperations':
            obj_ = InvoiceOperationListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceOperations = obj_
            obj_.original_tagname_ = 'invoiceOperations'
        super(ManageInvoiceRequestType, self)._buildChildren(child_, node, nodeName_, True)
# end class ManageInvoiceRequestType


class MandatoryQueryParamsType(GeneratedsSuper):
    """MandatoryQueryParamsType -- A sz
    á
    mla lek
    é
    rdez
    é
    s k
    ö
    telez
    ő
    param
    é
    terei
    Mandatory params of the invoice query
    invoiceIssueDate -- Sz
    á
    mla ki
    á
    ll
    í
    t
    á
    s
    á
    nak d
    á
    tumtartom
    á
    nya
    Date range of the invoice issue date
    insDate -- Sz
    á
    mla adatszolg
    á
    ltat
    á
    s feldolgoz
    á
    s
    á
    nak id
    ő
    pont tartom
    á
    nya UTC id
    ő
    szerint
    Datetime range of processing data exchange in UTC time
    originalInvoiceNumber -- Az eredeti sz
    á
    mla sorsz
    á
    ma, melyre a m
    ó
    dos
    í
    t
    á
    s vonatkozik
    Sequence number of the original invoice, on which the modification occurs

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceIssueDate=None, insDate=None, originalInvoiceNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceIssueDate = invoiceIssueDate
        self.invoiceIssueDate_nsprefix_ = None
        self.insDate = insDate
        self.insDate_nsprefix_ = None
        self.originalInvoiceNumber = originalInvoiceNumber
        self.validate_SimpleText50NotBlankType(self.originalInvoiceNumber)
        self.originalInvoiceNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MandatoryQueryParamsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MandatoryQueryParamsType.subclass:
            return MandatoryQueryParamsType.subclass(*args_, **kwargs_)
        else:
            return MandatoryQueryParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceIssueDate(self):
        return self.invoiceIssueDate
    def set_invoiceIssueDate(self, invoiceIssueDate):
        self.invoiceIssueDate = invoiceIssueDate
    def get_insDate(self):
        return self.insDate
    def set_insDate(self, insDate):
        self.insDate = insDate
    def get_originalInvoiceNumber(self):
        return self.originalInvoiceNumber
    def set_originalInvoiceNumber(self, originalInvoiceNumber):
        self.originalInvoiceNumber = originalInvoiceNumber
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.invoiceIssueDate is not None or
            self.insDate is not None or
            self.originalInvoiceNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='MandatoryQueryParamsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MandatoryQueryParamsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MandatoryQueryParamsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MandatoryQueryParamsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MandatoryQueryParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MandatoryQueryParamsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='MandatoryQueryParamsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceIssueDate is not None:
            namespaceprefix_ = self.invoiceIssueDate_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceIssueDate_nsprefix_) else ''
            self.invoiceIssueDate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceIssueDate', pretty_print=pretty_print)
        if self.insDate is not None:
            namespaceprefix_ = self.insDate_nsprefix_ + ':' if (UseCapturedNS_ and self.insDate_nsprefix_) else ''
            self.insDate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='insDate', pretty_print=pretty_print)
        if self.originalInvoiceNumber is not None:
            namespaceprefix_ = self.originalInvoiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.originalInvoiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalInvoiceNumber>%s</%soriginalInvoiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originalInvoiceNumber), input_name='originalInvoiceNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='MandatoryQueryParamsType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.invoiceIssueDate is not None:
            invoiceIssueDate_ = self.invoiceIssueDate
            invoiceIssueDate_.to_etree(element, name_='invoiceIssueDate', mapping_=mapping_, nsmap_=nsmap_)
        if self.insDate is not None:
            insDate_ = self.insDate
            insDate_.to_etree(element, name_='insDate', mapping_=mapping_, nsmap_=nsmap_)
        if self.originalInvoiceNumber is not None:
            originalInvoiceNumber_ = self.originalInvoiceNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}originalInvoiceNumber').text = self.gds_format_string(originalInvoiceNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MandatoryQueryParamsType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceIssueDate is not None:
            showIndent(outfile, level)
            outfile.write('invoiceIssueDate=model_.DateIntervalParamType(\n')
            self.invoiceIssueDate.exportLiteral(outfile, level, name_='invoiceIssueDate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.insDate is not None:
            showIndent(outfile, level)
            outfile.write('insDate=model_.DateTimeIntervalParamType(\n')
            self.insDate.exportLiteral(outfile, level, name_='insDate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.originalInvoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('originalInvoiceNumber=%s,\n' % self.gds_encode(quote_python(self.originalInvoiceNumber)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceIssueDate':
            obj_ = DateIntervalParamType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceIssueDate = obj_
            obj_.original_tagname_ = 'invoiceIssueDate'
        elif nodeName_ == 'insDate':
            obj_ = DateTimeIntervalParamType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.insDate = obj_
            obj_.original_tagname_ = 'insDate'
        elif nodeName_ == 'originalInvoiceNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originalInvoiceNumber')
            value_ = self.gds_validate_string(value_, node, 'originalInvoiceNumber')
            self.originalInvoiceNumber = value_
            self.originalInvoiceNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.originalInvoiceNumber)
# end class MandatoryQueryParamsType


class NewCreatedLinesType(GeneratedsSuper):
    """NewCreatedLinesType -- A m
    ó
    dos
    í
    t
    ó
    okirat
    á
    ltal
    ú
    jk
    é
    nt l
    é
    trehozott sz
    á
    mlasorok
    New invoice lines created by the modification document
    lineNumberIntervalStart -- Sz
    á
    mla sor intervallum kezdete
    Invoice line interval start
    lineNumberIntervalEnd -- Sz
    á
    mla sor intervallum v
    é
    ge (inkluz
    í
    v)
    Invoice line interval end (inclusive)

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lineNumberIntervalStart=None, lineNumberIntervalEnd=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lineNumberIntervalStart = lineNumberIntervalStart
        self.validate_LineNumberType(self.lineNumberIntervalStart)
        self.lineNumberIntervalStart_nsprefix_ = "base"
        self.lineNumberIntervalEnd = lineNumberIntervalEnd
        self.validate_LineNumberType(self.lineNumberIntervalEnd)
        self.lineNumberIntervalEnd_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NewCreatedLinesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NewCreatedLinesType.subclass:
            return NewCreatedLinesType.subclass(*args_, **kwargs_)
        else:
            return NewCreatedLinesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lineNumberIntervalStart(self):
        return self.lineNumberIntervalStart
    def set_lineNumberIntervalStart(self, lineNumberIntervalStart):
        self.lineNumberIntervalStart = lineNumberIntervalStart
    def get_lineNumberIntervalEnd(self):
        return self.lineNumberIntervalEnd
    def set_lineNumberIntervalEnd(self, lineNumberIntervalEnd):
        self.lineNumberIntervalEnd = lineNumberIntervalEnd
    def validate_LineNumberType(self, value):
        result = True
        # Validate type LineNumberType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.lineNumberIntervalStart is not None or
            self.lineNumberIntervalEnd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='NewCreatedLinesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NewCreatedLinesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NewCreatedLinesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NewCreatedLinesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NewCreatedLinesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NewCreatedLinesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='NewCreatedLinesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lineNumberIntervalStart is not None:
            namespaceprefix_ = self.lineNumberIntervalStart_nsprefix_ + ':' if (UseCapturedNS_ and self.lineNumberIntervalStart_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineNumberIntervalStart>%s</%slineNumberIntervalStart>%s' % (namespaceprefix_ , self.gds_format_integer(self.lineNumberIntervalStart, input_name='lineNumberIntervalStart'), namespaceprefix_ , eol_))
        if self.lineNumberIntervalEnd is not None:
            namespaceprefix_ = self.lineNumberIntervalEnd_nsprefix_ + ':' if (UseCapturedNS_ and self.lineNumberIntervalEnd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineNumberIntervalEnd>%s</%slineNumberIntervalEnd>%s' % (namespaceprefix_ , self.gds_format_integer(self.lineNumberIntervalEnd, input_name='lineNumberIntervalEnd'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='NewCreatedLinesType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.lineNumberIntervalStart is not None:
            lineNumberIntervalStart_ = self.lineNumberIntervalStart
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}lineNumberIntervalStart').text = self.gds_format_integer(lineNumberIntervalStart_)
        if self.lineNumberIntervalEnd is not None:
            lineNumberIntervalEnd_ = self.lineNumberIntervalEnd
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}lineNumberIntervalEnd').text = self.gds_format_integer(lineNumberIntervalEnd_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='NewCreatedLinesType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.lineNumberIntervalStart is not None:
            showIndent(outfile, level)
            outfile.write('lineNumberIntervalStart=%d,\n' % self.lineNumberIntervalStart)
        if self.lineNumberIntervalEnd is not None:
            showIndent(outfile, level)
            outfile.write('lineNumberIntervalEnd=%d,\n' % self.lineNumberIntervalEnd)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lineNumberIntervalStart' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lineNumberIntervalStart')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'lineNumberIntervalStart')
            self.lineNumberIntervalStart = ival_
            self.lineNumberIntervalStart_nsprefix_ = child_.prefix
            # validate type LineNumberType
            self.validate_LineNumberType(self.lineNumberIntervalStart)
        elif nodeName_ == 'lineNumberIntervalEnd' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lineNumberIntervalEnd')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'lineNumberIntervalEnd')
            self.lineNumberIntervalEnd = ival_
            self.lineNumberIntervalEnd_nsprefix_ = child_.prefix
            # validate type LineNumberType
            self.validate_LineNumberType(self.lineNumberIntervalEnd)
# end class NewCreatedLinesType


class PointerType(GeneratedsSuper):
    """PointerType -- Feldolgoz
    á
    si kurzor adatok
    Processing cursor data
    tag -- Tag hivatkoz
    á
    s
    Tag reference
    value -- É
    rt
    é
    k hivatkoz
    á
    s
    Value reference
    line -- Sorhivatkoz
    á
    s
    Line reference
    originalInvoiceNumber -- K
    ö
    tegelt sz
    á
    mla m
    ű
    velet eset
    é
    n az eredeti sz
    á
    mla sorsz
    á
    ma, melyre a m
    ó
    dos
    í
    t
    á
    s vonatkozik
    In case of a batch operation, the sequence number of the original invoice, on which the modification occurs

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tag=None, value=None, line=None, originalInvoiceNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tag = tag
        self.validate_SimpleText1024NotBlankType(self.tag)
        self.tag_nsprefix_ = "common"
        self.value = value
        self.validate_SimpleText1024NotBlankType(self.value)
        self.value_nsprefix_ = "common"
        self.line = line
        self.validate_LineNumberType(self.line)
        self.line_nsprefix_ = "base"
        self.originalInvoiceNumber = originalInvoiceNumber
        self.validate_SimpleText50NotBlankType(self.originalInvoiceNumber)
        self.originalInvoiceNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PointerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PointerType.subclass:
            return PointerType.subclass(*args_, **kwargs_)
        else:
            return PointerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_originalInvoiceNumber(self):
        return self.originalInvoiceNumber
    def set_originalInvoiceNumber(self, originalInvoiceNumber):
        self.originalInvoiceNumber = originalInvoiceNumber
    def validate_SimpleText1024NotBlankType(self, value):
        result = True
        # Validate type SimpleText1024NotBlankType, a restriction on AtomicStringType1024.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText1024NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText1024NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText1024NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText1024NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText1024NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_LineNumberType(self, value):
        result = True
        # Validate type LineNumberType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.tag is not None or
            self.value is not None or
            self.line is not None or
            self.originalInvoiceNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='PointerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PointerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PointerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PointerType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PointerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PointerType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='PointerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tag is not None:
            namespaceprefix_ = self.tag_nsprefix_ + ':' if (UseCapturedNS_ and self.tag_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stag>%s</%stag>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tag), input_name='tag')), namespaceprefix_ , eol_))
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
        if self.line is not None:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sline>%s</%sline>%s' % (namespaceprefix_ , self.gds_format_integer(self.line, input_name='line'), namespaceprefix_ , eol_))
        if self.originalInvoiceNumber is not None:
            namespaceprefix_ = self.originalInvoiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.originalInvoiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalInvoiceNumber>%s</%soriginalInvoiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originalInvoiceNumber), input_name='originalInvoiceNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='PointerType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.tag is not None:
            tag_ = self.tag
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}tag').text = self.gds_format_string(tag_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}value').text = self.gds_format_string(value_)
        if self.line is not None:
            line_ = self.line
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}line').text = self.gds_format_integer(line_)
        if self.originalInvoiceNumber is not None:
            originalInvoiceNumber_ = self.originalInvoiceNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}originalInvoiceNumber').text = self.gds_format_string(originalInvoiceNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='PointerType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.tag is not None:
            showIndent(outfile, level)
            outfile.write('tag=%s,\n' % self.gds_encode(quote_python(self.tag)))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % self.gds_encode(quote_python(self.value)))
        if self.line is not None:
            showIndent(outfile, level)
            outfile.write('line=%d,\n' % self.line)
        if self.originalInvoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('originalInvoiceNumber=%s,\n' % self.gds_encode(quote_python(self.originalInvoiceNumber)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tag':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tag')
            value_ = self.gds_validate_string(value_, node, 'tag')
            self.tag = value_
            self.tag_nsprefix_ = child_.prefix
            # validate type SimpleText1024NotBlankType
            self.validate_SimpleText1024NotBlankType(self.tag)
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'value')
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
            self.value_nsprefix_ = child_.prefix
            # validate type SimpleText1024NotBlankType
            self.validate_SimpleText1024NotBlankType(self.value)
        elif nodeName_ == 'line' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'line')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'line')
            self.line = ival_
            self.line_nsprefix_ = child_.prefix
            # validate type LineNumberType
            self.validate_LineNumberType(self.line)
        elif nodeName_ == 'originalInvoiceNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originalInvoiceNumber')
            value_ = self.gds_validate_string(value_, node, 'originalInvoiceNumber')
            self.originalInvoiceNumber = value_
            self.originalInvoiceNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.originalInvoiceNumber)
# end class PointerType


class ProcessingResultListType(GeneratedsSuper):
    """ProcessingResultListType -- A k
    é
    r
    é
    shez tartoz
    ó
    feldolgoz
    á
    si eredm
    é
    nyek
    Processing results of the request
    processingResult -- Sz
    á
    mla feldolgoz
    á
    si eredm
    é
    ny
    Invoice processing result
    originalRequestVersion -- Az adatszolg
    á
    ltat
    á
    s requestVersion
    é
    rt
    é
    ke
    requestVersion value of the invoice exchange
    annulmentData -- Technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    s st
    á
    tusz adatai
    Status data of technical annulment

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, processingResult=None, originalRequestVersion=None, annulmentData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if processingResult is None:
            self.processingResult = []
        else:
            self.processingResult = processingResult
        self.processingResult_nsprefix_ = None
        self.originalRequestVersion = originalRequestVersion
        self.validate_OriginalRequestVersionType(self.originalRequestVersion)
        self.originalRequestVersion_nsprefix_ = None
        self.annulmentData = annulmentData
        self.annulmentData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessingResultListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessingResultListType.subclass:
            return ProcessingResultListType.subclass(*args_, **kwargs_)
        else:
            return ProcessingResultListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_processingResult(self):
        return self.processingResult
    def set_processingResult(self, processingResult):
        self.processingResult = processingResult
    def add_processingResult(self, value):
        self.processingResult.append(value)
    def insert_processingResult_at(self, index, value):
        self.processingResult.insert(index, value)
    def replace_processingResult_at(self, index, value):
        self.processingResult[index] = value
    def get_originalRequestVersion(self):
        return self.originalRequestVersion
    def set_originalRequestVersion(self, originalRequestVersion):
        self.originalRequestVersion = originalRequestVersion
    def get_annulmentData(self):
        return self.annulmentData
    def set_annulmentData(self, annulmentData):
        self.annulmentData = annulmentData
    def validate_OriginalRequestVersionType(self, value):
        result = True
        # Validate type OriginalRequestVersionType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['1.0', '1.1', '2.0', '3.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OriginalRequestVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OriginalRequestVersionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on OriginalRequestVersionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.processingResult or
            self.originalRequestVersion is not None or
            self.annulmentData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ProcessingResultListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProcessingResultListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProcessingResultListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProcessingResultListType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProcessingResultListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProcessingResultListType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ProcessingResultListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for processingResult_ in self.processingResult:
            namespaceprefix_ = self.processingResult_nsprefix_ + ':' if (UseCapturedNS_ and self.processingResult_nsprefix_) else ''
            processingResult_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='processingResult', pretty_print=pretty_print)
        if self.originalRequestVersion is not None:
            namespaceprefix_ = self.originalRequestVersion_nsprefix_ + ':' if (UseCapturedNS_ and self.originalRequestVersion_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalRequestVersion>%s</%soriginalRequestVersion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originalRequestVersion), input_name='originalRequestVersion')), namespaceprefix_ , eol_))
        if self.annulmentData is not None:
            namespaceprefix_ = self.annulmentData_nsprefix_ + ':' if (UseCapturedNS_ and self.annulmentData_nsprefix_) else ''
            self.annulmentData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='annulmentData', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ProcessingResultListType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        for processingResult_ in self.processingResult:
            processingResult_.to_etree(element, name_='processingResult', mapping_=mapping_, nsmap_=nsmap_)
        if self.originalRequestVersion is not None:
            originalRequestVersion_ = self.originalRequestVersion
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}originalRequestVersion').text = self.gds_format_string(originalRequestVersion_)
        if self.annulmentData is not None:
            annulmentData_ = self.annulmentData
            annulmentData_.to_etree(element, name_='annulmentData', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ProcessingResultListType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('processingResult=[\n')
        level += 1
        for processingResult_ in self.processingResult:
            showIndent(outfile, level)
            outfile.write('model_.ProcessingResultType(\n')
            processingResult_.exportLiteral(outfile, level, name_='ProcessingResultType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.originalRequestVersion is not None:
            showIndent(outfile, level)
            outfile.write('originalRequestVersion=%s,\n' % self.gds_encode(quote_python(self.originalRequestVersion)))
        if self.annulmentData is not None:
            showIndent(outfile, level)
            outfile.write('annulmentData=model_.AnnulmentDataType(\n')
            self.annulmentData.exportLiteral(outfile, level, name_='annulmentData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'processingResult':
            obj_ = ProcessingResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.processingResult.append(obj_)
            obj_.original_tagname_ = 'processingResult'
        elif nodeName_ == 'originalRequestVersion':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originalRequestVersion')
            value_ = self.gds_validate_string(value_, node, 'originalRequestVersion')
            self.originalRequestVersion = value_
            self.originalRequestVersion_nsprefix_ = child_.prefix
            # validate type OriginalRequestVersionType
            self.validate_OriginalRequestVersionType(self.originalRequestVersion)
        elif nodeName_ == 'annulmentData':
            obj_ = AnnulmentDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.annulmentData = obj_
            obj_.original_tagname_ = 'annulmentData'
# end class ProcessingResultListType


class ProcessingResultType(GeneratedsSuper):
    """ProcessingResultType -- Sz
    á
    mla feldolgoz
    á
    si eredm
    é
    ny
    Invoice processing result
    index -- A sz
    á
    mla sorsz
    á
    ma a k
    é
    r
    é
    sen bel
    ü
    l
    Sequence number of the invoice within the request
    batchIndex -- A m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma a k
    ö
    tegen bel
    ü
    l
    Sequence number of the modification document within the batch
    invoiceStatus -- A sz
    á
    mla feldolgoz
    á
    si st
    á
    tusza
    Processing status of the invoice
    technicalValidationMessages -- Technikai valid
    á
    ci
    ó
    s
    ü
    zenetek
    Technical validation messages
    businessValidationMessages -- Ü
    zleti valid
    á
    ci
    ó
    s
    ü
    zenetek
    Business validation messages
    compressedContentIndicator -- Jel
    ö
    li, ha az originalRequest tartalm
    á
    t a BASE64 dek
    ó
    dol
    á
    st k
    ö
    vet
    ő
    en m
    é
    g ki kell t
    ö
    m
    ö
    r
    í
    teni az olvas
    á
    shoz
    Indicates if the content of the originalRequest needs to be decompressed to be read following the BASE64 decoding
    originalRequest -- Sz
    á
    mla adatok BASE64-ben k
    ó
    dolt tartalma
    Invoice data in BASE64 encoded form

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, index=None, batchIndex=None, invoiceStatus=None, technicalValidationMessages=None, businessValidationMessages=None, compressedContentIndicator=None, originalRequest=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.index = index
        self.validate_InvoiceIndexType(self.index)
        self.index_nsprefix_ = "base"
        self.batchIndex = batchIndex
        self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        self.batchIndex_nsprefix_ = "base"
        self.invoiceStatus = invoiceStatus
        self.validate_InvoiceStatusType(self.invoiceStatus)
        self.invoiceStatus_nsprefix_ = None
        if technicalValidationMessages is None:
            self.technicalValidationMessages = []
        else:
            self.technicalValidationMessages = technicalValidationMessages
        self.technicalValidationMessages_nsprefix_ = "common"
        if businessValidationMessages is None:
            self.businessValidationMessages = []
        else:
            self.businessValidationMessages = businessValidationMessages
        self.businessValidationMessages_nsprefix_ = None
        self.compressedContentIndicator = compressedContentIndicator
        self.compressedContentIndicator_nsprefix_ = "xs"
        self.originalRequest = originalRequest
        self.originalRequest_nsprefix_ = "xs"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessingResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessingResultType.subclass:
            return ProcessingResultType.subclass(*args_, **kwargs_)
        else:
            return ProcessingResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_batchIndex(self):
        return self.batchIndex
    def set_batchIndex(self, batchIndex):
        self.batchIndex = batchIndex
    def get_invoiceStatus(self):
        return self.invoiceStatus
    def set_invoiceStatus(self, invoiceStatus):
        self.invoiceStatus = invoiceStatus
    def get_technicalValidationMessages(self):
        return self.technicalValidationMessages
    def set_technicalValidationMessages(self, technicalValidationMessages):
        self.technicalValidationMessages = technicalValidationMessages
    def add_technicalValidationMessages(self, value):
        self.technicalValidationMessages.append(value)
    def insert_technicalValidationMessages_at(self, index, value):
        self.technicalValidationMessages.insert(index, value)
    def replace_technicalValidationMessages_at(self, index, value):
        self.technicalValidationMessages[index] = value
    def get_businessValidationMessages(self):
        return self.businessValidationMessages
    def set_businessValidationMessages(self, businessValidationMessages):
        self.businessValidationMessages = businessValidationMessages
    def add_businessValidationMessages(self, value):
        self.businessValidationMessages.append(value)
    def insert_businessValidationMessages_at(self, index, value):
        self.businessValidationMessages.insert(index, value)
    def replace_businessValidationMessages_at(self, index, value):
        self.businessValidationMessages[index] = value
    def get_compressedContentIndicator(self):
        return self.compressedContentIndicator
    def set_compressedContentIndicator(self, compressedContentIndicator):
        self.compressedContentIndicator = compressedContentIndicator
    def get_originalRequest(self):
        return self.originalRequest
    def set_originalRequest(self, originalRequest):
        self.originalRequest = originalRequest
    def validate_InvoiceIndexType(self, value):
        result = True
        # Validate type InvoiceIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceUnboundedIndexType(self, value):
        result = True
        # Validate type InvoiceUnboundedIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceUnboundedIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceStatusType(self, value):
        result = True
        # Validate type InvoiceStatusType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['RECEIVED', 'PROCESSING', 'SAVED', 'DONE', 'ABORTED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvoiceStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on InvoiceStatusType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on InvoiceStatusType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.index is not None or
            self.batchIndex is not None or
            self.invoiceStatus is not None or
            self.technicalValidationMessages or
            self.businessValidationMessages or
            self.compressedContentIndicator is not None or
            self.originalRequest is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='ProcessingResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProcessingResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProcessingResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProcessingResultType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProcessingResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProcessingResultType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='ProcessingResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.index is not None:
            namespaceprefix_ = self.index_nsprefix_ + ':' if (UseCapturedNS_ and self.index_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindex>%s</%sindex>%s' % (namespaceprefix_ , self.gds_format_integer(self.index, input_name='index'), namespaceprefix_ , eol_))
        if self.batchIndex is not None:
            namespaceprefix_ = self.batchIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.batchIndex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbatchIndex>%s</%sbatchIndex>%s' % (namespaceprefix_ , self.gds_format_integer(self.batchIndex, input_name='batchIndex'), namespaceprefix_ , eol_))
        if self.invoiceStatus is not None:
            namespaceprefix_ = self.invoiceStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceStatus>%s</%sinvoiceStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceStatus), input_name='invoiceStatus')), namespaceprefix_ , eol_))
        for technicalValidationMessages_ in self.technicalValidationMessages:
            namespaceprefix_ = self.technicalValidationMessages_nsprefix_ + ':' if (UseCapturedNS_ and self.technicalValidationMessages_nsprefix_) else ''
            technicalValidationMessages_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='technicalValidationMessages', pretty_print=pretty_print)
        for businessValidationMessages_ in self.businessValidationMessages:
            namespaceprefix_ = self.businessValidationMessages_nsprefix_ + ':' if (UseCapturedNS_ and self.businessValidationMessages_nsprefix_) else ''
            businessValidationMessages_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='businessValidationMessages', pretty_print=pretty_print)
        if self.compressedContentIndicator is not None:
            namespaceprefix_ = self.compressedContentIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.compressedContentIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompressedContentIndicator>%s</%scompressedContentIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.compressedContentIndicator, input_name='compressedContentIndicator'), namespaceprefix_ , eol_))
        if self.originalRequest is not None:
            namespaceprefix_ = self.originalRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.originalRequest_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalRequest>%s</%soriginalRequest>%s' % (namespaceprefix_ , self.gds_format_base64(self.originalRequest, input_name='originalRequest'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='ProcessingResultType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.index is not None:
            index_ = self.index
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}index').text = self.gds_format_integer(index_)
        if self.batchIndex is not None:
            batchIndex_ = self.batchIndex
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}batchIndex').text = self.gds_format_integer(batchIndex_)
        if self.invoiceStatus is not None:
            invoiceStatus_ = self.invoiceStatus
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceStatus').text = self.gds_format_string(invoiceStatus_)
        for technicalValidationMessages_ in self.technicalValidationMessages:
            technicalValidationMessages_.to_etree(element, name_='technicalValidationMessages', mapping_=mapping_, nsmap_=nsmap_)
        for businessValidationMessages_ in self.businessValidationMessages:
            businessValidationMessages_.to_etree(element, name_='businessValidationMessages', mapping_=mapping_, nsmap_=nsmap_)
        if self.compressedContentIndicator is not None:
            compressedContentIndicator_ = self.compressedContentIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}compressedContentIndicator').text = self.gds_format_boolean(compressedContentIndicator_)
        if self.originalRequest is not None:
            originalRequest_ = self.originalRequest
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}originalRequest').text = self.gds_format_base64(originalRequest_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ProcessingResultType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.index is not None:
            showIndent(outfile, level)
            outfile.write('index=%d,\n' % self.index)
        if self.batchIndex is not None:
            showIndent(outfile, level)
            outfile.write('batchIndex=%d,\n' % self.batchIndex)
        if self.invoiceStatus is not None:
            showIndent(outfile, level)
            outfile.write('invoiceStatus=%s,\n' % self.gds_encode(quote_python(self.invoiceStatus)))
        showIndent(outfile, level)
        outfile.write('technicalValidationMessages=[\n')
        level += 1
        for technicalValidationMessages_ in self.technicalValidationMessages:
            showIndent(outfile, level)
            outfile.write('model_.TechnicalValidationResultType(\n')
            technicalValidationMessages_.exportLiteral(outfile, level, name_='TechnicalValidationResultType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('businessValidationMessages=[\n')
        level += 1
        for businessValidationMessages_ in self.businessValidationMessages:
            showIndent(outfile, level)
            outfile.write('model_.BusinessValidationResultType(\n')
            businessValidationMessages_.exportLiteral(outfile, level, name_='BusinessValidationResultType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.compressedContentIndicator is not None:
            showIndent(outfile, level)
            outfile.write('compressedContentIndicator=%s,\n' % self.compressedContentIndicator)
        if self.originalRequest is not None:
            showIndent(outfile, level)
            outfile.write('originalRequest=model_.base64Binary(\n')
            self.originalRequest.exportLiteral(outfile, level, name_='originalRequest')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'index' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'index')
            ival_ = self.gds_validate_integer(ival_, node, 'index')
            self.index = ival_
            self.index_nsprefix_ = child_.prefix
            # validate type InvoiceIndexType
            self.validate_InvoiceIndexType(self.index)
        elif nodeName_ == 'batchIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'batchIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'batchIndex')
            self.batchIndex = ival_
            self.batchIndex_nsprefix_ = child_.prefix
            # validate type InvoiceUnboundedIndexType
            self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        elif nodeName_ == 'invoiceStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceStatus')
            value_ = self.gds_validate_string(value_, node, 'invoiceStatus')
            self.invoiceStatus = value_
            self.invoiceStatus_nsprefix_ = child_.prefix
            # validate type InvoiceStatusType
            self.validate_InvoiceStatusType(self.invoiceStatus)
        elif nodeName_ == 'technicalValidationMessages':
            obj_ = TechnicalValidationResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.technicalValidationMessages.append(obj_)
            obj_.original_tagname_ = 'technicalValidationMessages'
        elif nodeName_ == 'businessValidationMessages':
            obj_ = BusinessValidationResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.businessValidationMessages.append(obj_)
            obj_.original_tagname_ = 'businessValidationMessages'
        elif nodeName_ == 'compressedContentIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'compressedContentIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'compressedContentIndicator')
            self.compressedContentIndicator = ival_
            self.compressedContentIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'originalRequest':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'originalRequest')
            else:
                bval_ = None
            self.originalRequest = bval_
            self.originalRequest_nsprefix_ = child_.prefix
# end class ProcessingResultType


class QueryInvoiceChainDigestRequestType(BasicOnlineInvoiceRequestType):
    """QueryInvoiceChainDigestRequestType -- A POST /queryInvoiceChainDigest REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s t
    í
    pusa
    Request type of the POST /queryInvoiceChainDigest REST operation
    page -- A lek
    é
    rdezni k
    í
    v
    á
    nt lap sz
    á
    ma
    The queried page count
    invoiceChainQuery -- Sz
    á
    mlal
    á
    nc kivonat lek
    é
    rdez
    é
    s sz
    á
    mlasz
    á
    m param
    é
    tere
    Invoice number param of the invoice chain digest query

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceRequestType
    def __init__(self, header=None, user=None, software=None, page=None, invoiceChainQuery=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceChainDigestRequestType"), self).__init__(header, user, software, extensiontype_,  **kwargs_)
        self.page = page
        self.validate_RequestPageType(self.page)
        self.page_nsprefix_ = "common"
        self.invoiceChainQuery = invoiceChainQuery
        self.invoiceChainQuery_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceChainDigestRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceChainDigestRequestType.subclass:
            return QueryInvoiceChainDigestRequestType.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceChainDigestRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_page(self):
        return self.page
    def set_page(self, page):
        self.page = page
    def get_invoiceChainQuery(self):
        return self.invoiceChainQuery
    def set_invoiceChainQuery(self, invoiceChainQuery):
        self.invoiceChainQuery = invoiceChainQuery
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_RequestPageType(self, value):
        result = True
        # Validate type RequestPageType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on RequestPageType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.page is not None or
            self.invoiceChainQuery is not None or
            super(QueryInvoiceChainDigestRequestType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceChainDigestRequestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceChainDigestRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceChainDigestRequestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceChainDigestRequestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceChainDigestRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceChainDigestRequestType'):
        super(QueryInvoiceChainDigestRequestType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceChainDigestRequestType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceChainDigestRequestType', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceChainDigestRequestType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.page is not None:
            namespaceprefix_ = self.page_nsprefix_ + ':' if (UseCapturedNS_ and self.page_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spage>%s</%spage>%s' % (namespaceprefix_ , self.gds_format_integer(self.page, input_name='page'), namespaceprefix_ , eol_))
        if self.invoiceChainQuery is not None:
            namespaceprefix_ = self.invoiceChainQuery_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceChainQuery_nsprefix_) else ''
            self.invoiceChainQuery.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceChainQuery', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceChainDigestRequestType', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceChainDigestRequestType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.page is not None:
            page_ = self.page
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}page').text = self.gds_format_integer(page_)
        if self.invoiceChainQuery is not None:
            invoiceChainQuery_ = self.invoiceChainQuery
            invoiceChainQuery_.to_etree(element, name_='invoiceChainQuery', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceChainDigestRequestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceChainDigestRequestType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceChainDigestRequestType, self)._exportLiteralChildren(outfile, level, name_)
        if self.page is not None:
            showIndent(outfile, level)
            outfile.write('page=%d,\n' % self.page)
        if self.invoiceChainQuery is not None:
            showIndent(outfile, level)
            outfile.write('invoiceChainQuery=model_.InvoiceChainQueryType(\n')
            self.invoiceChainQuery.exportLiteral(outfile, level, name_='invoiceChainQuery')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryInvoiceChainDigestRequestType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'page' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'page')
            ival_ = self.gds_validate_integer(ival_, node, 'page')
            self.page = ival_
            self.page_nsprefix_ = child_.prefix
            # validate type RequestPageType
            self.validate_RequestPageType(self.page)
        elif nodeName_ == 'invoiceChainQuery':
            obj_ = InvoiceChainQueryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceChainQuery = obj_
            obj_.original_tagname_ = 'invoiceChainQuery'
        super(QueryInvoiceChainDigestRequestType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryInvoiceChainDigestRequestType


class QueryInvoiceChainDigestResponseType(BasicOnlineInvoiceResponseType):
    """QueryInvoiceChainDigestResponseType -- A POST /queryInvoiceChainDigest REST oper
    á
    ci
    ó
    v
    á
    lasz t
    í
    pusa
    Response type of the POST /queryInvoiceChainDigest REST operation
    invoiceChainDigestResult -- Sz
    á
    mlal
    á
    nc kivonat lek
    é
    rdez
    é
    s eredm
    é
    nyei
    Invoice chain digest query result

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceResponseType
    def __init__(self, header=None, result=None, software=None, invoiceChainDigestResult=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceChainDigestResponseType"), self).__init__(header, result, software, extensiontype_,  **kwargs_)
        self.invoiceChainDigestResult = invoiceChainDigestResult
        self.invoiceChainDigestResult_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceChainDigestResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceChainDigestResponseType.subclass:
            return QueryInvoiceChainDigestResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceChainDigestResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceChainDigestResult(self):
        return self.invoiceChainDigestResult
    def set_invoiceChainDigestResult(self, invoiceChainDigestResult):
        self.invoiceChainDigestResult = invoiceChainDigestResult
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.invoiceChainDigestResult is not None or
            super(QueryInvoiceChainDigestResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceChainDigestResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceChainDigestResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceChainDigestResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceChainDigestResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceChainDigestResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceChainDigestResponseType'):
        super(QueryInvoiceChainDigestResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceChainDigestResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceChainDigestResponseType', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceChainDigestResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceChainDigestResult is not None:
            namespaceprefix_ = self.invoiceChainDigestResult_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceChainDigestResult_nsprefix_) else ''
            self.invoiceChainDigestResult.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceChainDigestResult', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceChainDigestResponseType', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceChainDigestResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.invoiceChainDigestResult is not None:
            invoiceChainDigestResult_ = self.invoiceChainDigestResult
            invoiceChainDigestResult_.to_etree(element, name_='invoiceChainDigestResult', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceChainDigestResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceChainDigestResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceChainDigestResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.invoiceChainDigestResult is not None:
            showIndent(outfile, level)
            outfile.write('invoiceChainDigestResult=model_.InvoiceChainDigestResultType(\n')
            self.invoiceChainDigestResult.exportLiteral(outfile, level, name_='invoiceChainDigestResult')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryInvoiceChainDigestResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceChainDigestResult':
            obj_ = InvoiceChainDigestResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceChainDigestResult = obj_
            obj_.original_tagname_ = 'invoiceChainDigestResult'
        super(QueryInvoiceChainDigestResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryInvoiceChainDigestResponseType


class QueryInvoiceCheckResponseType(BasicOnlineInvoiceResponseType):
    """QueryInvoiceCheckResponseType -- A POST /queryInvoiceCheck REST oper
    á
    ci
    ó
    v
    á
    lasz t
    í
    pusa
    Response type of the POST /queryInvoiceCheck REST operation
    invoiceCheckResult -- Jel
    ö
    li, ha a lek
    é
    rdezett sz
    á
    mlasz
    á
    m
    é
    rv
    é
    nyesk
    é
    nt szerepel a rendszerben
    é
    s a lek
    é
    rdez
    ő
    ad
    ó
    sz
    á
    ma ki
    á
    ll
    í
    t
    ó
    k
    é
    nt vagy elad
    ó
    k
    é
    nt szerepel a sz
    á
    ml
    á
    n
    Indicates whether the queried invoice number exists in the system as a valid invoice, if the tax number of the querying entity is present on the invoice either as supplier or customer

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceResponseType
    def __init__(self, header=None, result=None, software=None, invoiceCheckResult=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceCheckResponseType"), self).__init__(header, result, software, extensiontype_,  **kwargs_)
        self.invoiceCheckResult = invoiceCheckResult
        self.invoiceCheckResult_nsprefix_ = "xs"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceCheckResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceCheckResponseType.subclass:
            return QueryInvoiceCheckResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceCheckResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceCheckResult(self):
        return self.invoiceCheckResult
    def set_invoiceCheckResult(self, invoiceCheckResult):
        self.invoiceCheckResult = invoiceCheckResult
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.invoiceCheckResult is not None or
            super(QueryInvoiceCheckResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='QueryInvoiceCheckResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceCheckResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceCheckResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceCheckResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceCheckResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceCheckResponseType'):
        super(QueryInvoiceCheckResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceCheckResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='QueryInvoiceCheckResponseType', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceCheckResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceCheckResult is not None:
            namespaceprefix_ = self.invoiceCheckResult_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceCheckResult_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceCheckResult>%s</%sinvoiceCheckResult>%s' % (namespaceprefix_ , self.gds_format_boolean(self.invoiceCheckResult, input_name='invoiceCheckResult'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='QueryInvoiceCheckResponseType', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceCheckResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.invoiceCheckResult is not None:
            invoiceCheckResult_ = self.invoiceCheckResult
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceCheckResult').text = self.gds_format_boolean(invoiceCheckResult_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceCheckResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceCheckResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceCheckResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.invoiceCheckResult is not None:
            showIndent(outfile, level)
            outfile.write('invoiceCheckResult=%s,\n' % self.invoiceCheckResult)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryInvoiceCheckResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceCheckResult':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'invoiceCheckResult')
            ival_ = self.gds_validate_boolean(ival_, node, 'invoiceCheckResult')
            self.invoiceCheckResult = ival_
            self.invoiceCheckResult_nsprefix_ = child_.prefix
        super(QueryInvoiceCheckResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryInvoiceCheckResponseType


class QueryInvoiceDataRequestType(BasicOnlineInvoiceRequestType):
    """QueryInvoiceDataRequestType -- A POST /queryInvoiceData REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s t
    í
    pusa
    Request type of the POST /queryInvoiceData REST operation
    invoiceNumberQuery -- Sz
    á
    mla lek
    é
    rdez
    é
    s sz
    á
    mlasz
    á
    m param
    é
    tere
    Invoice number param of the Invoice query

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceRequestType
    def __init__(self, header=None, user=None, software=None, invoiceNumberQuery=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceDataRequestType"), self).__init__(header, user, software, extensiontype_,  **kwargs_)
        self.invoiceNumberQuery = invoiceNumberQuery
        self.invoiceNumberQuery_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceDataRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceDataRequestType.subclass:
            return QueryInvoiceDataRequestType.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceDataRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceNumberQuery(self):
        return self.invoiceNumberQuery
    def set_invoiceNumberQuery(self, invoiceNumberQuery):
        self.invoiceNumberQuery = invoiceNumberQuery
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.invoiceNumberQuery is not None or
            super(QueryInvoiceDataRequestType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceDataRequestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceDataRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceDataRequestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDataRequestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceDataRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceDataRequestType'):
        super(QueryInvoiceDataRequestType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDataRequestType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceDataRequestType', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceDataRequestType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceNumberQuery is not None:
            namespaceprefix_ = self.invoiceNumberQuery_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNumberQuery_nsprefix_) else ''
            self.invoiceNumberQuery.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceNumberQuery', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceDataRequestType', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceDataRequestType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.invoiceNumberQuery is not None:
            invoiceNumberQuery_ = self.invoiceNumberQuery
            invoiceNumberQuery_.to_etree(element, name_='invoiceNumberQuery', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceDataRequestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceDataRequestType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceDataRequestType, self)._exportLiteralChildren(outfile, level, name_)
        if self.invoiceNumberQuery is not None:
            showIndent(outfile, level)
            outfile.write('invoiceNumberQuery=model_.InvoiceNumberQueryType(\n')
            self.invoiceNumberQuery.exportLiteral(outfile, level, name_='invoiceNumberQuery')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryInvoiceDataRequestType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceNumberQuery':
            obj_ = InvoiceNumberQueryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceNumberQuery = obj_
            obj_.original_tagname_ = 'invoiceNumberQuery'
        super(QueryInvoiceDataRequestType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryInvoiceDataRequestType


class QueryInvoiceDataResponseType(BasicOnlineInvoiceResponseType):
    """QueryInvoiceDataResponseType -- A POST /queryInvoiceData REST oper
    á
    ci
    ó
    v
    á
    lasz t
    í
    pusa
    Response type of the POST /queryInvoiceData REST operation
    invoiceDataResult -- A sz
    á
    mla lek
    é
    rdez
    é
    s eredm
    é
    nye
    Invoice data query result

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceResponseType
    def __init__(self, header=None, result=None, software=None, invoiceDataResult=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceDataResponseType"), self).__init__(header, result, software, extensiontype_,  **kwargs_)
        self.invoiceDataResult = invoiceDataResult
        self.invoiceDataResult_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceDataResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceDataResponseType.subclass:
            return QueryInvoiceDataResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceDataResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceDataResult(self):
        return self.invoiceDataResult
    def set_invoiceDataResult(self, invoiceDataResult):
        self.invoiceDataResult = invoiceDataResult
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.invoiceDataResult is not None or
            super(QueryInvoiceDataResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceDataResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceDataResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceDataResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDataResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceDataResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceDataResponseType'):
        super(QueryInvoiceDataResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDataResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceDataResponseType', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceDataResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceDataResult is not None:
            namespaceprefix_ = self.invoiceDataResult_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDataResult_nsprefix_) else ''
            self.invoiceDataResult.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceDataResult', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceDataResponseType', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceDataResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.invoiceDataResult is not None:
            invoiceDataResult_ = self.invoiceDataResult
            invoiceDataResult_.to_etree(element, name_='invoiceDataResult', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceDataResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceDataResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceDataResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.invoiceDataResult is not None:
            showIndent(outfile, level)
            outfile.write('invoiceDataResult=model_.InvoiceDataResultType(\n')
            self.invoiceDataResult.exportLiteral(outfile, level, name_='invoiceDataResult')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryInvoiceDataResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceDataResult':
            obj_ = InvoiceDataResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceDataResult = obj_
            obj_.original_tagname_ = 'invoiceDataResult'
        super(QueryInvoiceDataResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryInvoiceDataResponseType


class QueryInvoiceDigestRequestType(BasicOnlineInvoiceRequestType):
    """QueryInvoiceDigestRequestType -- A POST /queryInvoiceDigest REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s t
    í
    pusa
    Request type of the POST /queryInvoiceDigest REST operation
    page -- A lek
    é
    rdezni k
    í
    v
    á
    nt lap sz
    á
    ma
    The queried page count
    invoiceDirection -- Kimen
    ő
    vagy bej
    ö
    v
    ő
    sz
    á
    mla keres
    é
    si param
    é
    tere
    Inbound or outbound invoice query parameter
    invoiceQueryParams -- Sz
    á
    mla lek
    é
    rdez
    é
    si param
    é
    terek
    Invoice query parameters

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceRequestType
    def __init__(self, header=None, user=None, software=None, page=None, invoiceDirection=None, invoiceQueryParams=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceDigestRequestType"), self).__init__(header, user, software, extensiontype_,  **kwargs_)
        self.page = page
        self.validate_RequestPageType(self.page)
        self.page_nsprefix_ = "common"
        self.invoiceDirection = invoiceDirection
        self.validate_InvoiceDirectionType(self.invoiceDirection)
        self.invoiceDirection_nsprefix_ = None
        self.invoiceQueryParams = invoiceQueryParams
        self.invoiceQueryParams_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceDigestRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceDigestRequestType.subclass:
            return QueryInvoiceDigestRequestType.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceDigestRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_page(self):
        return self.page
    def set_page(self, page):
        self.page = page
    def get_invoiceDirection(self):
        return self.invoiceDirection
    def set_invoiceDirection(self, invoiceDirection):
        self.invoiceDirection = invoiceDirection
    def get_invoiceQueryParams(self):
        return self.invoiceQueryParams
    def set_invoiceQueryParams(self, invoiceQueryParams):
        self.invoiceQueryParams = invoiceQueryParams
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_RequestPageType(self, value):
        result = True
        # Validate type RequestPageType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on RequestPageType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceDirectionType(self, value):
        result = True
        # Validate type InvoiceDirectionType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['INBOUND', 'OUTBOUND']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvoiceDirectionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on InvoiceDirectionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on InvoiceDirectionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.page is not None or
            self.invoiceDirection is not None or
            self.invoiceQueryParams is not None or
            super(QueryInvoiceDigestRequestType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceDigestRequestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceDigestRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceDigestRequestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDigestRequestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceDigestRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceDigestRequestType'):
        super(QueryInvoiceDigestRequestType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDigestRequestType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceDigestRequestType', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceDigestRequestType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.page is not None:
            namespaceprefix_ = self.page_nsprefix_ + ':' if (UseCapturedNS_ and self.page_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spage>%s</%spage>%s' % (namespaceprefix_ , self.gds_format_integer(self.page, input_name='page'), namespaceprefix_ , eol_))
        if self.invoiceDirection is not None:
            namespaceprefix_ = self.invoiceDirection_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDirection_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceDirection>%s</%sinvoiceDirection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceDirection), input_name='invoiceDirection')), namespaceprefix_ , eol_))
        if self.invoiceQueryParams is not None:
            namespaceprefix_ = self.invoiceQueryParams_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceQueryParams_nsprefix_) else ''
            self.invoiceQueryParams.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceQueryParams', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceDigestRequestType', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceDigestRequestType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.page is not None:
            page_ = self.page
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}page').text = self.gds_format_integer(page_)
        if self.invoiceDirection is not None:
            invoiceDirection_ = self.invoiceDirection
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceDirection').text = self.gds_format_string(invoiceDirection_)
        if self.invoiceQueryParams is not None:
            invoiceQueryParams_ = self.invoiceQueryParams
            invoiceQueryParams_.to_etree(element, name_='invoiceQueryParams', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceDigestRequestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceDigestRequestType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceDigestRequestType, self)._exportLiteralChildren(outfile, level, name_)
        if self.page is not None:
            showIndent(outfile, level)
            outfile.write('page=%d,\n' % self.page)
        if self.invoiceDirection is not None:
            showIndent(outfile, level)
            outfile.write('invoiceDirection=%s,\n' % self.gds_encode(quote_python(self.invoiceDirection)))
        if self.invoiceQueryParams is not None:
            showIndent(outfile, level)
            outfile.write('invoiceQueryParams=model_.InvoiceQueryParamsType(\n')
            self.invoiceQueryParams.exportLiteral(outfile, level, name_='invoiceQueryParams')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryInvoiceDigestRequestType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'page' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'page')
            ival_ = self.gds_validate_integer(ival_, node, 'page')
            self.page = ival_
            self.page_nsprefix_ = child_.prefix
            # validate type RequestPageType
            self.validate_RequestPageType(self.page)
        elif nodeName_ == 'invoiceDirection':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceDirection')
            value_ = self.gds_validate_string(value_, node, 'invoiceDirection')
            self.invoiceDirection = value_
            self.invoiceDirection_nsprefix_ = child_.prefix
            # validate type InvoiceDirectionType
            self.validate_InvoiceDirectionType(self.invoiceDirection)
        elif nodeName_ == 'invoiceQueryParams':
            obj_ = InvoiceQueryParamsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceQueryParams = obj_
            obj_.original_tagname_ = 'invoiceQueryParams'
        super(QueryInvoiceDigestRequestType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryInvoiceDigestRequestType


class QueryInvoiceDigestResponseType(BasicOnlineInvoiceResponseType):
    """QueryInvoiceDigestResponseType -- A POST /queryInvoiceDigest REST oper
    á
    ci
    ó
    v
    á
    lasz t
    í
    pusa
    Response type of the POST /queryInvoiceDigest REST operation
    invoiceDigestResult -- A sz
    á
    mla kivonat lek
    é
    rdez
    é
    s eredm
    é
    nyei
    Invoice digest query results

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceResponseType
    def __init__(self, header=None, result=None, software=None, invoiceDigestResult=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceDigestResponseType"), self).__init__(header, result, software, extensiontype_,  **kwargs_)
        self.invoiceDigestResult = invoiceDigestResult
        self.invoiceDigestResult_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceDigestResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceDigestResponseType.subclass:
            return QueryInvoiceDigestResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceDigestResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceDigestResult(self):
        return self.invoiceDigestResult
    def set_invoiceDigestResult(self, invoiceDigestResult):
        self.invoiceDigestResult = invoiceDigestResult
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.invoiceDigestResult is not None or
            super(QueryInvoiceDigestResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceDigestResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceDigestResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceDigestResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDigestResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceDigestResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceDigestResponseType'):
        super(QueryInvoiceDigestResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDigestResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryInvoiceDigestResponseType', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceDigestResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceDigestResult is not None:
            namespaceprefix_ = self.invoiceDigestResult_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDigestResult_nsprefix_) else ''
            self.invoiceDigestResult.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceDigestResult', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceDigestResponseType', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceDigestResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.invoiceDigestResult is not None:
            invoiceDigestResult_ = self.invoiceDigestResult
            invoiceDigestResult_.to_etree(element, name_='invoiceDigestResult', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceDigestResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceDigestResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceDigestResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.invoiceDigestResult is not None:
            showIndent(outfile, level)
            outfile.write('invoiceDigestResult=model_.InvoiceDigestResultType(\n')
            self.invoiceDigestResult.exportLiteral(outfile, level, name_='invoiceDigestResult')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryInvoiceDigestResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceDigestResult':
            obj_ = InvoiceDigestResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceDigestResult = obj_
            obj_.original_tagname_ = 'invoiceDigestResult'
        super(QueryInvoiceDigestResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryInvoiceDigestResponseType


class QueryTaxpayerRequestType(BasicOnlineInvoiceRequestType):
    """QueryTaxpayerRequestType -- A POST /queryTaxpayer REST operációkérés típusa
        Request type of the POST /queryTaxpayer REST operation
    taxNumber -- A lekérdezett adózó adószáma
    Tax number of the queried taxpayer

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceRequestType
    def __init__(self, header=None, user=None, software=None, taxNumber=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTaxpayerRequestType"), self).__init__(header, user, software, extensiontype_,  **kwargs_)
        self.taxNumber = taxNumber
        self.validate_TaxpayerIdType(self.taxNumber)
        self.taxNumber_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTaxpayerRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTaxpayerRequestType.subclass:
            return QueryTaxpayerRequestType.subclass(*args_, **kwargs_)
        else:
            return QueryTaxpayerRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_taxNumber(self):
        return self.taxNumber
    def set_taxNumber(self, taxNumber):
        self.taxNumber = taxNumber
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_TaxpayerIdType(self, value):
        result = True
        # Validate type TaxpayerIdType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxpayerIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TaxpayerIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TaxpayerIdType_patterns_, ))
                result = False
        return result
    validate_TaxpayerIdType_patterns_ = [['^([0-9]{8})$']]
    def _hasContent(self):
        if (
            self.taxNumber is not None or
            super(QueryTaxpayerRequestType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns="http://schemas.nav.gov.hu/OSA/3.0/api" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='QueryTaxpayerRequestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTaxpayerRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTaxpayerRequestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTaxpayerRequestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTaxpayerRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTaxpayerRequestType'):
        super(QueryTaxpayerRequestType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTaxpayerRequestType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns="http://schemas.nav.gov.hu/OSA/3.0/api" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='QueryTaxpayerRequestType', fromsubclass_=False, pretty_print=True):
        super(QueryTaxpayerRequestType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.taxNumber is not None:
            namespaceprefix_ = self.taxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.taxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxNumber>%s</%staxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxNumber), input_name='taxNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='QueryTaxpayerRequestType', mapping_=None, nsmap_=None):
        element = super(QueryTaxpayerRequestType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.taxNumber is not None:
            taxNumber_ = self.taxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}taxNumber').text = self.gds_format_string(taxNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTaxpayerRequestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTaxpayerRequestType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTaxpayerRequestType, self)._exportLiteralChildren(outfile, level, name_)
        if self.taxNumber is not None:
            showIndent(outfile, level)
            outfile.write('taxNumber=%s,\n' % self.gds_encode(quote_python(self.taxNumber)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryTaxpayerRequestType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'taxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxNumber')
            value_ = self.gds_validate_string(value_, node, 'taxNumber')
            self.taxNumber = value_
            self.taxNumber_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.taxNumber)
        super(QueryTaxpayerRequestType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryTaxpayerRequestType


class QueryTaxpayerResponseType(BasicOnlineInvoiceResponseType):
    """QueryTaxpayerResponseType -- A POST /queryTaxpayer REST operációválasz típusa
    Response type of the POST /queryTaxpayer REST operation
    infoDate -- Az adatok utolsó változásának időpontja
    Last date on which the data was changed
    taxpayerValidity -- Jelzi, hogy a lekérdezett adózó létezik és érvényes-e
    Indicates whether the queried taxpayer is existing and valid
    taxpayerData -- Az adózó lekérdezés válasz adatai
    Response data of the taxpayer query

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceResponseType
    def __init__(self, header=None, result=None, software=None, infoDate=None, taxpayerValidity=None, taxpayerData=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTaxpayerResponseType"), self).__init__(header, result, software, extensiontype_,  **kwargs_)
        if isinstance(infoDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(infoDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = infoDate
        self.infoDate = initvalue_
        self.infoDate_nsprefix_ = "xs"
        self.taxpayerValidity = taxpayerValidity
        self.taxpayerValidity_nsprefix_ = "xs"
        self.taxpayerData = taxpayerData
        self.taxpayerData_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTaxpayerResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTaxpayerResponseType.subclass:
            return QueryTaxpayerResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryTaxpayerResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infoDate(self):
        return self.infoDate
    def set_infoDate(self, infoDate):
        self.infoDate = infoDate
    def get_taxpayerValidity(self):
        return self.taxpayerValidity
    def set_taxpayerValidity(self, taxpayerValidity):
        self.taxpayerValidity = taxpayerValidity
    def get_taxpayerData(self):
        return self.taxpayerData
    def set_taxpayerData(self, taxpayerData):
        self.taxpayerData = taxpayerData
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.infoDate is not None or
            self.taxpayerValidity is not None or
            self.taxpayerData is not None or
            super(QueryTaxpayerResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryTaxpayerResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTaxpayerResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTaxpayerResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTaxpayerResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTaxpayerResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTaxpayerResponseType'):
        super(QueryTaxpayerResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTaxpayerResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryTaxpayerResponseType', fromsubclass_=False, pretty_print=True):
        super(QueryTaxpayerResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infoDate is not None:
            namespaceprefix_ = self.infoDate_nsprefix_ + ':' if (UseCapturedNS_ and self.infoDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinfoDate>%s</%sinfoDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.infoDate, input_name='infoDate'), namespaceprefix_ , eol_))
        if self.taxpayerValidity is not None:
            namespaceprefix_ = self.taxpayerValidity_nsprefix_ + ':' if (UseCapturedNS_ and self.taxpayerValidity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxpayerValidity>%s</%staxpayerValidity>%s' % (namespaceprefix_ , self.gds_format_boolean(self.taxpayerValidity, input_name='taxpayerValidity'), namespaceprefix_ , eol_))
        if self.taxpayerData is not None:
            namespaceprefix_ = self.taxpayerData_nsprefix_ + ':' if (UseCapturedNS_ and self.taxpayerData_nsprefix_) else ''
            self.taxpayerData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taxpayerData', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryTaxpayerResponseType', mapping_=None, nsmap_=None):
        element = super(QueryTaxpayerResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.infoDate is not None:
            infoDate_ = self.infoDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}infoDate').text = self.gds_format_datetime(infoDate_)
        if self.taxpayerValidity is not None:
            taxpayerValidity_ = self.taxpayerValidity
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}taxpayerValidity').text = self.gds_format_boolean(taxpayerValidity_)
        if self.taxpayerData is not None:
            taxpayerData_ = self.taxpayerData
            taxpayerData_.to_etree(element, name_='taxpayerData', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTaxpayerResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTaxpayerResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTaxpayerResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.infoDate is not None:
            showIndent(outfile, level)
            outfile.write('infoDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.infoDate, input_name='infoDate'))
        if self.taxpayerValidity is not None:
            showIndent(outfile, level)
            outfile.write('taxpayerValidity=%s,\n' % self.taxpayerValidity)
        if self.taxpayerData is not None:
            showIndent(outfile, level)
            outfile.write('taxpayerData=model_.TaxpayerDataType(\n')
            self.taxpayerData.exportLiteral(outfile, level, name_='taxpayerData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryTaxpayerResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infoDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.infoDate = dval_
            self.infoDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'taxpayerValidity':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'taxpayerValidity')
            ival_ = self.gds_validate_boolean(ival_, node, 'taxpayerValidity')
            self.taxpayerValidity = ival_
            self.taxpayerValidity_nsprefix_ = child_.prefix
        elif nodeName_ == 'taxpayerData':
            obj_ = TaxpayerDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taxpayerData = obj_
            obj_.original_tagname_ = 'taxpayerData'
        super(QueryTaxpayerResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryTaxpayerResponseType


class QueryTransactionListRequestType(BasicOnlineInvoiceRequestType):
    """QueryTransactionListRequestType -- A POST /queryTransactionList REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s t
    í
    pusa
    Request type of the POST /queryTransactionList REST operation
    page -- A lek
    é
    rdezni k
    í
    v
    á
    nt lap sz
    á
    ma
    The queried page count
    insDate -- A lek
    é
    rdezni k
    í
    v
    á
    nt tranzakci
    ó
    k kiad
    á
    s
    á
    nak szerver oldali ideje UTC id
    ő
    ben
    The queried transaction's insert date on server side in UTC time
    requestStatus -- A k
    é
    r
    é
    s feldolgoz
    á
    si st
    á
    tusza
    Processing status of the request

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceRequestType
    def __init__(self, header=None, user=None, software=None, page=None, insDate=None, requestStatus=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTransactionListRequestType"), self).__init__(header, user, software, extensiontype_,  **kwargs_)
        self.page = page
        self.validate_RequestPageType(self.page)
        self.page_nsprefix_ = "common"
        self.insDate = insDate
        self.insDate_nsprefix_ = None
        self.requestStatus = requestStatus
        self.validate_RequestStatusType(self.requestStatus)
        self.requestStatus_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTransactionListRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTransactionListRequestType.subclass:
            return QueryTransactionListRequestType.subclass(*args_, **kwargs_)
        else:
            return QueryTransactionListRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_page(self):
        return self.page
    def set_page(self, page):
        self.page = page
    def get_insDate(self):
        return self.insDate
    def set_insDate(self, insDate):
        self.insDate = insDate
    def get_requestStatus(self):
        return self.requestStatus
    def set_requestStatus(self, requestStatus):
        self.requestStatus = requestStatus
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_RequestPageType(self, value):
        result = True
        # Validate type RequestPageType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on RequestPageType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_RequestStatusType(self, value):
        result = True
        # Validate type RequestStatusType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['RECEIVED', 'PROCESSING', 'SAVED', 'FINISHED', 'NOTIFIED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RequestStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on RequestStatusType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on RequestStatusType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.page is not None or
            self.insDate is not None or
            self.requestStatus is not None or
            super(QueryTransactionListRequestType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryTransactionListRequestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTransactionListRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTransactionListRequestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionListRequestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTransactionListRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTransactionListRequestType'):
        super(QueryTransactionListRequestType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionListRequestType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryTransactionListRequestType', fromsubclass_=False, pretty_print=True):
        super(QueryTransactionListRequestType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.page is not None:
            namespaceprefix_ = self.page_nsprefix_ + ':' if (UseCapturedNS_ and self.page_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spage>%s</%spage>%s' % (namespaceprefix_ , self.gds_format_integer(self.page, input_name='page'), namespaceprefix_ , eol_))
        if self.insDate is not None:
            namespaceprefix_ = self.insDate_nsprefix_ + ':' if (UseCapturedNS_ and self.insDate_nsprefix_) else ''
            self.insDate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='insDate', pretty_print=pretty_print)
        if self.requestStatus is not None:
            namespaceprefix_ = self.requestStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.requestStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequestStatus>%s</%srequestStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.requestStatus), input_name='requestStatus')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='QueryTransactionListRequestType', mapping_=None, nsmap_=None):
        element = super(QueryTransactionListRequestType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.page is not None:
            page_ = self.page
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}page').text = self.gds_format_integer(page_)
        if self.insDate is not None:
            insDate_ = self.insDate
            insDate_.to_etree(element, name_='insDate', mapping_=mapping_, nsmap_=nsmap_)
        if self.requestStatus is not None:
            requestStatus_ = self.requestStatus
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}requestStatus').text = self.gds_format_string(requestStatus_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTransactionListRequestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTransactionListRequestType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTransactionListRequestType, self)._exportLiteralChildren(outfile, level, name_)
        if self.page is not None:
            showIndent(outfile, level)
            outfile.write('page=%d,\n' % self.page)
        if self.insDate is not None:
            showIndent(outfile, level)
            outfile.write('insDate=model_.DateTimeIntervalParamType(\n')
            self.insDate.exportLiteral(outfile, level, name_='insDate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.requestStatus is not None:
            showIndent(outfile, level)
            outfile.write('requestStatus=%s,\n' % self.gds_encode(quote_python(self.requestStatus)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryTransactionListRequestType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'page' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'page')
            ival_ = self.gds_validate_integer(ival_, node, 'page')
            self.page = ival_
            self.page_nsprefix_ = child_.prefix
            # validate type RequestPageType
            self.validate_RequestPageType(self.page)
        elif nodeName_ == 'insDate':
            obj_ = DateTimeIntervalParamType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.insDate = obj_
            obj_.original_tagname_ = 'insDate'
        elif nodeName_ == 'requestStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'requestStatus')
            value_ = self.gds_validate_string(value_, node, 'requestStatus')
            self.requestStatus = value_
            self.requestStatus_nsprefix_ = child_.prefix
            # validate type RequestStatusType
            self.validate_RequestStatusType(self.requestStatus)
        super(QueryTransactionListRequestType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryTransactionListRequestType


class QueryTransactionListResponseType(BasicOnlineInvoiceResponseType):
    """QueryTransactionListResponseType -- A POST /queryTransactionList REST oper
    á
    ci
    ó
    v
    á
    lasz t
    í
    pusa
    Response type of the POST /queryTransactionList REST operation
    transactionListResult -- Tranzakci
    ó
    lek
    é
    rdez
    é
    si eredm
    é
    nyei
    Transaction query results

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceResponseType
    def __init__(self, header=None, result=None, software=None, transactionListResult=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTransactionListResponseType"), self).__init__(header, result, software, extensiontype_,  **kwargs_)
        self.transactionListResult = transactionListResult
        self.transactionListResult_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTransactionListResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTransactionListResponseType.subclass:
            return QueryTransactionListResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryTransactionListResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_transactionListResult(self):
        return self.transactionListResult
    def set_transactionListResult(self, transactionListResult):
        self.transactionListResult = transactionListResult
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.transactionListResult is not None or
            super(QueryTransactionListResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryTransactionListResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTransactionListResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTransactionListResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionListResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTransactionListResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTransactionListResponseType'):
        super(QueryTransactionListResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionListResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryTransactionListResponseType', fromsubclass_=False, pretty_print=True):
        super(QueryTransactionListResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transactionListResult is not None:
            namespaceprefix_ = self.transactionListResult_nsprefix_ + ':' if (UseCapturedNS_ and self.transactionListResult_nsprefix_) else ''
            self.transactionListResult.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transactionListResult', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryTransactionListResponseType', mapping_=None, nsmap_=None):
        element = super(QueryTransactionListResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.transactionListResult is not None:
            transactionListResult_ = self.transactionListResult
            transactionListResult_.to_etree(element, name_='transactionListResult', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTransactionListResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTransactionListResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTransactionListResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.transactionListResult is not None:
            showIndent(outfile, level)
            outfile.write('transactionListResult=model_.TransactionListResultType(\n')
            self.transactionListResult.exportLiteral(outfile, level, name_='transactionListResult')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryTransactionListResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'transactionListResult':
            obj_ = TransactionListResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transactionListResult = obj_
            obj_.original_tagname_ = 'transactionListResult'
        super(QueryTransactionListResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryTransactionListResponseType


class QueryTransactionStatusRequestType(BasicOnlineInvoiceRequestType):
    """QueryTransactionStatusRequestType -- A POST /queryTransactionStatus REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s t
    í
    pusa
    Request type of the POST /queryTransactionStatus REST operation
    transactionId -- Az adatszolg
    á
    ltat
    á
    s tranzakci
    ó
    azonos
    í
    t
    ó
    ja
    Transaction identifier of the data exchange
    returnOriginalRequest -- Jel
    ö
    li, ha a kliens
    á
    ltal bek
    ü
    ld
    ö
    tt eredeti tartalmat is vissza kell adni a v
    á
    laszban
    Indicates if the original client data should also be returned in the response

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceRequestType
    def __init__(self, header=None, user=None, software=None, transactionId=None, returnOriginalRequest=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTransactionStatusRequestType"), self).__init__(header, user, software, extensiontype_,  **kwargs_)
        self.transactionId = transactionId
        self.validate_EntityIdType(self.transactionId)
        self.transactionId_nsprefix_ = "common"
        self.returnOriginalRequest = returnOriginalRequest
        self.returnOriginalRequest_nsprefix_ = "xs"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTransactionStatusRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTransactionStatusRequestType.subclass:
            return QueryTransactionStatusRequestType.subclass(*args_, **kwargs_)
        else:
            return QueryTransactionStatusRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_transactionId(self):
        return self.transactionId
    def set_transactionId(self, transactionId):
        self.transactionId = transactionId
    def get_returnOriginalRequest(self):
        return self.returnOriginalRequest
    def set_returnOriginalRequest(self, returnOriginalRequest):
        self.returnOriginalRequest = returnOriginalRequest
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_EntityIdType(self, value):
        result = True
        # Validate type EntityIdType, a restriction on AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityIdType_patterns_, ))
                result = False
        return result
    validate_EntityIdType_patterns_ = [['^([+a-zA-Z0-9_]{1,30})$']]
    def _hasContent(self):
        if (
            self.transactionId is not None or
            self.returnOriginalRequest is not None or
            super(QueryTransactionStatusRequestType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='QueryTransactionStatusRequestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTransactionStatusRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTransactionStatusRequestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionStatusRequestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTransactionStatusRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTransactionStatusRequestType'):
        super(QueryTransactionStatusRequestType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionStatusRequestType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='QueryTransactionStatusRequestType', fromsubclass_=False, pretty_print=True):
        super(QueryTransactionStatusRequestType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transactionId is not None:
            namespaceprefix_ = self.transactionId_nsprefix_ + ':' if (UseCapturedNS_ and self.transactionId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransactionId>%s</%stransactionId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.transactionId), input_name='transactionId')), namespaceprefix_ , eol_))
        if self.returnOriginalRequest is not None:
            namespaceprefix_ = self.returnOriginalRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.returnOriginalRequest_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreturnOriginalRequest>%s</%sreturnOriginalRequest>%s' % (namespaceprefix_ , self.gds_format_boolean(self.returnOriginalRequest, input_name='returnOriginalRequest'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='QueryTransactionStatusRequestType', mapping_=None, nsmap_=None):
        element = super(QueryTransactionStatusRequestType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.transactionId is not None:
            transactionId_ = self.transactionId
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}transactionId').text = self.gds_format_string(transactionId_)
        if self.returnOriginalRequest is not None:
            returnOriginalRequest_ = self.returnOriginalRequest
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}returnOriginalRequest').text = self.gds_format_boolean(returnOriginalRequest_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTransactionStatusRequestType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTransactionStatusRequestType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTransactionStatusRequestType, self)._exportLiteralChildren(outfile, level, name_)
        if self.transactionId is not None:
            showIndent(outfile, level)
            outfile.write('transactionId=%s,\n' % self.gds_encode(quote_python(self.transactionId)))
        if self.returnOriginalRequest is not None:
            showIndent(outfile, level)
            outfile.write('returnOriginalRequest=%s,\n' % self.returnOriginalRequest)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryTransactionStatusRequestType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'transactionId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'transactionId')
            value_ = self.gds_validate_string(value_, node, 'transactionId')
            self.transactionId = value_
            self.transactionId_nsprefix_ = child_.prefix
            # validate type EntityIdType
            self.validate_EntityIdType(self.transactionId)
        elif nodeName_ == 'returnOriginalRequest':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'returnOriginalRequest')
            ival_ = self.gds_validate_boolean(ival_, node, 'returnOriginalRequest')
            self.returnOriginalRequest = ival_
            self.returnOriginalRequest_nsprefix_ = child_.prefix
        super(QueryTransactionStatusRequestType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryTransactionStatusRequestType


class QueryTransactionStatusResponseType(BasicOnlineInvoiceResponseType):
    """QueryTransactionStatusResponseType -- A POST /queryTransactionStatus REST oper
    á
    ci
    ó
    v
    á
    lasz t
    í
    pusa
    Response type of the POST /queryTransactionStatus REST operation
    processingResults -- A k
    é
    r
    é
    sben szerepl
    ő
    sz
    á
    ml
    á
    k feldolgoz
    á
    si st
    á
    tusza
    Processing status of the invoices in the request

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceResponseType
    def __init__(self, header=None, result=None, software=None, processingResults=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTransactionStatusResponseType"), self).__init__(header, result, software, extensiontype_,  **kwargs_)
        self.processingResults = processingResults
        self.processingResults_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTransactionStatusResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTransactionStatusResponseType.subclass:
            return QueryTransactionStatusResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryTransactionStatusResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_processingResults(self):
        return self.processingResults
    def set_processingResults(self, processingResults):
        self.processingResults = processingResults
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.processingResults is not None or
            super(QueryTransactionStatusResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryTransactionStatusResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTransactionStatusResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTransactionStatusResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionStatusResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTransactionStatusResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTransactionStatusResponseType'):
        super(QueryTransactionStatusResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionStatusResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryTransactionStatusResponseType', fromsubclass_=False, pretty_print=True):
        super(QueryTransactionStatusResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processingResults is not None:
            namespaceprefix_ = self.processingResults_nsprefix_ + ':' if (UseCapturedNS_ and self.processingResults_nsprefix_) else ''
            self.processingResults.export(outfile, level, namespaceprefix_, namespacedef_='', name_='processingResults', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryTransactionStatusResponseType', mapping_=None, nsmap_=None):
        element = super(QueryTransactionStatusResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.processingResults is not None:
            processingResults_ = self.processingResults
            processingResults_.to_etree(element, name_='processingResults', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTransactionStatusResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTransactionStatusResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTransactionStatusResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.processingResults is not None:
            showIndent(outfile, level)
            outfile.write('processingResults=model_.ProcessingResultListType(\n')
            self.processingResults.exportLiteral(outfile, level, name_='processingResults')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QueryTransactionStatusResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'processingResults':
            obj_ = ProcessingResultListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.processingResults = obj_
            obj_.original_tagname_ = 'processingResults'
        super(QueryTransactionStatusResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class QueryTransactionStatusResponseType


class RelationalQueryParamsType(GeneratedsSuper):
    """RelationalQueryParamsType -- A sz
    á
    mla lek
    é
    rdez
    é
    s rel
    á
    ci
    ó
    s param
    é
    terei
    Relational params of the invoice query
    invoiceDelivery -- Sz
    á
    mla teljes
    í
    t
    é
    si d
    á
    tum
    á
    nak keres
    ő
    param
    é
    tere
    Query parameter of the invoice delivery date
    paymentDate -- A sz
    á
    mla fizet
    é
    si hat
    á
    ridej
    é
    nek keres
    ő
    param
    é
    tere
    Query parameter of the invoice payment date
    invoiceNetAmount -- A sz
    á
    mla nett
    ó
    ö
    sszeg keres
    ő
    param
    é
    tere a sz
    á
    mla p
    é
    nznem
    é
    ben
    Query parameter of the invoice net amount expressed in the currency of the invoice
    invoiceNetAmountHUF -- A sz
    á
    mla nett
    ó
    ö
    sszeg
    é
    nek keres
    ő
    param
    é
    tere forintban
    Query parameter of the invoice net amount expressed in HUF
    invoiceVatAmount -- A sz
    á
    mla
    Á
    FA
    ö
    sszeg
    é
    nek keres
    ő
    param
    é
    tere a sz
    á
    mla p
    é
    nznem
    é
    ben
    Query parameter of the invoice VAT amount expressed in the currency of the invoice
    invoiceVatAmountHUF -- A sz
    á
    mla
    Á
    FA
    ö
    sszeg
    é
    nek keres
    ő
    param
    é
    tere forintban
    Query parameter of the invoice VAT amount expressed in HUF

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceDelivery=None, paymentDate=None, invoiceNetAmount=None, invoiceNetAmountHUF=None, invoiceVatAmount=None, invoiceVatAmountHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if invoiceDelivery is None:
            self.invoiceDelivery = []
        else:
            self.invoiceDelivery = invoiceDelivery
        self.invoiceDelivery_nsprefix_ = None
        if paymentDate is None:
            self.paymentDate = []
        else:
            self.paymentDate = paymentDate
        self.paymentDate_nsprefix_ = None
        if invoiceNetAmount is None:
            self.invoiceNetAmount = []
        else:
            self.invoiceNetAmount = invoiceNetAmount
        self.invoiceNetAmount_nsprefix_ = None
        if invoiceNetAmountHUF is None:
            self.invoiceNetAmountHUF = []
        else:
            self.invoiceNetAmountHUF = invoiceNetAmountHUF
        self.invoiceNetAmountHUF_nsprefix_ = None
        if invoiceVatAmount is None:
            self.invoiceVatAmount = []
        else:
            self.invoiceVatAmount = invoiceVatAmount
        self.invoiceVatAmount_nsprefix_ = None
        if invoiceVatAmountHUF is None:
            self.invoiceVatAmountHUF = []
        else:
            self.invoiceVatAmountHUF = invoiceVatAmountHUF
        self.invoiceVatAmountHUF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelationalQueryParamsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelationalQueryParamsType.subclass:
            return RelationalQueryParamsType.subclass(*args_, **kwargs_)
        else:
            return RelationalQueryParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceDelivery(self):
        return self.invoiceDelivery
    def set_invoiceDelivery(self, invoiceDelivery):
        self.invoiceDelivery = invoiceDelivery
    def add_invoiceDelivery(self, value):
        self.invoiceDelivery.append(value)
    def insert_invoiceDelivery_at(self, index, value):
        self.invoiceDelivery.insert(index, value)
    def replace_invoiceDelivery_at(self, index, value):
        self.invoiceDelivery[index] = value
    def get_paymentDate(self):
        return self.paymentDate
    def set_paymentDate(self, paymentDate):
        self.paymentDate = paymentDate
    def add_paymentDate(self, value):
        self.paymentDate.append(value)
    def insert_paymentDate_at(self, index, value):
        self.paymentDate.insert(index, value)
    def replace_paymentDate_at(self, index, value):
        self.paymentDate[index] = value
    def get_invoiceNetAmount(self):
        return self.invoiceNetAmount
    def set_invoiceNetAmount(self, invoiceNetAmount):
        self.invoiceNetAmount = invoiceNetAmount
    def add_invoiceNetAmount(self, value):
        self.invoiceNetAmount.append(value)
    def insert_invoiceNetAmount_at(self, index, value):
        self.invoiceNetAmount.insert(index, value)
    def replace_invoiceNetAmount_at(self, index, value):
        self.invoiceNetAmount[index] = value
    def get_invoiceNetAmountHUF(self):
        return self.invoiceNetAmountHUF
    def set_invoiceNetAmountHUF(self, invoiceNetAmountHUF):
        self.invoiceNetAmountHUF = invoiceNetAmountHUF
    def add_invoiceNetAmountHUF(self, value):
        self.invoiceNetAmountHUF.append(value)
    def insert_invoiceNetAmountHUF_at(self, index, value):
        self.invoiceNetAmountHUF.insert(index, value)
    def replace_invoiceNetAmountHUF_at(self, index, value):
        self.invoiceNetAmountHUF[index] = value
    def get_invoiceVatAmount(self):
        return self.invoiceVatAmount
    def set_invoiceVatAmount(self, invoiceVatAmount):
        self.invoiceVatAmount = invoiceVatAmount
    def add_invoiceVatAmount(self, value):
        self.invoiceVatAmount.append(value)
    def insert_invoiceVatAmount_at(self, index, value):
        self.invoiceVatAmount.insert(index, value)
    def replace_invoiceVatAmount_at(self, index, value):
        self.invoiceVatAmount[index] = value
    def get_invoiceVatAmountHUF(self):
        return self.invoiceVatAmountHUF
    def set_invoiceVatAmountHUF(self, invoiceVatAmountHUF):
        self.invoiceVatAmountHUF = invoiceVatAmountHUF
    def add_invoiceVatAmountHUF(self, value):
        self.invoiceVatAmountHUF.append(value)
    def insert_invoiceVatAmountHUF_at(self, index, value):
        self.invoiceVatAmountHUF.insert(index, value)
    def replace_invoiceVatAmountHUF_at(self, index, value):
        self.invoiceVatAmountHUF[index] = value
    def _hasContent(self):
        if (
            self.invoiceDelivery or
            self.paymentDate or
            self.invoiceNetAmount or
            self.invoiceNetAmountHUF or
            self.invoiceVatAmount or
            self.invoiceVatAmountHUF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='RelationalQueryParamsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelationalQueryParamsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RelationalQueryParamsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RelationalQueryParamsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RelationalQueryParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RelationalQueryParamsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='RelationalQueryParamsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for invoiceDelivery_ in self.invoiceDelivery:
            namespaceprefix_ = self.invoiceDelivery_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDelivery_nsprefix_) else ''
            invoiceDelivery_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceDelivery', pretty_print=pretty_print)
        for paymentDate_ in self.paymentDate:
            namespaceprefix_ = self.paymentDate_nsprefix_ + ':' if (UseCapturedNS_ and self.paymentDate_nsprefix_) else ''
            paymentDate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paymentDate', pretty_print=pretty_print)
        for invoiceNetAmount_ in self.invoiceNetAmount:
            namespaceprefix_ = self.invoiceNetAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNetAmount_nsprefix_) else ''
            invoiceNetAmount_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceNetAmount', pretty_print=pretty_print)
        for invoiceNetAmountHUF_ in self.invoiceNetAmountHUF:
            namespaceprefix_ = self.invoiceNetAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNetAmountHUF_nsprefix_) else ''
            invoiceNetAmountHUF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceNetAmountHUF', pretty_print=pretty_print)
        for invoiceVatAmount_ in self.invoiceVatAmount:
            namespaceprefix_ = self.invoiceVatAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceVatAmount_nsprefix_) else ''
            invoiceVatAmount_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceVatAmount', pretty_print=pretty_print)
        for invoiceVatAmountHUF_ in self.invoiceVatAmountHUF:
            namespaceprefix_ = self.invoiceVatAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceVatAmountHUF_nsprefix_) else ''
            invoiceVatAmountHUF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceVatAmountHUF', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RelationalQueryParamsType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        for invoiceDelivery_ in self.invoiceDelivery:
            invoiceDelivery_.to_etree(element, name_='invoiceDelivery', mapping_=mapping_, nsmap_=nsmap_)
        for paymentDate_ in self.paymentDate:
            paymentDate_.to_etree(element, name_='paymentDate', mapping_=mapping_, nsmap_=nsmap_)
        for invoiceNetAmount_ in self.invoiceNetAmount:
            invoiceNetAmount_.to_etree(element, name_='invoiceNetAmount', mapping_=mapping_, nsmap_=nsmap_)
        for invoiceNetAmountHUF_ in self.invoiceNetAmountHUF:
            invoiceNetAmountHUF_.to_etree(element, name_='invoiceNetAmountHUF', mapping_=mapping_, nsmap_=nsmap_)
        for invoiceVatAmount_ in self.invoiceVatAmount:
            invoiceVatAmount_.to_etree(element, name_='invoiceVatAmount', mapping_=mapping_, nsmap_=nsmap_)
        for invoiceVatAmountHUF_ in self.invoiceVatAmountHUF:
            invoiceVatAmountHUF_.to_etree(element, name_='invoiceVatAmountHUF', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='RelationalQueryParamsType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('invoiceDelivery=[\n')
        level += 1
        for invoiceDelivery_ in self.invoiceDelivery:
            showIndent(outfile, level)
            outfile.write('model_.RelationQueryDateType(\n')
            invoiceDelivery_.exportLiteral(outfile, level, name_='RelationQueryDateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('paymentDate=[\n')
        level += 1
        for paymentDate_ in self.paymentDate:
            showIndent(outfile, level)
            outfile.write('model_.RelationQueryDateType(\n')
            paymentDate_.exportLiteral(outfile, level, name_='RelationQueryDateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('invoiceNetAmount=[\n')
        level += 1
        for invoiceNetAmount_ in self.invoiceNetAmount:
            showIndent(outfile, level)
            outfile.write('model_.RelationQueryMonetaryType(\n')
            invoiceNetAmount_.exportLiteral(outfile, level, name_='RelationQueryMonetaryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('invoiceNetAmountHUF=[\n')
        level += 1
        for invoiceNetAmountHUF_ in self.invoiceNetAmountHUF:
            showIndent(outfile, level)
            outfile.write('model_.RelationQueryMonetaryType(\n')
            invoiceNetAmountHUF_.exportLiteral(outfile, level, name_='RelationQueryMonetaryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('invoiceVatAmount=[\n')
        level += 1
        for invoiceVatAmount_ in self.invoiceVatAmount:
            showIndent(outfile, level)
            outfile.write('model_.RelationQueryMonetaryType(\n')
            invoiceVatAmount_.exportLiteral(outfile, level, name_='RelationQueryMonetaryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('invoiceVatAmountHUF=[\n')
        level += 1
        for invoiceVatAmountHUF_ in self.invoiceVatAmountHUF:
            showIndent(outfile, level)
            outfile.write('model_.RelationQueryMonetaryType(\n')
            invoiceVatAmountHUF_.exportLiteral(outfile, level, name_='RelationQueryMonetaryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceDelivery':
            obj_ = RelationQueryDateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceDelivery.append(obj_)
            obj_.original_tagname_ = 'invoiceDelivery'
        elif nodeName_ == 'paymentDate':
            obj_ = RelationQueryDateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.paymentDate.append(obj_)
            obj_.original_tagname_ = 'paymentDate'
        elif nodeName_ == 'invoiceNetAmount':
            obj_ = RelationQueryMonetaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceNetAmount.append(obj_)
            obj_.original_tagname_ = 'invoiceNetAmount'
        elif nodeName_ == 'invoiceNetAmountHUF':
            obj_ = RelationQueryMonetaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceNetAmountHUF.append(obj_)
            obj_.original_tagname_ = 'invoiceNetAmountHUF'
        elif nodeName_ == 'invoiceVatAmount':
            obj_ = RelationQueryMonetaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceVatAmount.append(obj_)
            obj_.original_tagname_ = 'invoiceVatAmount'
        elif nodeName_ == 'invoiceVatAmountHUF':
            obj_ = RelationQueryMonetaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceVatAmountHUF.append(obj_)
            obj_.original_tagname_ = 'invoiceVatAmountHUF'
# end class RelationalQueryParamsType


class RelationQueryDateType(GeneratedsSuper):
    """RelationQueryDateType -- Keres
    ő
    param
    é
    ter d
    á
    tum
    é
    rt
    é
    kekhez
    Query parameter for date values
    queryOperator -- Keres
    ő
    oper
    á
    tor
    Query operator
    queryValue -- Keres
    ő
    é
    rt
    é
    k
    Query value

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, queryOperator=None, queryValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.queryOperator = queryOperator
        self.validate_QueryOperatorType(self.queryOperator)
        self.queryOperator_nsprefix_ = None
        if isinstance(queryValue, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(queryValue, '%Y-%m-%d').date()
        else:
            initvalue_ = queryValue
        self.queryValue = initvalue_
        self.queryValue_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelationQueryDateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelationQueryDateType.subclass:
            return RelationQueryDateType.subclass(*args_, **kwargs_)
        else:
            return RelationQueryDateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_queryOperator(self):
        return self.queryOperator
    def set_queryOperator(self, queryOperator):
        self.queryOperator = queryOperator
    def get_queryValue(self):
        return self.queryValue
    def set_queryValue(self, queryValue):
        self.queryValue = queryValue
    def validate_QueryOperatorType(self, value):
        result = True
        # Validate type QueryOperatorType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['EQ', 'GT', 'GTE', 'LT', 'LTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on QueryOperatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on QueryOperatorType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on QueryOperatorType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceDateType(self, value):
        result = True
        # Validate type InvoiceDateType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.strptime('2010-01-01', '%Y-%m-%d').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceDateType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceDateType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceDateType_patterns_, ))
                result = False
        return result
    validate_InvoiceDateType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2})$']]
    def _hasContent(self):
        if (
            self.queryOperator is not None or
            self.queryValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='RelationQueryDateType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelationQueryDateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RelationQueryDateType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RelationQueryDateType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RelationQueryDateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RelationQueryDateType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='RelationQueryDateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.queryOperator is not None:
            namespaceprefix_ = self.queryOperator_nsprefix_ + ':' if (UseCapturedNS_ and self.queryOperator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squeryOperator>%s</%squeryOperator>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.queryOperator), input_name='queryOperator')), namespaceprefix_ , eol_))
        if self.queryValue is not None:
            namespaceprefix_ = self.queryValue_nsprefix_ + ':' if (UseCapturedNS_ and self.queryValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squeryValue>%s</%squeryValue>%s' % (namespaceprefix_ , self.gds_format_date(self.queryValue, input_name='queryValue'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='RelationQueryDateType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.queryOperator is not None:
            queryOperator_ = self.queryOperator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}queryOperator').text = self.gds_format_string(queryOperator_)
        if self.queryValue is not None:
            queryValue_ = self.queryValue
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}queryValue').text = self.gds_format_date(queryValue_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='RelationQueryDateType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.queryOperator is not None:
            showIndent(outfile, level)
            outfile.write('queryOperator=%s,\n' % self.gds_encode(quote_python(self.queryOperator)))
        if self.queryValue is not None:
            showIndent(outfile, level)
            outfile.write('queryValue=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.queryValue, input_name='queryValue'))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'queryOperator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'queryOperator')
            value_ = self.gds_validate_string(value_, node, 'queryOperator')
            self.queryOperator = value_
            self.queryOperator_nsprefix_ = child_.prefix
            # validate type QueryOperatorType
            self.validate_QueryOperatorType(self.queryOperator)
        elif nodeName_ == 'queryValue':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.queryValue = dval_
            self.queryValue_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.queryValue)
# end class RelationQueryDateType


class RelationQueryMonetaryType(GeneratedsSuper):
    """RelationQueryMonetaryType -- Keres
    ő
    param
    é
    ter monet
    á
    ris
    é
    rt
    é
    kekhez
    Query parameter for monetary values
    queryOperator -- Keres
    ő
    oper
    á
    tor
    Query operator
    queryValue -- Keres
    ő
    é
    rt
    é
    k
    Query value

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, queryOperator=None, queryValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.queryOperator = queryOperator
        self.validate_QueryOperatorType(self.queryOperator)
        self.queryOperator_nsprefix_ = None
        self.queryValue = queryValue
        self.validate_MonetaryType(self.queryValue)
        self.queryValue_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelationQueryMonetaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelationQueryMonetaryType.subclass:
            return RelationQueryMonetaryType.subclass(*args_, **kwargs_)
        else:
            return RelationQueryMonetaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_queryOperator(self):
        return self.queryOperator
    def set_queryOperator(self, queryOperator):
        self.queryOperator = queryOperator
    def get_queryValue(self):
        return self.queryValue
    def set_queryValue(self, queryValue):
        self.queryValue = queryValue
    def validate_QueryOperatorType(self, value):
        result = True
        # Validate type QueryOperatorType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['EQ', 'GT', 'GTE', 'LT', 'LTE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on QueryOperatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on QueryOperatorType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on QueryOperatorType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.queryOperator is not None or
            self.queryValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='RelationQueryMonetaryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelationQueryMonetaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RelationQueryMonetaryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RelationQueryMonetaryType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RelationQueryMonetaryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RelationQueryMonetaryType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='RelationQueryMonetaryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.queryOperator is not None:
            namespaceprefix_ = self.queryOperator_nsprefix_ + ':' if (UseCapturedNS_ and self.queryOperator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squeryOperator>%s</%squeryOperator>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.queryOperator), input_name='queryOperator')), namespaceprefix_ , eol_))
        if self.queryValue is not None:
            namespaceprefix_ = self.queryValue_nsprefix_ + ':' if (UseCapturedNS_ and self.queryValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squeryValue>%s</%squeryValue>%s' % (namespaceprefix_ , self.gds_format_decimal(self.queryValue, input_name='queryValue'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='RelationQueryMonetaryType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.queryOperator is not None:
            queryOperator_ = self.queryOperator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}queryOperator').text = self.gds_format_string(queryOperator_)
        if self.queryValue is not None:
            queryValue_ = self.queryValue
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}queryValue').text = self.gds_format_decimal(queryValue_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='RelationQueryMonetaryType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.queryOperator is not None:
            showIndent(outfile, level)
            outfile.write('queryOperator=%s,\n' % self.gds_encode(quote_python(self.queryOperator)))
        if self.queryValue is not None:
            showIndent(outfile, level)
            outfile.write('queryValue=%f,\n' % self.queryValue)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'queryOperator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'queryOperator')
            value_ = self.gds_validate_string(value_, node, 'queryOperator')
            self.queryOperator = value_
            self.queryOperator_nsprefix_ = child_.prefix
            # validate type QueryOperatorType
            self.validate_QueryOperatorType(self.queryOperator)
        elif nodeName_ == 'queryValue' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'queryValue')
            fval_ = self.gds_validate_decimal(fval_, node, 'queryValue')
            self.queryValue = fval_
            self.queryValue_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.queryValue)
# end class RelationQueryMonetaryType


class SoftwareType(GeneratedsSuper):
    """SoftwareType -- A számlázó program adatai
    Billing software data
    softwareId -- A számlázó program azonosítója
    Billing software ID
    softwareName -- A számlázó program neve
    Billing software name
    softwareOperation -- A számlázó program működési típusa (lokális program vagy online számlázó szolgáltatás)
    Billing software operation type (local program or online billing service)
    softwareMainVersion -- A számlázó program fő verziója
    Billing software main version
    softwareDevName -- A számlázó program fejlesztőjének neve
    Name of the billing software's developer
    softwareDevContact -- A számlázóprogram fejlesztőjének elektronikus elérhetősége
    Electronic contact of the billing software's developer
    softwareDevCountryCode -- A számlázó program fejlesztőjének ISO-3166 alpha2 országkódja
    ISO-3166 alpha2 country code of the billing software's developer
    softwareDevTaxNumber -- A számlázó program fejlesztőjének adószáma
    Tax number of the billing software's developer

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, softwareId=None, softwareName=None, softwareOperation=None, softwareMainVersion=None, softwareDevName=None, softwareDevContact=None, softwareDevCountryCode=None, softwareDevTaxNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.softwareId = softwareId
        self.validate_SoftwareIdType(self.softwareId)
        self.softwareId_nsprefix_ = None
        self.softwareName = softwareName
        self.validate_SimpleText50NotBlankType(self.softwareName)
        self.softwareName_nsprefix_ = None
        self.softwareOperation = softwareOperation
        self.validate_SoftwareOperationType(self.softwareOperation)
        self.softwareOperation_nsprefix_ = None
        self.softwareMainVersion = softwareMainVersion
        self.validate_SimpleText15NotBlankType(self.softwareMainVersion)
        self.softwareMainVersion_nsprefix_ = None
        self.softwareDevName = softwareDevName
        self.validate_SimpleText512NotBlankType(self.softwareDevName)
        self.softwareDevName_nsprefix_ = None
        self.softwareDevContact = softwareDevContact
        self.validate_SimpleText200NotBlankType(self.softwareDevContact)
        self.softwareDevContact_nsprefix_ = None
        self.softwareDevCountryCode = softwareDevCountryCode
        self.validate_CountryCodeType(self.softwareDevCountryCode)
        self.softwareDevCountryCode_nsprefix_ = None
        self.softwareDevTaxNumber = softwareDevTaxNumber
        self.validate_SimpleText50NotBlankType(self.softwareDevTaxNumber)
        self.softwareDevTaxNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SoftwareType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SoftwareType.subclass:
            return SoftwareType.subclass(*args_, **kwargs_)
        else:
            return SoftwareType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_softwareId(self):
        return self.softwareId
    def set_softwareId(self, softwareId):
        self.softwareId = softwareId
    def get_softwareName(self):
        return self.softwareName
    def set_softwareName(self, softwareName):
        self.softwareName = softwareName
    def get_softwareOperation(self):
        return self.softwareOperation
    def set_softwareOperation(self, softwareOperation):
        self.softwareOperation = softwareOperation
    def get_softwareMainVersion(self):
        return self.softwareMainVersion
    def set_softwareMainVersion(self, softwareMainVersion):
        self.softwareMainVersion = softwareMainVersion
    def get_softwareDevName(self):
        return self.softwareDevName
    def set_softwareDevName(self, softwareDevName):
        self.softwareDevName = softwareDevName
    def get_softwareDevContact(self):
        return self.softwareDevContact
    def set_softwareDevContact(self, softwareDevContact):
        self.softwareDevContact = softwareDevContact
    def get_softwareDevCountryCode(self):
        return self.softwareDevCountryCode
    def set_softwareDevCountryCode(self, softwareDevCountryCode):
        self.softwareDevCountryCode = softwareDevCountryCode
    def get_softwareDevTaxNumber(self):
        return self.softwareDevTaxNumber
    def set_softwareDevTaxNumber(self, softwareDevTaxNumber):
        self.softwareDevTaxNumber = softwareDevTaxNumber
    def validate_SoftwareIdType(self, value):
        result = True
        # Validate type SoftwareIdType, a restriction on common:AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on SoftwareIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SoftwareIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SoftwareIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SoftwareIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SoftwareIdType_patterns_, ))
                result = False
        return result
    validate_SoftwareIdType_patterns_ = [['^([0-9A-Z\\-]{18})$']]
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SoftwareOperationType(self, value):
        result = True
        # Validate type SoftwareOperationType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['LOCAL_SOFTWARE', 'ONLINE_SERVICE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SoftwareOperationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SoftwareOperationType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SoftwareOperationType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText15NotBlankType(self, value):
        result = True
        # Validate type SimpleText15NotBlankType, a restriction on AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText15NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText15NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText15NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText15NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText15NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText200NotBlankType(self, value):
        result = True
        # Validate type SimpleText200NotBlankType, a restriction on AtomicStringType200.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText200NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText200NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText200NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText200NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText200NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_CountryCodeType(self, value):
        result = True
        # Validate type CountryCodeType, a restriction on AtomicStringType2.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on CountryCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CountryCodeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CountryCodeType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CountryCodeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CountryCodeType_patterns_, ))
                result = False
        return result
    validate_CountryCodeType_patterns_ = [['^([A-Z]{2})$']]
    def _hasContent(self):
        if (
            self.softwareId is not None or
            self.softwareName is not None or
            self.softwareOperation is not None or
            self.softwareMainVersion is not None or
            self.softwareDevName is not None or
            self.softwareDevContact is not None or
            self.softwareDevCountryCode is not None or
            self.softwareDevTaxNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='SoftwareType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SoftwareType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SoftwareType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SoftwareType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SoftwareType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SoftwareType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='SoftwareType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.softwareId is not None:
            namespaceprefix_ = self.softwareId_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareId>%s</%ssoftwareId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareId), input_name='softwareId')), namespaceprefix_ , eol_))
        if self.softwareName is not None:
            namespaceprefix_ = self.softwareName_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareName>%s</%ssoftwareName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareName), input_name='softwareName')), namespaceprefix_ , eol_))
        if self.softwareOperation is not None:
            namespaceprefix_ = self.softwareOperation_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareOperation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareOperation>%s</%ssoftwareOperation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareOperation), input_name='softwareOperation')), namespaceprefix_ , eol_))
        if self.softwareMainVersion is not None:
            namespaceprefix_ = self.softwareMainVersion_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareMainVersion_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareMainVersion>%s</%ssoftwareMainVersion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareMainVersion), input_name='softwareMainVersion')), namespaceprefix_ , eol_))
        if self.softwareDevName is not None:
            namespaceprefix_ = self.softwareDevName_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareDevName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareDevName>%s</%ssoftwareDevName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareDevName), input_name='softwareDevName')), namespaceprefix_ , eol_))
        if self.softwareDevContact is not None:
            namespaceprefix_ = self.softwareDevContact_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareDevContact_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareDevContact>%s</%ssoftwareDevContact>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareDevContact), input_name='softwareDevContact')), namespaceprefix_ , eol_))
        if self.softwareDevCountryCode is not None:
            namespaceprefix_ = self.softwareDevCountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareDevCountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareDevCountryCode>%s</%ssoftwareDevCountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareDevCountryCode), input_name='softwareDevCountryCode')), namespaceprefix_ , eol_))
        if self.softwareDevTaxNumber is not None:
            namespaceprefix_ = self.softwareDevTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.softwareDevTaxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoftwareDevTaxNumber>%s</%ssoftwareDevTaxNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.softwareDevTaxNumber), input_name='softwareDevTaxNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='SoftwareType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.softwareId is not None:
            softwareId_ = self.softwareId
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}softwareId').text = self.gds_format_string(softwareId_)
        if self.softwareName is not None:
            softwareName_ = self.softwareName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}softwareName').text = self.gds_format_string(softwareName_)
        if self.softwareOperation is not None:
            softwareOperation_ = self.softwareOperation
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}softwareOperation').text = self.gds_format_string(softwareOperation_)
        if self.softwareMainVersion is not None:
            softwareMainVersion_ = self.softwareMainVersion
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}softwareMainVersion').text = self.gds_format_string(softwareMainVersion_)
        if self.softwareDevName is not None:
            softwareDevName_ = self.softwareDevName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}softwareDevName').text = self.gds_format_string(softwareDevName_)
        if self.softwareDevContact is not None:
            softwareDevContact_ = self.softwareDevContact
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}softwareDevContact').text = self.gds_format_string(softwareDevContact_)
        if self.softwareDevCountryCode is not None:
            softwareDevCountryCode_ = self.softwareDevCountryCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}softwareDevCountryCode').text = self.gds_format_string(softwareDevCountryCode_)
        if self.softwareDevTaxNumber is not None:
            softwareDevTaxNumber_ = self.softwareDevTaxNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}softwareDevTaxNumber').text = self.gds_format_string(softwareDevTaxNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SoftwareType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.softwareId is not None:
            showIndent(outfile, level)
            outfile.write('softwareId=%s,\n' % self.gds_encode(quote_python(self.softwareId)))
        if self.softwareName is not None:
            showIndent(outfile, level)
            outfile.write('softwareName=%s,\n' % self.gds_encode(quote_python(self.softwareName)))
        if self.softwareOperation is not None:
            showIndent(outfile, level)
            outfile.write('softwareOperation=%s,\n' % self.gds_encode(quote_python(self.softwareOperation)))
        if self.softwareMainVersion is not None:
            showIndent(outfile, level)
            outfile.write('softwareMainVersion=%s,\n' % self.gds_encode(quote_python(self.softwareMainVersion)))
        if self.softwareDevName is not None:
            showIndent(outfile, level)
            outfile.write('softwareDevName=%s,\n' % self.gds_encode(quote_python(self.softwareDevName)))
        if self.softwareDevContact is not None:
            showIndent(outfile, level)
            outfile.write('softwareDevContact=%s,\n' % self.gds_encode(quote_python(self.softwareDevContact)))
        if self.softwareDevCountryCode is not None:
            showIndent(outfile, level)
            outfile.write('softwareDevCountryCode=%s,\n' % self.gds_encode(quote_python(self.softwareDevCountryCode)))
        if self.softwareDevTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('softwareDevTaxNumber=%s,\n' % self.gds_encode(quote_python(self.softwareDevTaxNumber)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'softwareId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'softwareId')
            value_ = self.gds_validate_string(value_, node, 'softwareId')
            self.softwareId = value_
            self.softwareId_nsprefix_ = child_.prefix
            # validate type SoftwareIdType
            self.validate_SoftwareIdType(self.softwareId)
        elif nodeName_ == 'softwareName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'softwareName')
            value_ = self.gds_validate_string(value_, node, 'softwareName')
            self.softwareName = value_
            self.softwareName_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.softwareName)
        elif nodeName_ == 'softwareOperation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'softwareOperation')
            value_ = self.gds_validate_string(value_, node, 'softwareOperation')
            self.softwareOperation = value_
            self.softwareOperation_nsprefix_ = child_.prefix
            # validate type SoftwareOperationType
            self.validate_SoftwareOperationType(self.softwareOperation)
        elif nodeName_ == 'softwareMainVersion':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'softwareMainVersion')
            value_ = self.gds_validate_string(value_, node, 'softwareMainVersion')
            self.softwareMainVersion = value_
            self.softwareMainVersion_nsprefix_ = child_.prefix
            # validate type SimpleText15NotBlankType
            self.validate_SimpleText15NotBlankType(self.softwareMainVersion)
        elif nodeName_ == 'softwareDevName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'softwareDevName')
            value_ = self.gds_validate_string(value_, node, 'softwareDevName')
            self.softwareDevName = value_
            self.softwareDevName_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.softwareDevName)
        elif nodeName_ == 'softwareDevContact':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'softwareDevContact')
            value_ = self.gds_validate_string(value_, node, 'softwareDevContact')
            self.softwareDevContact = value_
            self.softwareDevContact_nsprefix_ = child_.prefix
            # validate type SimpleText200NotBlankType
            self.validate_SimpleText200NotBlankType(self.softwareDevContact)
        elif nodeName_ == 'softwareDevCountryCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'softwareDevCountryCode')
            value_ = self.gds_validate_string(value_, node, 'softwareDevCountryCode')
            self.softwareDevCountryCode = value_
            self.softwareDevCountryCode_nsprefix_ = child_.prefix
            # validate type CountryCodeType
            self.validate_CountryCodeType(self.softwareDevCountryCode)
        elif nodeName_ == 'softwareDevTaxNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'softwareDevTaxNumber')
            value_ = self.gds_validate_string(value_, node, 'softwareDevTaxNumber')
            self.softwareDevTaxNumber = value_
            self.softwareDevTaxNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.softwareDevTaxNumber)
# end class SoftwareType


class TaxpayerAddressItemType(GeneratedsSuper):
    """TaxpayerAddressItemType -- Adózói címsor adat
    Taxpayer address_list item
    taxpayerAddressType -- Adózói cím típus
    Taxpayer address_list type
    taxpayerAddress -- Az adózó címadatai
    Address data of the taxpayer

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, taxpayerAddressType=None, taxpayerAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.taxpayerAddressType = taxpayerAddressType
        self.validate_TaxpayerAddressTypeType(self.taxpayerAddressType)
        self.taxpayerAddressType_nsprefix_ = None
        self.taxpayerAddress = taxpayerAddress
        self.taxpayerAddress_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxpayerAddressItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxpayerAddressItemType.subclass:
            return TaxpayerAddressItemType.subclass(*args_, **kwargs_)
        else:
            return TaxpayerAddressItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_taxpayerAddressType(self):
        return self.taxpayerAddressType
    def set_taxpayerAddressType(self, taxpayerAddressType):
        self.taxpayerAddressType = taxpayerAddressType
    def get_taxpayerAddress(self):
        return self.taxpayerAddress
    def set_taxpayerAddress(self, taxpayerAddress):
        self.taxpayerAddress = taxpayerAddress
    def validate_TaxpayerAddressTypeType(self, value):
        result = True
        # Validate type TaxpayerAddressTypeType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['HQ', 'SITE', 'BRANCH']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TaxpayerAddressTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxpayerAddressTypeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxpayerAddressTypeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.taxpayerAddressType is not None or
            self.taxpayerAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='TaxpayerAddressItemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxpayerAddressItemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxpayerAddressItemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxpayerAddressItemType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxpayerAddressItemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxpayerAddressItemType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='TaxpayerAddressItemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.taxpayerAddressType is not None:
            namespaceprefix_ = self.taxpayerAddressType_nsprefix_ + ':' if (UseCapturedNS_ and self.taxpayerAddressType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxpayerAddressType>%s</%staxpayerAddressType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxpayerAddressType), input_name='taxpayerAddressType')), namespaceprefix_ , eol_))
        if self.taxpayerAddress is not None:
            namespaceprefix_ = self.taxpayerAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.taxpayerAddress_nsprefix_) else ''
            self.taxpayerAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taxpayerAddress', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TaxpayerAddressItemType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.taxpayerAddressType is not None:
            taxpayerAddressType_ = self.taxpayerAddressType
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}taxpayerAddressType').text = self.gds_format_string(taxpayerAddressType_)
        if self.taxpayerAddress is not None:
            taxpayerAddress_ = self.taxpayerAddress
            taxpayerAddress_.to_etree(element, name_='taxpayerAddress', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TaxpayerAddressItemType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.taxpayerAddressType is not None:
            showIndent(outfile, level)
            outfile.write('taxpayerAddressType=%s,\n' % self.gds_encode(quote_python(self.taxpayerAddressType)))
        if self.taxpayerAddress is not None:
            showIndent(outfile, level)
            outfile.write('taxpayerAddress=model_.DetailedAddressType(\n')
            self.taxpayerAddress.exportLiteral(outfile, level, name_='taxpayerAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'taxpayerAddressType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxpayerAddressType')
            value_ = self.gds_validate_string(value_, node, 'taxpayerAddressType')
            self.taxpayerAddressType = value_
            self.taxpayerAddressType_nsprefix_ = child_.prefix
            # validate type TaxpayerAddressTypeType
            self.validate_TaxpayerAddressTypeType(self.taxpayerAddressType)
        elif nodeName_ == 'taxpayerAddress':
            obj_ = DetailedAddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taxpayerAddress = obj_
            obj_.original_tagname_ = 'taxpayerAddress'
# end class TaxpayerAddressItemType


class TaxpayerAddressListType(GeneratedsSuper):
    """TaxpayerAddressListType -- Adózói cím lista típus
    Taxpayer address_list list type
    taxpayerAddressItem -- Adózói címsor adat
    Taxpayer address_list item

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, taxpayerAddressItem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if taxpayerAddressItem is None:
            self.taxpayerAddressItem = []
        else:
            self.taxpayerAddressItem = taxpayerAddressItem
        self.taxpayerAddressItem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxpayerAddressListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxpayerAddressListType.subclass:
            return TaxpayerAddressListType.subclass(*args_, **kwargs_)
        else:
            return TaxpayerAddressListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_taxpayerAddressItem(self):
        return self.taxpayerAddressItem
    def set_taxpayerAddressItem(self, taxpayerAddressItem):
        self.taxpayerAddressItem = taxpayerAddressItem
    def add_taxpayerAddressItem(self, value):
        self.taxpayerAddressItem.append(value)
    def insert_taxpayerAddressItem_at(self, index, value):
        self.taxpayerAddressItem.insert(index, value)
    def replace_taxpayerAddressItem_at(self, index, value):
        self.taxpayerAddressItem[index] = value
    def _hasContent(self):
        if (
            self.taxpayerAddressItem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='TaxpayerAddressListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxpayerAddressListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxpayerAddressListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxpayerAddressListType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxpayerAddressListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxpayerAddressListType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='TaxpayerAddressListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for taxpayerAddressItem_ in self.taxpayerAddressItem:
            namespaceprefix_ = self.taxpayerAddressItem_nsprefix_ + ':' if (UseCapturedNS_ and self.taxpayerAddressItem_nsprefix_) else ''
            taxpayerAddressItem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taxpayerAddressItem', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TaxpayerAddressListType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        for taxpayerAddressItem_ in self.taxpayerAddressItem:
            taxpayerAddressItem_.to_etree(element, name_='taxpayerAddressItem', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TaxpayerAddressListType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('taxpayerAddressItem=[\n')
        level += 1
        for taxpayerAddressItem_ in self.taxpayerAddressItem:
            showIndent(outfile, level)
            outfile.write('model_.TaxpayerAddressItemType(\n')
            taxpayerAddressItem_.exportLiteral(outfile, level, name_='TaxpayerAddressItemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'taxpayerAddressItem':
            obj_ = TaxpayerAddressItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taxpayerAddressItem.append(obj_)
            obj_.original_tagname_ = 'taxpayerAddressItem'
# end class TaxpayerAddressListType


class TaxpayerDataType(GeneratedsSuper):
    """TaxpayerDataType -- Az ad
    ó
    z
    ó
    lek
    é
    rdez
    é
    s v
    á
    lasz adatai
    Response data of the taxpayer query
    taxpayerName -- Az ad
    ó
    z
    ó
    neve
    Name of the taxpayer
    taxpayerShortName -- Az ad
    ó
    z
    ó
    r
    ö
    vid
    í
    tett neve
    Shortened name of the taxpayer
    taxNumberDetail -- Az ad
    ó
    sz
    á
    m r
    é
    szletes adatai
    Detailed data of the tax number
    incorporation -- Gazdas
    á
    gi t
    í
    pus
    Incorporation type
    vatGroupMembership -- Az ad
    ó
    z
    ó
    Á
    FA csoport tags
    á
    ga
    VAT group membership of the taxpayer
    taxpayerAddressList -- Ad
    ó
    z
    ó
    i c
    í
    m lista t
    í
    pus
    Taxpayer address_list list type

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, taxpayerName=None, taxpayerShortName=None, taxNumberDetail=None, incorporation=None, vatGroupMembership=None, taxpayerAddressList=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.taxpayerName = taxpayerName
        self.validate_SimpleText512NotBlankType(self.taxpayerName)
        self.taxpayerName_nsprefix_ = "common"
        self.taxpayerShortName = taxpayerShortName
        self.validate_SimpleText200NotBlankType(self.taxpayerShortName)
        self.taxpayerShortName_nsprefix_ = "common"
        self.taxNumberDetail = taxNumberDetail
        self.taxNumberDetail_nsprefix_ = "base"
        self.incorporation = incorporation
        self.validate_IncorporationType(self.incorporation)
        self.incorporation_nsprefix_ = None
        self.vatGroupMembership = vatGroupMembership
        self.validate_TaxpayerIdType(self.vatGroupMembership)
        self.vatGroupMembership_nsprefix_ = "common"
        self.taxpayerAddressList = taxpayerAddressList
        self.taxpayerAddressList_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxpayerDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxpayerDataType.subclass:
            return TaxpayerDataType.subclass(*args_, **kwargs_)
        else:
            return TaxpayerDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_taxpayerName(self):
        return self.taxpayerName
    def set_taxpayerName(self, taxpayerName):
        self.taxpayerName = taxpayerName
    def get_taxpayerShortName(self):
        return self.taxpayerShortName
    def set_taxpayerShortName(self, taxpayerShortName):
        self.taxpayerShortName = taxpayerShortName
    def get_taxNumberDetail(self):
        return self.taxNumberDetail
    def set_taxNumberDetail(self, taxNumberDetail):
        self.taxNumberDetail = taxNumberDetail
    def get_incorporation(self):
        return self.incorporation
    def set_incorporation(self, incorporation):
        self.incorporation = incorporation
    def get_vatGroupMembership(self):
        return self.vatGroupMembership
    def set_vatGroupMembership(self, vatGroupMembership):
        self.vatGroupMembership = vatGroupMembership
    def get_taxpayerAddressList(self):
        return self.taxpayerAddressList
    def set_taxpayerAddressList(self, taxpayerAddressList):
        self.taxpayerAddressList = taxpayerAddressList
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText200NotBlankType(self, value):
        result = True
        # Validate type SimpleText200NotBlankType, a restriction on AtomicStringType200.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText200NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText200NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText200NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText200NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText200NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_IncorporationType(self, value):
        result = True
        # Validate type IncorporationType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['ORGANIZATION', 'SELF_EMPLOYED', 'TAXABLE_PERSON']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on IncorporationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IncorporationType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on IncorporationType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_TaxpayerIdType(self, value):
        result = True
        # Validate type TaxpayerIdType, a restriction on AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TaxpayerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TaxpayerIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TaxpayerIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TaxpayerIdType_patterns_, ))
                result = False
        return result
    validate_TaxpayerIdType_patterns_ = [['^([0-9]{8})$']]
    def _hasContent(self):
        if (
            self.taxpayerName is not None or
            self.taxpayerShortName is not None or
            self.taxNumberDetail is not None or
            self.incorporation is not None or
            self.vatGroupMembership is not None or
            self.taxpayerAddressList is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='TaxpayerDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxpayerDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TaxpayerDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxpayerDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxpayerDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxpayerDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='TaxpayerDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.taxpayerName is not None:
            namespaceprefix_ = self.taxpayerName_nsprefix_ + ':' if (UseCapturedNS_ and self.taxpayerName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxpayerName>%s</%staxpayerName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxpayerName), input_name='taxpayerName')), namespaceprefix_ , eol_))
        if self.taxpayerShortName is not None:
            namespaceprefix_ = self.taxpayerShortName_nsprefix_ + ':' if (UseCapturedNS_ and self.taxpayerShortName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxpayerShortName>%s</%staxpayerShortName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.taxpayerShortName), input_name='taxpayerShortName')), namespaceprefix_ , eol_))
        if self.taxNumberDetail is not None:
            namespaceprefix_ = self.taxNumberDetail_nsprefix_ + ':' if (UseCapturedNS_ and self.taxNumberDetail_nsprefix_) else ''
            self.taxNumberDetail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taxNumberDetail', pretty_print=pretty_print)
        if self.incorporation is not None:
            namespaceprefix_ = self.incorporation_nsprefix_ + ':' if (UseCapturedNS_ and self.incorporation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sincorporation>%s</%sincorporation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.incorporation), input_name='incorporation')), namespaceprefix_ , eol_))
        if self.vatGroupMembership is not None:
            namespaceprefix_ = self.vatGroupMembership_nsprefix_ + ':' if (UseCapturedNS_ and self.vatGroupMembership_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatGroupMembership>%s</%svatGroupMembership>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vatGroupMembership), input_name='vatGroupMembership')), namespaceprefix_ , eol_))
        if self.taxpayerAddressList is not None:
            namespaceprefix_ = self.taxpayerAddressList_nsprefix_ + ':' if (UseCapturedNS_ and self.taxpayerAddressList_nsprefix_) else ''
            self.taxpayerAddressList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taxpayerAddressList', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TaxpayerDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.taxpayerName is not None:
            taxpayerName_ = self.taxpayerName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}taxpayerName').text = self.gds_format_string(taxpayerName_)
        if self.taxpayerShortName is not None:
            taxpayerShortName_ = self.taxpayerShortName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}taxpayerShortName').text = self.gds_format_string(taxpayerShortName_)
        if self.taxNumberDetail is not None:
            taxNumberDetail_ = self.taxNumberDetail
            taxNumberDetail_.to_etree(element, name_='taxNumberDetail', mapping_=mapping_, nsmap_=nsmap_)
        if self.incorporation is not None:
            incorporation_ = self.incorporation
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}incorporation').text = self.gds_format_string(incorporation_)
        if self.vatGroupMembership is not None:
            vatGroupMembership_ = self.vatGroupMembership
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}vatGroupMembership').text = self.gds_format_string(vatGroupMembership_)
        if self.taxpayerAddressList is not None:
            taxpayerAddressList_ = self.taxpayerAddressList
            taxpayerAddressList_.to_etree(element, name_='taxpayerAddressList', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TaxpayerDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.taxpayerName is not None:
            showIndent(outfile, level)
            outfile.write('taxpayerName=%s,\n' % self.gds_encode(quote_python(self.taxpayerName)))
        if self.taxpayerShortName is not None:
            showIndent(outfile, level)
            outfile.write('taxpayerShortName=%s,\n' % self.gds_encode(quote_python(self.taxpayerShortName)))
        if self.taxNumberDetail is not None:
            showIndent(outfile, level)
            outfile.write('taxNumberDetail=model_.TaxNumberType(\n')
            self.taxNumberDetail.exportLiteral(outfile, level, name_='taxNumberDetail')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.incorporation is not None:
            showIndent(outfile, level)
            outfile.write('incorporation=%s,\n' % self.gds_encode(quote_python(self.incorporation)))
        if self.vatGroupMembership is not None:
            showIndent(outfile, level)
            outfile.write('vatGroupMembership=%s,\n' % self.gds_encode(quote_python(self.vatGroupMembership)))
        if self.taxpayerAddressList is not None:
            showIndent(outfile, level)
            outfile.write('taxpayerAddressList=model_.TaxpayerAddressListType(\n')
            self.taxpayerAddressList.exportLiteral(outfile, level, name_='taxpayerAddressList')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'taxpayerName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxpayerName')
            value_ = self.gds_validate_string(value_, node, 'taxpayerName')
            self.taxpayerName = value_
            self.taxpayerName_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.taxpayerName)
        elif nodeName_ == 'taxpayerShortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'taxpayerShortName')
            value_ = self.gds_validate_string(value_, node, 'taxpayerShortName')
            self.taxpayerShortName = value_
            self.taxpayerShortName_nsprefix_ = child_.prefix
            # validate type SimpleText200NotBlankType
            self.validate_SimpleText200NotBlankType(self.taxpayerShortName)
        elif nodeName_ == 'taxNumberDetail':
            class_obj_ = self.get_class_obj_(child_, TaxNumberType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taxNumberDetail = obj_
            obj_.original_tagname_ = 'taxNumberDetail'
        elif nodeName_ == 'incorporation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'incorporation')
            value_ = self.gds_validate_string(value_, node, 'incorporation')
            self.incorporation = value_
            self.incorporation_nsprefix_ = child_.prefix
            # validate type IncorporationType
            self.validate_IncorporationType(self.incorporation)
        elif nodeName_ == 'vatGroupMembership':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vatGroupMembership')
            value_ = self.gds_validate_string(value_, node, 'vatGroupMembership')
            self.vatGroupMembership = value_
            self.vatGroupMembership_nsprefix_ = child_.prefix
            # validate type TaxpayerIdType
            self.validate_TaxpayerIdType(self.vatGroupMembership)
        elif nodeName_ == 'taxpayerAddressList':
            obj_ = TaxpayerAddressListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taxpayerAddressList = obj_
            obj_.original_tagname_ = 'taxpayerAddressList'
# end class TaxpayerDataType


class TokenExchangeResponseType(BasicOnlineInvoiceResponseType):
    """TokenExchangeResponseType -- A POST /tokenExchange REST operáció válasz típusa
    Response type of the POST /tokenExchange REST operation
    encodedExchangeToken -- A kiadott exchange token AES-128 ECB algoritmussal kódolt alakja
    The issued exchange token in AES-128 ECB encoded form
    tokenValidityFrom -- A kiadott token érvényességének kezdete
    Validity start of the issued exchange token
    tokenValidityTo -- A kiadott token érvényességének vége
    Validity end of the issued exchange token

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceResponseType
    def __init__(self, header=None, result=None, software=None, encodedExchangeToken=None, tokenValidityFrom=None, tokenValidityTo=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TokenExchangeResponseType"), self).__init__(header, result, software, extensiontype_,  **kwargs_)
        self.encodedExchangeToken = encodedExchangeToken
        self.encodedExchangeToken_nsprefix_ = "xs"
        if isinstance(tokenValidityFrom, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(tokenValidityFrom, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = tokenValidityFrom
        self.tokenValidityFrom = initvalue_
        self.tokenValidityFrom_nsprefix_ = "base"
        if isinstance(tokenValidityTo, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(tokenValidityTo, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = tokenValidityTo
        self.tokenValidityTo = initvalue_
        self.tokenValidityTo_nsprefix_ = "base"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TokenExchangeResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TokenExchangeResponseType.subclass:
            return TokenExchangeResponseType.subclass(*args_, **kwargs_)
        else:
            return TokenExchangeResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_encodedExchangeToken(self):
        return self.encodedExchangeToken
    def set_encodedExchangeToken(self, encodedExchangeToken):
        self.encodedExchangeToken = encodedExchangeToken
    def get_tokenValidityFrom(self):
        return self.tokenValidityFrom
    def set_tokenValidityFrom(self, tokenValidityFrom):
        self.tokenValidityFrom = tokenValidityFrom
    def get_tokenValidityTo(self):
        return self.tokenValidityTo
    def set_tokenValidityTo(self, tokenValidityTo):
        self.tokenValidityTo = tokenValidityTo
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.fromisoformat('2010-01-01T00:00:00.000000').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
            if not isinstance(value, datetime.datetime):
                result = False
            else:
                iso_format = value.isoformat()[:-9]+"Z"
                if not self.gds_validate_simple_patterns(
                       self.validate_InvoiceTimestampType_patterns_, iso_format):
                    self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (iso_format, self.validate_InvoiceTimestampType_patterns_, ))
                    result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def _hasContent(self):
        if (
            self.encodedExchangeToken is not None or
            self.tokenValidityFrom is not None or
            self.tokenValidityTo is not None or
            super(TokenExchangeResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='TokenExchangeResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TokenExchangeResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TokenExchangeResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TokenExchangeResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TokenExchangeResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TokenExchangeResponseType'):
        super(TokenExchangeResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TokenExchangeResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='TokenExchangeResponseType', fromsubclass_=False, pretty_print=True):
        super(TokenExchangeResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.encodedExchangeToken is not None:
            namespaceprefix_ = self.encodedExchangeToken_nsprefix_ + ':' if (UseCapturedNS_ and self.encodedExchangeToken_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sencodedExchangeToken>%s</%sencodedExchangeToken>%s' % (namespaceprefix_ , self.gds_format_base64(self.encodedExchangeToken, input_name='encodedExchangeToken'), namespaceprefix_ , eol_))
        if self.tokenValidityFrom is not None:
            namespaceprefix_ = self.tokenValidityFrom_nsprefix_ + ':' if (UseCapturedNS_ and self.tokenValidityFrom_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stokenValidityFrom>%s</%stokenValidityFrom>%s' % (namespaceprefix_ , self.gds_format_datetime(self.tokenValidityFrom, input_name='tokenValidityFrom'), namespaceprefix_ , eol_))
        if self.tokenValidityTo is not None:
            namespaceprefix_ = self.tokenValidityTo_nsprefix_ + ':' if (UseCapturedNS_ and self.tokenValidityTo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stokenValidityTo>%s</%stokenValidityTo>%s' % (namespaceprefix_ , self.gds_format_datetime(self.tokenValidityTo, input_name='tokenValidityTo'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='TokenExchangeResponseType', mapping_=None, nsmap_=None):
        element = super(TokenExchangeResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.encodedExchangeToken is not None:
            encodedExchangeToken_ = self.encodedExchangeToken
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}encodedExchangeToken').text = self.gds_format_base64(encodedExchangeToken_)
        if self.tokenValidityFrom is not None:
            tokenValidityFrom_ = self.tokenValidityFrom
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}tokenValidityFrom').text = self.gds_format_datetime(tokenValidityFrom_)
        if self.tokenValidityTo is not None:
            tokenValidityTo_ = self.tokenValidityTo
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}tokenValidityTo').text = self.gds_format_datetime(tokenValidityTo_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TokenExchangeResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TokenExchangeResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(TokenExchangeResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.encodedExchangeToken is not None:
            showIndent(outfile, level)
            outfile.write('encodedExchangeToken=model_.base64Binary(\n')
            self.encodedExchangeToken.exportLiteral(outfile, level, name_='encodedExchangeToken')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tokenValidityFrom is not None:
            showIndent(outfile, level)
            outfile.write('tokenValidityFrom=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.tokenValidityFrom, input_name='tokenValidityFrom'))
        if self.tokenValidityTo is not None:
            showIndent(outfile, level)
            outfile.write('tokenValidityTo=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.tokenValidityTo, input_name='tokenValidityTo'))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TokenExchangeResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'encodedExchangeToken':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'encodedExchangeToken')
            else:
                bval_ = None
            self.encodedExchangeToken = bval_
            self.encodedExchangeToken_nsprefix_ = child_.prefix
        elif nodeName_ == 'tokenValidityFrom':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.tokenValidityFrom = dval_
            self.tokenValidityFrom_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.tokenValidityFrom)
        elif nodeName_ == 'tokenValidityTo':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.tokenValidityTo = dval_
            self.tokenValidityTo_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.tokenValidityTo)
        super(TokenExchangeResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class TokenExchangeResponseType


class TransactionListResultType(GeneratedsSuper):
    """TransactionListResultType -- Tranzakció
    lek
    é
    rdez
    é
    si eredm
    é
    nyei
    Transaction query results
    currentPage -- A jelenleg lek
    é
    rdezett lapsz
    á
    m
    The currently queried page count
    availablePage -- A lek
    é
    rdez
    é
    s eredm
    é
    nye szerint el
    é
    rhet
    ő
    utols
    ó
    lapsz
    á
    m
    The highest available page count matching the query
    transaction -- Tranzakci
    ó
    lek
    é
    rdez
    é
    si eredm
    é
    ny
    Transaction query result

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, currentPage=None, availablePage=None, transaction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currentPage = currentPage
        self.validate_ResponsePageType(self.currentPage)
        self.currentPage_nsprefix_ = "common"
        self.availablePage = availablePage
        self.validate_ResponsePageType(self.availablePage)
        self.availablePage_nsprefix_ = "common"
        if transaction is None:
            self.transaction = []
        else:
            self.transaction = transaction
        self.transaction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransactionListResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransactionListResultType.subclass:
            return TransactionListResultType.subclass(*args_, **kwargs_)
        else:
            return TransactionListResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_currentPage(self):
        return self.currentPage
    def set_currentPage(self, currentPage):
        self.currentPage = currentPage
    def get_availablePage(self):
        return self.availablePage
    def set_availablePage(self, availablePage):
        self.availablePage = availablePage
    def get_transaction(self):
        return self.transaction
    def set_transaction(self, transaction):
        self.transaction = transaction
    def add_transaction(self, value):
        self.transaction.append(value)
    def insert_transaction_at(self, index, value):
        self.transaction.insert(index, value)
    def replace_transaction_at(self, index, value):
        self.transaction[index] = value
    def validate_ResponsePageType(self, value):
        result = True
        # Validate type ResponsePageType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ResponsePageType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.currentPage is not None or
            self.availablePage is not None or
            self.transaction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='TransactionListResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransactionListResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransactionListResultType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransactionListResultType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransactionListResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TransactionListResultType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='TransactionListResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currentPage is not None:
            namespaceprefix_ = self.currentPage_nsprefix_ + ':' if (UseCapturedNS_ and self.currentPage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentPage>%s</%scurrentPage>%s' % (namespaceprefix_ , self.gds_format_integer(self.currentPage, input_name='currentPage'), namespaceprefix_ , eol_))
        if self.availablePage is not None:
            namespaceprefix_ = self.availablePage_nsprefix_ + ':' if (UseCapturedNS_ and self.availablePage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailablePage>%s</%savailablePage>%s' % (namespaceprefix_ , self.gds_format_integer(self.availablePage, input_name='availablePage'), namespaceprefix_ , eol_))
        for transaction_ in self.transaction:
            namespaceprefix_ = self.transaction_nsprefix_ + ':' if (UseCapturedNS_ and self.transaction_nsprefix_) else ''
            transaction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transaction', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TransactionListResultType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.currentPage is not None:
            currentPage_ = self.currentPage
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}currentPage').text = self.gds_format_integer(currentPage_)
        if self.availablePage is not None:
            availablePage_ = self.availablePage
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}availablePage').text = self.gds_format_integer(availablePage_)
        for transaction_ in self.transaction:
            transaction_.to_etree(element, name_='transaction', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TransactionListResultType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.currentPage is not None:
            showIndent(outfile, level)
            outfile.write('currentPage=%d,\n' % self.currentPage)
        if self.availablePage is not None:
            showIndent(outfile, level)
            outfile.write('availablePage=%d,\n' % self.availablePage)
        showIndent(outfile, level)
        outfile.write('transaction=[\n')
        level += 1
        for transaction_ in self.transaction:
            showIndent(outfile, level)
            outfile.write('model_.TransactionType(\n')
            transaction_.exportLiteral(outfile, level, name_='TransactionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currentPage' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'currentPage')
            ival_ = self.gds_validate_integer(ival_, node, 'currentPage')
            self.currentPage = ival_
            self.currentPage_nsprefix_ = child_.prefix
            # validate type ResponsePageType
            self.validate_ResponsePageType(self.currentPage)
        elif nodeName_ == 'availablePage' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'availablePage')
            ival_ = self.gds_validate_integer(ival_, node, 'availablePage')
            self.availablePage = ival_
            self.availablePage_nsprefix_ = child_.prefix
            # validate type ResponsePageType
            self.validate_ResponsePageType(self.availablePage)
        elif nodeName_ == 'transaction':
            obj_ = TransactionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transaction.append(obj_)
            obj_.original_tagname_ = 'transaction'
# end class TransactionListResultType


class TransactionQueryParamsType(GeneratedsSuper):
    """TransactionQueryParamsType -- A sz
    á
    mla lek
    é
    rdez
    é
    s tranzakci
    ó
    s param
    é
    terei
    Transactional params of the invoice query
    transactionId -- Az adatszolg
    á
    ltat
    á
    s tranzakci
    ó
    azonos
    í
    t
    ó
    ja
    Transaction identifier of the data exchange
    index -- A sz
    á
    mla sorsz
    á
    ma a k
    é
    r
    é
    sen bel
    ü
    l
    Sequence number of the invoice within the request
    invoiceOperation -- Sz
    á
    mlam
    ű
    velet t
    í
    pus
    Invoice operation type

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, transactionId=None, index=None, invoiceOperation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.transactionId = transactionId
        self.validate_EntityIdType(self.transactionId)
        self.transactionId_nsprefix_ = "common"
        self.index = index
        self.validate_InvoiceIndexType(self.index)
        self.index_nsprefix_ = "base"
        self.invoiceOperation = invoiceOperation
        self.validate_ManageInvoiceOperationType(self.invoiceOperation)
        self.invoiceOperation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransactionQueryParamsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransactionQueryParamsType.subclass:
            return TransactionQueryParamsType.subclass(*args_, **kwargs_)
        else:
            return TransactionQueryParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_transactionId(self):
        return self.transactionId
    def set_transactionId(self, transactionId):
        self.transactionId = transactionId
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_invoiceOperation(self):
        return self.invoiceOperation
    def set_invoiceOperation(self, invoiceOperation):
        self.invoiceOperation = invoiceOperation
    def validate_EntityIdType(self, value):
        result = True
        # Validate type EntityIdType, a restriction on AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityIdType_patterns_, ))
                result = False
        return result
    validate_EntityIdType_patterns_ = [['^([+a-zA-Z0-9_]{1,30})$']]
    def validate_InvoiceIndexType(self, value):
        result = True
        # Validate type InvoiceIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ManageInvoiceOperationType(self, value):
        result = True
        # Validate type ManageInvoiceOperationType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['CREATE', 'MODIFY', 'STORNO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ManageInvoiceOperationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ManageInvoiceOperationType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ManageInvoiceOperationType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.transactionId is not None or
            self.index is not None or
            self.invoiceOperation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='TransactionQueryParamsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransactionQueryParamsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransactionQueryParamsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransactionQueryParamsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransactionQueryParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TransactionQueryParamsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='TransactionQueryParamsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transactionId is not None:
            namespaceprefix_ = self.transactionId_nsprefix_ + ':' if (UseCapturedNS_ and self.transactionId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransactionId>%s</%stransactionId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.transactionId), input_name='transactionId')), namespaceprefix_ , eol_))
        if self.index is not None:
            namespaceprefix_ = self.index_nsprefix_ + ':' if (UseCapturedNS_ and self.index_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindex>%s</%sindex>%s' % (namespaceprefix_ , self.gds_format_integer(self.index, input_name='index'), namespaceprefix_ , eol_))
        if self.invoiceOperation is not None:
            namespaceprefix_ = self.invoiceOperation_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceOperation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceOperation>%s</%sinvoiceOperation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceOperation), input_name='invoiceOperation')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='TransactionQueryParamsType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.transactionId is not None:
            transactionId_ = self.transactionId
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}transactionId').text = self.gds_format_string(transactionId_)
        if self.index is not None:
            index_ = self.index
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}index').text = self.gds_format_integer(index_)
        if self.invoiceOperation is not None:
            invoiceOperation_ = self.invoiceOperation
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}invoiceOperation').text = self.gds_format_string(invoiceOperation_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TransactionQueryParamsType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.transactionId is not None:
            showIndent(outfile, level)
            outfile.write('transactionId=%s,\n' % self.gds_encode(quote_python(self.transactionId)))
        if self.index is not None:
            showIndent(outfile, level)
            outfile.write('index=%d,\n' % self.index)
        if self.invoiceOperation is not None:
            showIndent(outfile, level)
            outfile.write('invoiceOperation=%s,\n' % self.gds_encode(quote_python(self.invoiceOperation)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'transactionId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'transactionId')
            value_ = self.gds_validate_string(value_, node, 'transactionId')
            self.transactionId = value_
            self.transactionId_nsprefix_ = child_.prefix
            # validate type EntityIdType
            self.validate_EntityIdType(self.transactionId)
        elif nodeName_ == 'index' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'index')
            ival_ = self.gds_validate_integer(ival_, node, 'index')
            self.index = ival_
            self.index_nsprefix_ = child_.prefix
            # validate type InvoiceIndexType
            self.validate_InvoiceIndexType(self.index)
        elif nodeName_ == 'invoiceOperation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceOperation')
            value_ = self.gds_validate_string(value_, node, 'invoiceOperation')
            self.invoiceOperation = value_
            self.invoiceOperation_nsprefix_ = child_.prefix
            # validate type ManageInvoiceOperationType
            self.validate_ManageInvoiceOperationType(self.invoiceOperation)
# end class TransactionQueryParamsType


class TransactionResponseType(BasicOnlineInvoiceResponseType):
    """TransactionResponseType -- A POST /manageInvoice
    é
    s a POST /manageAnnulment REST oper
    á
    ci
    ó
    k
    ö
    z
    ö
    s v
    á
    lasz t
    í
    pusa
    Common response type of the POST /manageInvoice and the POST /manageAnnulment REST operation
    transactionId -- A k
    é
    rt oper
    á
    ci
    ó
    tranzakci
    ó
    azonos
    í
    t
    ó
    ja
    Transaction identifier of the requested operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceResponseType
    def __init__(self, header=None, result=None, software=None, transactionId=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TransactionResponseType"), self).__init__(header, result, software, extensiontype_,  **kwargs_)
        self.transactionId = transactionId
        self.validate_EntityIdType(self.transactionId)
        self.transactionId_nsprefix_ = "common"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransactionResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransactionResponseType.subclass:
            return TransactionResponseType.subclass(*args_, **kwargs_)
        else:
            return TransactionResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_transactionId(self):
        return self.transactionId
    def set_transactionId(self, transactionId):
        self.transactionId = transactionId
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_EntityIdType(self, value):
        result = True
        # Validate type EntityIdType, a restriction on AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityIdType_patterns_, ))
                result = False
        return result
    validate_EntityIdType_patterns_ = [['^([+a-zA-Z0-9_]{1,30})$']]
    def _hasContent(self):
        if (
            self.transactionId is not None or
            super(TransactionResponseType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='TransactionResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransactionResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransactionResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransactionResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransactionResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TransactionResponseType'):
        super(TransactionResponseType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransactionResponseType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='TransactionResponseType', fromsubclass_=False, pretty_print=True):
        super(TransactionResponseType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transactionId is not None:
            namespaceprefix_ = self.transactionId_nsprefix_ + ':' if (UseCapturedNS_ and self.transactionId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransactionId>%s</%stransactionId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.transactionId), input_name='transactionId')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='TransactionResponseType', mapping_=None, nsmap_=None):
        element = super(TransactionResponseType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.transactionId is not None:
            transactionId_ = self.transactionId
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}transactionId').text = self.gds_format_string(transactionId_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TransactionResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TransactionResponseType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(TransactionResponseType, self)._exportLiteralChildren(outfile, level, name_)
        if self.transactionId is not None:
            showIndent(outfile, level)
            outfile.write('transactionId=%s,\n' % self.gds_encode(quote_python(self.transactionId)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TransactionResponseType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'transactionId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'transactionId')
            value_ = self.gds_validate_string(value_, node, 'transactionId')
            self.transactionId = value_
            self.transactionId_nsprefix_ = child_.prefix
            # validate type EntityIdType
            self.validate_EntityIdType(self.transactionId)
        super(TransactionResponseType, self)._buildChildren(child_, node, nodeName_, True)
# end class TransactionResponseType


class TransactionType(GeneratedsSuper):
    """TransactionType -- Tranzakci
    ó
    lek
    é
    rdez
    é
    si eredm
    é
    ny
    Transaction query result
    insDate -- A besz
    ú
    r
    á
    s id
    ő
    pontja UTC id
    ő
    ben
    Insert date in UTC time
    insCusUser -- A besz
    ú
    r
    á
    st v
    é
    gz
    ő
    felhaszn
    á
    l
    ó
    Inserting user name
    source -- Az adatszolg
    á
    ltat
    á
    s forr
    á
    sa
    Data exchange source
    transactionId -- A sz
    á
    mla tranzakci
    ó
    azonos
    í
    t
    ó
    ja
    Transaction ID of the invoice
    requestStatus -- A k
    é
    r
    é
    s feldolgoz
    á
    si st
    á
    tusza
    Processing status of the request
    technicalAnnulment -- Jel
    ö
    li ha a tranzakci
    ó
    technikai
    é
    rv
    é
    nytelen
    í
    t
    é
    st tartalmaz
    Indicates whether the transaction contains technical annulment
    originalRequestVersion -- Az adatszolg
    á
    ltat
    á
    s requestVersion
    é
    rt
    é
    ke
    requestVersion value of the invoice exchange
    itemCount -- Az adatszolg
    á
    ltat
    á
    s t
    é
    teleinek sz
    á
    ma
    Item count of the invoiceExchange

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, insDate=None, insCusUser=None, source=None, transactionId=None, requestStatus=None, technicalAnnulment=None, originalRequestVersion=None, itemCount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(insDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(insDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = insDate
        self.insDate = initvalue_
        self.insDate_nsprefix_ = "base"
        self.insCusUser = insCusUser
        self.validate_LoginType(self.insCusUser)
        self.insCusUser_nsprefix_ = "common"
        self.source = source
        self.validate_SourceType(self.source)
        self.source_nsprefix_ = None
        self.transactionId = transactionId
        self.validate_EntityIdType(self.transactionId)
        self.transactionId_nsprefix_ = "common"
        self.requestStatus = requestStatus
        self.validate_RequestStatusType(self.requestStatus)
        self.requestStatus_nsprefix_ = None
        self.technicalAnnulment = technicalAnnulment
        self.technicalAnnulment_nsprefix_ = "xs"
        self.originalRequestVersion = originalRequestVersion
        self.validate_OriginalRequestVersionType(self.originalRequestVersion)
        self.originalRequestVersion_nsprefix_ = None
        self.itemCount = itemCount
        self.validate_InvoiceIndexType(self.itemCount)
        self.itemCount_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransactionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransactionType.subclass:
            return TransactionType.subclass(*args_, **kwargs_)
        else:
            return TransactionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_insDate(self):
        return self.insDate
    def set_insDate(self, insDate):
        self.insDate = insDate
    def get_insCusUser(self):
        return self.insCusUser
    def set_insCusUser(self, insCusUser):
        self.insCusUser = insCusUser
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_transactionId(self):
        return self.transactionId
    def set_transactionId(self, transactionId):
        self.transactionId = transactionId
    def get_requestStatus(self):
        return self.requestStatus
    def set_requestStatus(self, requestStatus):
        self.requestStatus = requestStatus
    def get_technicalAnnulment(self):
        return self.technicalAnnulment
    def set_technicalAnnulment(self, technicalAnnulment):
        self.technicalAnnulment = technicalAnnulment
    def get_originalRequestVersion(self):
        return self.originalRequestVersion
    def set_originalRequestVersion(self, originalRequestVersion):
        self.originalRequestVersion = originalRequestVersion
    def get_itemCount(self):
        return self.itemCount
    def set_itemCount(self, itemCount):
        self.itemCount = itemCount
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.fromisostring('2010-01-01T00:00:00.000000').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceTimestampType_patterns_, ))
                result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def validate_LoginType(self, value):
        result = True
        # Validate type LoginType, a restriction on AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LoginType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 6:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LoginType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LoginType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LoginType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_LoginType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_LoginType_patterns_, ))
                result = False
        return result
    validate_LoginType_patterns_ = [['^([a-zA-Z0-9]{6,15})$']]
    def validate_SourceType(self, value):
        result = True
        # Validate type SourceType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['WEB', 'XML', 'MGM', 'OPG', 'OSZ']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SourceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SourceType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SourceType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_EntityIdType(self, value):
        result = True
        # Validate type EntityIdType, a restriction on AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EntityIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EntityIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EntityIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EntityIdType_patterns_, ))
                result = False
        return result
    validate_EntityIdType_patterns_ = [['^([+a-zA-Z0-9_]{1,30})$']]
    def validate_RequestStatusType(self, value):
        result = True
        # Validate type RequestStatusType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['RECEIVED', 'PROCESSING', 'SAVED', 'FINISHED', 'NOTIFIED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RequestStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on RequestStatusType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on RequestStatusType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_OriginalRequestVersionType(self, value):
        result = True
        # Validate type OriginalRequestVersionType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['1.0', '1.1', '2.0', '3.0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OriginalRequestVersionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on OriginalRequestVersionType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on OriginalRequestVersionType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceIndexType(self, value):
        result = True
        # Validate type InvoiceIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on InvoiceIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.insDate is not None or
            self.insCusUser is not None or
            self.source is not None or
            self.transactionId is not None or
            self.requestStatus is not None or
            self.technicalAnnulment is not None or
            self.originalRequestVersion is not None or
            self.itemCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='TransactionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransactionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransactionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransactionType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransactionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TransactionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='TransactionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.insDate is not None:
            namespaceprefix_ = self.insDate_nsprefix_ + ':' if (UseCapturedNS_ and self.insDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinsDate>%s</%sinsDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.insDate, input_name='insDate'), namespaceprefix_ , eol_))
        if self.insCusUser is not None:
            namespaceprefix_ = self.insCusUser_nsprefix_ + ':' if (UseCapturedNS_ and self.insCusUser_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinsCusUser>%s</%sinsCusUser>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.insCusUser), input_name='insCusUser')), namespaceprefix_ , eol_))
        if self.source is not None:
            namespaceprefix_ = self.source_nsprefix_ + ':' if (UseCapturedNS_ and self.source_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespaceprefix_ , eol_))
        if self.transactionId is not None:
            namespaceprefix_ = self.transactionId_nsprefix_ + ':' if (UseCapturedNS_ and self.transactionId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransactionId>%s</%stransactionId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.transactionId), input_name='transactionId')), namespaceprefix_ , eol_))
        if self.requestStatus is not None:
            namespaceprefix_ = self.requestStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.requestStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequestStatus>%s</%srequestStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.requestStatus), input_name='requestStatus')), namespaceprefix_ , eol_))
        if self.technicalAnnulment is not None:
            namespaceprefix_ = self.technicalAnnulment_nsprefix_ + ':' if (UseCapturedNS_ and self.technicalAnnulment_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stechnicalAnnulment>%s</%stechnicalAnnulment>%s' % (namespaceprefix_ , self.gds_format_boolean(self.technicalAnnulment, input_name='technicalAnnulment'), namespaceprefix_ , eol_))
        if self.originalRequestVersion is not None:
            namespaceprefix_ = self.originalRequestVersion_nsprefix_ + ':' if (UseCapturedNS_ and self.originalRequestVersion_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalRequestVersion>%s</%soriginalRequestVersion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originalRequestVersion), input_name='originalRequestVersion')), namespaceprefix_ , eol_))
        if self.itemCount is not None:
            namespaceprefix_ = self.itemCount_nsprefix_ + ':' if (UseCapturedNS_ and self.itemCount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sitemCount>%s</%sitemCount>%s' % (namespaceprefix_ , self.gds_format_integer(self.itemCount, input_name='itemCount'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='TransactionType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/api}' + name_, nsmap=nsmap_)
        if self.insDate is not None:
            insDate_ = self.insDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}insDate').text = self.gds_format_datetime(insDate_)
        if self.insCusUser is not None:
            insCusUser_ = self.insCusUser
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}insCusUser').text = self.gds_format_string(insCusUser_)
        if self.source is not None:
            source_ = self.source
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}source').text = self.gds_format_string(source_)
        if self.transactionId is not None:
            transactionId_ = self.transactionId
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}transactionId').text = self.gds_format_string(transactionId_)
        if self.requestStatus is not None:
            requestStatus_ = self.requestStatus
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}requestStatus').text = self.gds_format_string(requestStatus_)
        if self.technicalAnnulment is not None:
            technicalAnnulment_ = self.technicalAnnulment
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}technicalAnnulment').text = self.gds_format_boolean(technicalAnnulment_)
        if self.originalRequestVersion is not None:
            originalRequestVersion_ = self.originalRequestVersion
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}originalRequestVersion').text = self.gds_format_string(originalRequestVersion_)
        if self.itemCount is not None:
            itemCount_ = self.itemCount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/api}itemCount').text = self.gds_format_integer(itemCount_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TransactionType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.insDate is not None:
            showIndent(outfile, level)
            outfile.write('insDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.insDate, input_name='insDate'))
        if self.insCusUser is not None:
            showIndent(outfile, level)
            outfile.write('insCusUser=%s,\n' % self.gds_encode(quote_python(self.insCusUser)))
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=%s,\n' % self.gds_encode(quote_python(self.source)))
        if self.transactionId is not None:
            showIndent(outfile, level)
            outfile.write('transactionId=%s,\n' % self.gds_encode(quote_python(self.transactionId)))
        if self.requestStatus is not None:
            showIndent(outfile, level)
            outfile.write('requestStatus=%s,\n' % self.gds_encode(quote_python(self.requestStatus)))
        if self.technicalAnnulment is not None:
            showIndent(outfile, level)
            outfile.write('technicalAnnulment=%s,\n' % self.technicalAnnulment)
        if self.originalRequestVersion is not None:
            showIndent(outfile, level)
            outfile.write('originalRequestVersion=%s,\n' % self.gds_encode(quote_python(self.originalRequestVersion)))
        if self.itemCount is not None:
            showIndent(outfile, level)
            outfile.write('itemCount=%d,\n' % self.itemCount)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'insDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.insDate = dval_
            self.insDate_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.insDate)
        elif nodeName_ == 'insCusUser':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'insCusUser')
            value_ = self.gds_validate_string(value_, node, 'insCusUser')
            self.insCusUser = value_
            self.insCusUser_nsprefix_ = child_.prefix
            # validate type LoginType
            self.validate_LoginType(self.insCusUser)
        elif nodeName_ == 'source':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'source')
            value_ = self.gds_validate_string(value_, node, 'source')
            self.source = value_
            self.source_nsprefix_ = child_.prefix
            # validate type SourceType
            self.validate_SourceType(self.source)
        elif nodeName_ == 'transactionId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'transactionId')
            value_ = self.gds_validate_string(value_, node, 'transactionId')
            self.transactionId = value_
            self.transactionId_nsprefix_ = child_.prefix
            # validate type EntityIdType
            self.validate_EntityIdType(self.transactionId)
        elif nodeName_ == 'requestStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'requestStatus')
            value_ = self.gds_validate_string(value_, node, 'requestStatus')
            self.requestStatus = value_
            self.requestStatus_nsprefix_ = child_.prefix
            # validate type RequestStatusType
            self.validate_RequestStatusType(self.requestStatus)
        elif nodeName_ == 'technicalAnnulment':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'technicalAnnulment')
            ival_ = self.gds_validate_boolean(ival_, node, 'technicalAnnulment')
            self.technicalAnnulment = ival_
            self.technicalAnnulment_nsprefix_ = child_.prefix
        elif nodeName_ == 'originalRequestVersion':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originalRequestVersion')
            value_ = self.gds_validate_string(value_, node, 'originalRequestVersion')
            self.originalRequestVersion = value_
            self.originalRequestVersion_nsprefix_ = child_.prefix
            # validate type OriginalRequestVersionType
            self.validate_OriginalRequestVersionType(self.originalRequestVersion)
        elif nodeName_ == 'itemCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'itemCount')
            ival_ = self.gds_validate_integer(ival_, node, 'itemCount')
            self.itemCount = ival_
            self.itemCount_nsprefix_ = child_.prefix
            # validate type InvoiceIndexType
            self.validate_InvoiceIndexType(self.itemCount)
# end class TransactionType


class GeneralErrorResponse(GeneralErrorResponseType):
    """GeneralErrorResponse -- Online Sz
    á
    mla rendszerre specifikus
    á
    ltal
    á
    nos hibav
    á
    lasz
    Online Invoice specific general error response

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = GeneralErrorResponseType
    def __init__(self, header=None, result=None, software=None, technicalValidationMessages=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("GeneralErrorResponse"), self).__init__(header, result, software, technicalValidationMessages,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralErrorResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralErrorResponse.subclass:
            return GeneralErrorResponse.subclass(*args_, **kwargs_)
        else:
            return GeneralErrorResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(GeneralErrorResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='GeneralErrorResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralErrorResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeneralErrorResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralErrorResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeneralErrorResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeneralErrorResponse'):
        super(GeneralErrorResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralErrorResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='GeneralErrorResponse', fromsubclass_=False, pretty_print=True):
        super(GeneralErrorResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GeneralErrorResponse', mapping_=None, nsmap_=None):
        element = super(GeneralErrorResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='GeneralErrorResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GeneralErrorResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(GeneralErrorResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(GeneralErrorResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(GeneralErrorResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class GeneralErrorResponse


class ManageAnnulmentRequest(ManageAnnulmentRequestType):
    """ManageAnnulmentRequest -- A POST /manageAnnulment REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s
    é
    nek root elementje
    Request root element of the POST /manageAnnulment REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ManageAnnulmentRequestType
    def __init__(self, header=None, user=None, software=None, exchangeToken=None, annulmentOperations=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ManageAnnulmentRequest"), self).__init__(header, user, software, exchangeToken, annulmentOperations,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManageAnnulmentRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManageAnnulmentRequest.subclass:
            return ManageAnnulmentRequest.subclass(*args_, **kwargs_)
        else:
            return ManageAnnulmentRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ManageAnnulmentRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='ManageAnnulmentRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ManageAnnulmentRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ManageAnnulmentRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageAnnulmentRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ManageAnnulmentRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ManageAnnulmentRequest'):
        super(ManageAnnulmentRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageAnnulmentRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='ManageAnnulmentRequest', fromsubclass_=False, pretty_print=True):
        super(ManageAnnulmentRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ManageAnnulmentRequest', mapping_=None, nsmap_=None):
        element = super(ManageAnnulmentRequest, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ManageAnnulmentRequest'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ManageAnnulmentRequest, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(ManageAnnulmentRequest, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ManageAnnulmentRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ManageAnnulmentRequest, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ManageAnnulmentRequest


class ManageAnnulmentResponse(TransactionResponseType):
    """ManageAnnulmentResponse -- A POST /manageAnnulment REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the POST /manageAnnulment REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TransactionResponseType
    def __init__(self, header=None, result=None, software=None, transactionId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ManageAnnulmentResponse"), self).__init__(header, result, software, transactionId,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManageAnnulmentResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManageAnnulmentResponse.subclass:
            return ManageAnnulmentResponse.subclass(*args_, **kwargs_)
        else:
            return ManageAnnulmentResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ManageAnnulmentResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='ManageAnnulmentResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ManageAnnulmentResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ManageAnnulmentResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageAnnulmentResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ManageAnnulmentResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ManageAnnulmentResponse'):
        super(ManageAnnulmentResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageAnnulmentResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='ManageAnnulmentResponse', fromsubclass_=False, pretty_print=True):
        super(ManageAnnulmentResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ManageAnnulmentResponse', mapping_=None, nsmap_=None):
        element = super(ManageAnnulmentResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ManageAnnulmentResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ManageAnnulmentResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(ManageAnnulmentResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ManageAnnulmentResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ManageAnnulmentResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ManageAnnulmentResponse


class ManageInvoiceRequest(ManageInvoiceRequestType):
    """ManageInvoiceRequest -- A POST /manageInvoice REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s
    é
    nek root elementje
    Request root element of the POST /manageInvoice REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ManageInvoiceRequestType
    def __init__(self, header=None, user=None, software=None, exchangeToken=None, invoiceOperations=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ManageInvoiceRequest"), self).__init__(header, user, software, exchangeToken, invoiceOperations,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManageInvoiceRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManageInvoiceRequest.subclass:
            return ManageInvoiceRequest.subclass(*args_, **kwargs_)
        else:
            return ManageInvoiceRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ManageInvoiceRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='ManageInvoiceRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ManageInvoiceRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ManageInvoiceRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageInvoiceRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ManageInvoiceRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ManageInvoiceRequest'):
        super(ManageInvoiceRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageInvoiceRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='ManageInvoiceRequest', fromsubclass_=False, pretty_print=True):
        super(ManageInvoiceRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ManageInvoiceRequest', mapping_=None, nsmap_=None):
        element = super(ManageInvoiceRequest, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ManageInvoiceRequest'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ManageInvoiceRequest, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(ManageInvoiceRequest, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ManageInvoiceRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ManageInvoiceRequest, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ManageInvoiceRequest


class ManageInvoiceResponse(TransactionResponseType):
    """ManageInvoiceResponse -- A POST /manageInvoice REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the POST /manageInvoice REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TransactionResponseType
    def __init__(self, header=None, result=None, software=None, transactionId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ManageInvoiceResponse"), self).__init__(header, result, software, transactionId,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManageInvoiceResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManageInvoiceResponse.subclass:
            return ManageInvoiceResponse.subclass(*args_, **kwargs_)
        else:
            return ManageInvoiceResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ManageInvoiceResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='ManageInvoiceResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ManageInvoiceResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ManageInvoiceResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageInvoiceResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ManageInvoiceResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ManageInvoiceResponse'):
        super(ManageInvoiceResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManageInvoiceResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='ManageInvoiceResponse', fromsubclass_=False, pretty_print=True):
        super(ManageInvoiceResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ManageInvoiceResponse', mapping_=None, nsmap_=None):
        element = super(ManageInvoiceResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ManageInvoiceResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ManageInvoiceResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(ManageInvoiceResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ManageInvoiceResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ManageInvoiceResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ManageInvoiceResponse


class QueryInvoiceChainDigestRequest(QueryInvoiceChainDigestRequestType):
    """QueryInvoiceChainDigestRequest -- A POST /queryInvoiceChainDigest REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s
    é
    nek root elementje
    Request root element of the POST /queryInvoiceChainDigest REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryInvoiceChainDigestRequestType
    def __init__(self, header=None, user=None, software=None, page=None, invoiceChainQuery=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceChainDigestRequest"), self).__init__(header, user, software, page, invoiceChainQuery,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceChainDigestRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceChainDigestRequest.subclass:
            return QueryInvoiceChainDigestRequest.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceChainDigestRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryInvoiceChainDigestRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceChainDigestRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceChainDigestRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceChainDigestRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceChainDigestRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceChainDigestRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceChainDigestRequest'):
        super(QueryInvoiceChainDigestRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceChainDigestRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceChainDigestRequest', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceChainDigestRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceChainDigestRequest', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceChainDigestRequest, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceChainDigestRequest'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceChainDigestRequest, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceChainDigestRequest, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryInvoiceChainDigestRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryInvoiceChainDigestRequest, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryInvoiceChainDigestRequest


class QueryInvoiceChainDigestResponse(QueryInvoiceChainDigestResponseType):
    """QueryInvoiceChainDigestResponse -- A POST /queryInvoiceChainDigest REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the POST /queryInvoiceChainDigest REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryInvoiceChainDigestResponseType
    def __init__(self, header=None, result=None, software=None, invoiceChainDigestResult=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceChainDigestResponse"), self).__init__(header, result, software, invoiceChainDigestResult,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceChainDigestResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceChainDigestResponse.subclass:
            return QueryInvoiceChainDigestResponse.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceChainDigestResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryInvoiceChainDigestResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceChainDigestResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceChainDigestResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceChainDigestResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceChainDigestResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceChainDigestResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceChainDigestResponse'):
        super(QueryInvoiceChainDigestResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceChainDigestResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceChainDigestResponse', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceChainDigestResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceChainDigestResponse', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceChainDigestResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceChainDigestResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceChainDigestResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceChainDigestResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryInvoiceChainDigestResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryInvoiceChainDigestResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryInvoiceChainDigestResponse


class QueryInvoiceCheckRequest(QueryInvoiceDataRequestType):
    """QueryInvoiceCheckRequest -- A POST /queryInvoiceCheck REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s
    é
    nek root elementje
    Request root element of the POST /queryInvoiceCheck REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryInvoiceDataRequestType
    def __init__(self, header=None, user=None, software=None, invoiceNumberQuery=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceCheckRequest"), self).__init__(header, user, software, invoiceNumberQuery,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceCheckRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceCheckRequest.subclass:
            return QueryInvoiceCheckRequest.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceCheckRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryInvoiceCheckRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceCheckRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceCheckRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceCheckRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceCheckRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceCheckRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceCheckRequest'):
        super(QueryInvoiceCheckRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceCheckRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceCheckRequest', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceCheckRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceCheckRequest', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceCheckRequest, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceCheckRequest'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceCheckRequest, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceCheckRequest, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryInvoiceCheckRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryInvoiceCheckRequest, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryInvoiceCheckRequest


class QueryInvoiceCheckResponse(QueryInvoiceCheckResponseType):
    """QueryInvoiceCheckResponse -- A POST /queryInvoiceCheck REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the POST /queryInvoiceCheck REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryInvoiceCheckResponseType
    def __init__(self, header=None, result=None, software=None, invoiceCheckResult=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceCheckResponse"), self).__init__(header, result, software, invoiceCheckResult,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceCheckResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceCheckResponse.subclass:
            return QueryInvoiceCheckResponse.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceCheckResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryInvoiceCheckResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceCheckResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceCheckResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceCheckResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceCheckResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceCheckResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceCheckResponse'):
        super(QueryInvoiceCheckResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceCheckResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceCheckResponse', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceCheckResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceCheckResponse', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceCheckResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceCheckResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceCheckResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceCheckResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryInvoiceCheckResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryInvoiceCheckResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryInvoiceCheckResponse


class QueryInvoiceDataRequest(QueryInvoiceDataRequestType):
    """QueryInvoiceDataRequest -- A POST /queryInvoiceData REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s
    é
    nek root elementje
    Request root element of the POST /queryInvoiceData REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryInvoiceDataRequestType
    def __init__(self, header=None, user=None, software=None, invoiceNumberQuery=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceDataRequest"), self).__init__(header, user, software, invoiceNumberQuery,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceDataRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceDataRequest.subclass:
            return QueryInvoiceDataRequest.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceDataRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryInvoiceDataRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceDataRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceDataRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceDataRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDataRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceDataRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceDataRequest'):
        super(QueryInvoiceDataRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDataRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceDataRequest', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceDataRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceDataRequest', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceDataRequest, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceDataRequest'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceDataRequest, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceDataRequest, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryInvoiceDataRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryInvoiceDataRequest, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryInvoiceDataRequest


class QueryInvoiceDataResponse(QueryInvoiceDataResponseType):
    """QueryInvoiceDataResponse -- A POST /queryInvoiceData REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the POST /queryInvoiceData REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryInvoiceDataResponseType
    def __init__(self, header=None, result=None, software=None, invoiceDataResult=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceDataResponse"), self).__init__(header, result, software, invoiceDataResult,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceDataResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceDataResponse.subclass:
            return QueryInvoiceDataResponse.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceDataResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryInvoiceDataResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceDataResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceDataResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceDataResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDataResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceDataResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceDataResponse'):
        super(QueryInvoiceDataResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDataResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceDataResponse', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceDataResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceDataResponse', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceDataResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceDataResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceDataResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceDataResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryInvoiceDataResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryInvoiceDataResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryInvoiceDataResponse


class QueryInvoiceDigestRequest(QueryInvoiceDigestRequestType):
    """QueryInvoiceDigestRequest -- A POST /queryInvoiceDigest REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the POST /queryInvoiceDigest REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryInvoiceDigestRequestType
    def __init__(self, header=None, user=None, software=None, page=None, invoiceDirection=None, invoiceQueryParams=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceDigestRequest"), self).__init__(header, user, software, page, invoiceDirection, invoiceQueryParams,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceDigestRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceDigestRequest.subclass:
            return QueryInvoiceDigestRequest.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceDigestRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryInvoiceDigestRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceDigestRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceDigestRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceDigestRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDigestRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceDigestRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceDigestRequest'):
        super(QueryInvoiceDigestRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDigestRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceDigestRequest', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceDigestRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceDigestRequest', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceDigestRequest, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceDigestRequest'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceDigestRequest, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceDigestRequest, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryInvoiceDigestRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryInvoiceDigestRequest, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryInvoiceDigestRequest


class QueryInvoiceDigestResponse(QueryInvoiceDigestResponseType):
    """QueryInvoiceDigestResponse -- A POST /queryInvoiceDigest REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the POST /queryInvoiceDigest REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryInvoiceDigestResponseType
    def __init__(self, header=None, result=None, software=None, invoiceDigestResult=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryInvoiceDigestResponse"), self).__init__(header, result, software, invoiceDigestResult,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryInvoiceDigestResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryInvoiceDigestResponse.subclass:
            return QueryInvoiceDigestResponse.subclass(*args_, **kwargs_)
        else:
            return QueryInvoiceDigestResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryInvoiceDigestResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceDigestResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryInvoiceDigestResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryInvoiceDigestResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDigestResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryInvoiceDigestResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryInvoiceDigestResponse'):
        super(QueryInvoiceDigestResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryInvoiceDigestResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryInvoiceDigestResponse', fromsubclass_=False, pretty_print=True):
        super(QueryInvoiceDigestResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryInvoiceDigestResponse', mapping_=None, nsmap_=None):
        element = super(QueryInvoiceDigestResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryInvoiceDigestResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryInvoiceDigestResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryInvoiceDigestResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryInvoiceDigestResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryInvoiceDigestResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryInvoiceDigestResponse


class QueryTaxpayerRequest(QueryTaxpayerRequestType):
    """QueryTaxpayerRequest -- A POST /queryTaxpayer REST operáció kérésének root elementje
    Request root element of the POST /queryTaxpayer REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryTaxpayerRequestType
    def __init__(self, header=None, user=None, software=None, taxNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTaxpayerRequest"), self).__init__(header, user, software, taxNumber,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTaxpayerRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTaxpayerRequest.subclass:
            return QueryTaxpayerRequest.subclass(*args_, **kwargs_)
        else:
            return QueryTaxpayerRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryTaxpayerRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns="http://schemas.nav.gov.hu/OSA/3.0/api" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTaxpayerRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTaxpayerRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTaxpayerRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTaxpayerRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTaxpayerRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTaxpayerRequest'):
        super(QueryTaxpayerRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTaxpayerRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns="http://schemas.nav.gov.hu/OSA/3.0/api" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTaxpayerRequest', fromsubclass_=False, pretty_print=True):
        super(QueryTaxpayerRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryTaxpayerRequest', mapping_=None, nsmap_=None):
        element = super(QueryTaxpayerRequest, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTaxpayerRequest'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTaxpayerRequest, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTaxpayerRequest, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryTaxpayerRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryTaxpayerRequest, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryTaxpayerRequest


class QueryTaxpayerResponse(QueryTaxpayerResponseType):
    """QueryTaxpayerResponse -- A POST /queryTaxpayer REST operáció válaszának root elementje
    Response root element of the POST /queryTaxpayer REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryTaxpayerResponseType
    def __init__(self, header=None, result=None, software=None, infoDate=None, taxpayerValidity=None, taxpayerData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTaxpayerResponse"), self).__init__(header, result, software, infoDate, taxpayerValidity, taxpayerData,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTaxpayerResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTaxpayerResponse.subclass:
            return QueryTaxpayerResponse.subclass(*args_, **kwargs_)
        else:
            return QueryTaxpayerResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryTaxpayerResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTaxpayerResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTaxpayerResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTaxpayerResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTaxpayerResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTaxpayerResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTaxpayerResponse'):
        super(QueryTaxpayerResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTaxpayerResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTaxpayerResponse', fromsubclass_=False, pretty_print=True):
        super(QueryTaxpayerResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryTaxpayerResponse', mapping_=None, nsmap_=None):
        element = super(QueryTaxpayerResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTaxpayerResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTaxpayerResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTaxpayerResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryTaxpayerResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryTaxpayerResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryTaxpayerResponse


class QueryTransactionListRequest(QueryTransactionListRequestType):
    """QueryTransactionListRequest -- A POST /queryTransactionList REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s
    é
    nek root elementje
    Request root element of the POST /queryTransactionList REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryTransactionListRequestType
    def __init__(self, header=None, user=None, software=None, page=None, insDate=None, requestStatus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTransactionListRequest"), self).__init__(header, user, software, page, insDate, requestStatus,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTransactionListRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTransactionListRequest.subclass:
            return QueryTransactionListRequest.subclass(*args_, **kwargs_)
        else:
            return QueryTransactionListRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryTransactionListRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTransactionListRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTransactionListRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTransactionListRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionListRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTransactionListRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTransactionListRequest'):
        super(QueryTransactionListRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionListRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTransactionListRequest', fromsubclass_=False, pretty_print=True):
        super(QueryTransactionListRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryTransactionListRequest', mapping_=None, nsmap_=None):
        element = super(QueryTransactionListRequest, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTransactionListRequest'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTransactionListRequest, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTransactionListRequest, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryTransactionListRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryTransactionListRequest, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryTransactionListRequest


class QueryTransactionListResponse(QueryTransactionListResponseType):
    """QueryTransactionListResponse -- A POST /queryTransactionList REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the POST /queryTransactionList REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryTransactionListResponseType
    def __init__(self, header=None, result=None, software=None, transactionListResult=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTransactionListResponse"), self).__init__(header, result, software, transactionListResult,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTransactionListResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTransactionListResponse.subclass:
            return QueryTransactionListResponse.subclass(*args_, **kwargs_)
        else:
            return QueryTransactionListResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryTransactionListResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTransactionListResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTransactionListResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTransactionListResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionListResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTransactionListResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTransactionListResponse'):
        super(QueryTransactionListResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionListResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTransactionListResponse', fromsubclass_=False, pretty_print=True):
        super(QueryTransactionListResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryTransactionListResponse', mapping_=None, nsmap_=None):
        element = super(QueryTransactionListResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTransactionListResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTransactionListResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTransactionListResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryTransactionListResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryTransactionListResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryTransactionListResponse


class QueryTransactionStatusRequest(QueryTransactionStatusRequestType):
    """QueryTransactionStatusRequest -- A POST /queryTransactionStatus REST oper
    á
    ci
    ó
    k
    é
    r
    é
    s
    é
    nek root elementje
    Request root element of the POST /queryTransactionStatus REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryTransactionStatusRequestType
    def __init__(self, header=None, user=None, software=None, transactionId=None, returnOriginalRequest=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTransactionStatusRequest"), self).__init__(header, user, software, transactionId, returnOriginalRequest,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTransactionStatusRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTransactionStatusRequest.subclass:
            return QueryTransactionStatusRequest.subclass(*args_, **kwargs_)
        else:
            return QueryTransactionStatusRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryTransactionStatusRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTransactionStatusRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTransactionStatusRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTransactionStatusRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionStatusRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTransactionStatusRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTransactionStatusRequest'):
        super(QueryTransactionStatusRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionStatusRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTransactionStatusRequest', fromsubclass_=False, pretty_print=True):
        super(QueryTransactionStatusRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryTransactionStatusRequest', mapping_=None, nsmap_=None):
        element = super(QueryTransactionStatusRequest, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTransactionStatusRequest'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTransactionStatusRequest, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTransactionStatusRequest, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryTransactionStatusRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryTransactionStatusRequest, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryTransactionStatusRequest


class QueryTransactionStatusResponse(QueryTransactionStatusResponseType):
    """QueryTransactionStatusResponse -- A POST /queryTransactionStatus REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the POST /queryTransactionStatus REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryTransactionStatusResponseType
    def __init__(self, header=None, result=None, software=None, processingResults=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryTransactionStatusResponse"), self).__init__(header, result, software, processingResults,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryTransactionStatusResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryTransactionStatusResponse.subclass:
            return QueryTransactionStatusResponse.subclass(*args_, **kwargs_)
        else:
            return QueryTransactionStatusResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryTransactionStatusResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTransactionStatusResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryTransactionStatusResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryTransactionStatusResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionStatusResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryTransactionStatusResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryTransactionStatusResponse'):
        super(QueryTransactionStatusResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryTransactionStatusResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryTransactionStatusResponse', fromsubclass_=False, pretty_print=True):
        super(QueryTransactionStatusResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryTransactionStatusResponse', mapping_=None, nsmap_=None):
        element = super(QueryTransactionStatusResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryTransactionStatusResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryTransactionStatusResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryTransactionStatusResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryTransactionStatusResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryTransactionStatusResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryTransactionStatusResponse


class TokenExchangeRequest(BasicOnlineInvoiceRequestType):
    """TokenExchangeRequest -- A POST /tokenExchange REST operáció kérésének root elementje
    Request root element of the POST /tokenExchange REST operation
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BasicOnlineInvoiceRequestType
    def __init__(self, header=None, user=None, software=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TokenExchangeRequest"), self).__init__(header, user, software,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TokenExchangeRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TokenExchangeRequest.subclass:
            return TokenExchangeRequest.subclass(*args_, **kwargs_)
        else:
            return TokenExchangeRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(TokenExchangeRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='',
               namespacedef_='xmlns="http://schemas.nav.gov.hu/OSA/3.0/api" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"',
               name_='TokenExchangeRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TokenExchangeRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TokenExchangeRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TokenExchangeRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TokenExchangeRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TokenExchangeRequest'):
        super(TokenExchangeRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TokenExchangeRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='TokenExchangeRequest', fromsubclass_=False, pretty_print=True):
        super(TokenExchangeRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TokenExchangeRequest', mapping_=None, nsmap_=None):
        element = super(TokenExchangeRequest, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TokenExchangeRequest'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TokenExchangeRequest, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(TokenExchangeRequest, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TokenExchangeRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TokenExchangeRequest, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TokenExchangeRequest


class TokenExchangeResponse(TokenExchangeResponseType):
    """TokenExchangeResponse -- A POST /tokenExchange REST operáció válaszának root elementje
    Response root element of the POST /tokenExchange REST operation

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TokenExchangeResponseType
    def __init__(self, header=None, result=None, software=None, encodedExchangeToken=None, tokenValidityFrom=None, tokenValidityTo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TokenExchangeResponse"), self).__init__(header, result, software, encodedExchangeToken, tokenValidityFrom, tokenValidityTo,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TokenExchangeResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TokenExchangeResponse.subclass:
            return TokenExchangeResponse.subclass(*args_, **kwargs_)
        else:
            return TokenExchangeResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(TokenExchangeResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"', name_='TokenExchangeResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TokenExchangeResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TokenExchangeResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TokenExchangeResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TokenExchangeResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TokenExchangeResponse'):
        super(TokenExchangeResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TokenExchangeResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"', name_='TokenExchangeResponse', fromsubclass_=False, pretty_print=True):
        super(TokenExchangeResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TokenExchangeResponse', mapping_=None, nsmap_=None):
        element = super(TokenExchangeResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TokenExchangeResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TokenExchangeResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(TokenExchangeResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TokenExchangeResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TokenExchangeResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TokenExchangeResponse


class AdditionalDataType(GeneratedsSuper):
    """AdditionalDataType -- Tov
    á
    bbi adat le
    í
    r
    á
    s
    á
    ra szolg
    á
    l
    ó
    t
    í
    pus
    Type for additional data description
    dataName -- Az adatmez
    ő
    egyedi azonos
    í
    t
    ó
    ja
    Unique identification of the data field
    dataDescription -- Az adatmez
    ő
    tartalm
    á
    nak sz
    ö
    veges le
    í
    r
    á
    sa
    Description of content of the data field
    dataValue -- Az adat
    é
    rt
    é
    ke
    Value of the data

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dataName=None, dataDescription=None, dataValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dataName = dataName
        self.validate_DataNameType(self.dataName)
        self.dataName_nsprefix_ = None
        self.dataDescription = dataDescription
        self.validate_SimpleText255NotBlankType(self.dataDescription)
        self.dataDescription_nsprefix_ = "common"
        self.dataValue = dataValue
        self.validate_SimpleText512NotBlankType(self.dataValue)
        self.dataValue_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalDataType.subclass:
            return AdditionalDataType.subclass(*args_, **kwargs_)
        else:
            return AdditionalDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dataName(self):
        return self.dataName
    def set_dataName(self, dataName):
        self.dataName = dataName
    def get_dataDescription(self):
        return self.dataDescription
    def set_dataDescription(self, dataDescription):
        self.dataDescription = dataDescription
    def get_dataValue(self):
        return self.dataValue
    def set_dataValue(self, dataValue):
        self.dataValue = dataValue
    def validate_DataNameType(self, value):
        result = True
        # Validate type DataNameType, a restriction on common:AtomicStringType255.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DataNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on DataNameType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on DataNameType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on DataNameType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_DataNameType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DataNameType_patterns_, ))
                result = False
        return result
    validate_DataNameType_patterns_ = [['^([A-Z][0-9]{5}[_][_A-Z0-9]{1,249})$']]
    def validate_SimpleText255NotBlankType(self, value):
        result = True
        # Validate type SimpleText255NotBlankType, a restriction on AtomicStringType255.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText255NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText255NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText255NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText255NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText255NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.dataName is not None or
            self.dataDescription is not None or
            self.dataValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='AdditionalDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdditionalDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AdditionalDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdditionalDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AdditionalDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdditionalDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='AdditionalDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dataName is not None:
            namespaceprefix_ = self.dataName_nsprefix_ + ':' if (UseCapturedNS_ and self.dataName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdataName>%s</%sdataName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dataName), input_name='dataName')), namespaceprefix_ , eol_))
        if self.dataDescription is not None:
            namespaceprefix_ = self.dataDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.dataDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdataDescription>%s</%sdataDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dataDescription), input_name='dataDescription')), namespaceprefix_ , eol_))
        if self.dataValue is not None:
            namespaceprefix_ = self.dataValue_nsprefix_ + ':' if (UseCapturedNS_ and self.dataValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdataValue>%s</%sdataValue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dataValue), input_name='dataValue')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='AdditionalDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.dataName is not None:
            dataName_ = self.dataName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}dataName').text = self.gds_format_string(dataName_)
        if self.dataDescription is not None:
            dataDescription_ = self.dataDescription
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}dataDescription').text = self.gds_format_string(dataDescription_)
        if self.dataValue is not None:
            dataValue_ = self.dataValue
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}dataValue').text = self.gds_format_string(dataValue_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AdditionalDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.dataName is not None:
            showIndent(outfile, level)
            outfile.write('dataName=%s,\n' % self.gds_encode(quote_python(self.dataName)))
        if self.dataDescription is not None:
            showIndent(outfile, level)
            outfile.write('dataDescription=%s,\n' % self.gds_encode(quote_python(self.dataDescription)))
        if self.dataValue is not None:
            showIndent(outfile, level)
            outfile.write('dataValue=%s,\n' % self.gds_encode(quote_python(self.dataValue)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dataName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dataName')
            value_ = self.gds_validate_string(value_, node, 'dataName')
            self.dataName = value_
            self.dataName_nsprefix_ = child_.prefix
            # validate type DataNameType
            self.validate_DataNameType(self.dataName)
        elif nodeName_ == 'dataDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dataDescription')
            value_ = self.gds_validate_string(value_, node, 'dataDescription')
            self.dataDescription = value_
            self.dataDescription_nsprefix_ = child_.prefix
            # validate type SimpleText255NotBlankType
            self.validate_SimpleText255NotBlankType(self.dataDescription)
        elif nodeName_ == 'dataValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dataValue')
            value_ = self.gds_validate_string(value_, node, 'dataValue')
            self.dataValue = value_
            self.dataValue_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.dataValue)
# end class AdditionalDataType


class AdvanceDataType(GeneratedsSuper):
    """AdvanceDataType -- El
    ő
    leghez kapcsol
    ó
    d
    ó
    adatok
    Advance related data
    advanceIndicator -- É
    rt
    é
    ke true, ha a sz
    á
    mla t
    é
    tel el
    ő
    leg jelleg
    ű
    The value is true if the invoice item is a kind of advance charge
    advancePaymentData -- El
    ő
    leg fizet
    é
    shez kapcsol
    ó
    d
    ó
    adatok
    Advance payment related data

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, advanceIndicator=None, advancePaymentData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.advanceIndicator = advanceIndicator
        self.advanceIndicator_nsprefix_ = "xs"
        self.advancePaymentData = advancePaymentData
        self.advancePaymentData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdvanceDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdvanceDataType.subclass:
            return AdvanceDataType.subclass(*args_, **kwargs_)
        else:
            return AdvanceDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_advanceIndicator(self):
        return self.advanceIndicator
    def set_advanceIndicator(self, advanceIndicator):
        self.advanceIndicator = advanceIndicator
    def get_advancePaymentData(self):
        return self.advancePaymentData
    def set_advancePaymentData(self, advancePaymentData):
        self.advancePaymentData = advancePaymentData
    def _hasContent(self):
        if (
            self.advanceIndicator is not None or
            self.advancePaymentData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='AdvanceDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdvanceDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AdvanceDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdvanceDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AdvanceDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdvanceDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='AdvanceDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.advanceIndicator is not None:
            namespaceprefix_ = self.advanceIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.advanceIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadvanceIndicator>%s</%sadvanceIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.advanceIndicator, input_name='advanceIndicator'), namespaceprefix_ , eol_))
        if self.advancePaymentData is not None:
            namespaceprefix_ = self.advancePaymentData_nsprefix_ + ':' if (UseCapturedNS_ and self.advancePaymentData_nsprefix_) else ''
            self.advancePaymentData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='advancePaymentData', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AdvanceDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.advanceIndicator is not None:
            advanceIndicator_ = self.advanceIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}advanceIndicator').text = self.gds_format_boolean(advanceIndicator_)
        if self.advancePaymentData is not None:
            advancePaymentData_ = self.advancePaymentData
            advancePaymentData_.to_etree(element, name_='advancePaymentData', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AdvanceDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.advanceIndicator is not None:
            showIndent(outfile, level)
            outfile.write('advanceIndicator=%s,\n' % self.advanceIndicator)
        if self.advancePaymentData is not None:
            showIndent(outfile, level)
            outfile.write('advancePaymentData=model_.AdvancePaymentDataType(\n')
            self.advancePaymentData.exportLiteral(outfile, level, name_='advancePaymentData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'advanceIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'advanceIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'advanceIndicator')
            self.advanceIndicator = ival_
            self.advanceIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'advancePaymentData':
            obj_ = AdvancePaymentDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.advancePaymentData = obj_
            obj_.original_tagname_ = 'advancePaymentData'
# end class AdvanceDataType


class AdvancePaymentDataType(GeneratedsSuper):
    """AdvancePaymentDataType -- El
    ő
    legfizet
    é
    shez kapcsol
    ó
    d
    ó
    adatok
    Advance payment related data
    advanceOriginalInvoice -- Az el
    ő
    legsz
    á
    ml
    á
    nak a sorsz
    á
    ma, amelyben az el
    ő
    legfizet
    é
    s t
    ö
    rt
    é
    nt
    Invoice number containing the advance payment
    advancePaymentDate -- Az el
    ő
    leg fizet
    é
    s
    é
    nek d
    á
    tuma
    Payment date of the advance
    advanceExchangeRate -- Az el
    ő
    legfizet
    é
    s sor
    á
    n alkalmazott
    á
    rfolyam
    Applied exchange rate of the advance

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, advanceOriginalInvoice=None, advancePaymentDate=None, advanceExchangeRate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.advanceOriginalInvoice = advanceOriginalInvoice
        self.validate_SimpleText50NotBlankType(self.advanceOriginalInvoice)
        self.advanceOriginalInvoice_nsprefix_ = "common"
        if isinstance(advancePaymentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(advancePaymentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = advancePaymentDate
        self.advancePaymentDate = initvalue_
        self.advancePaymentDate_nsprefix_ = "base"
        self.advanceExchangeRate = advanceExchangeRate
        self.validate_ExchangeRateType(self.advanceExchangeRate)
        self.advanceExchangeRate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdvancePaymentDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdvancePaymentDataType.subclass:
            return AdvancePaymentDataType.subclass(*args_, **kwargs_)
        else:
            return AdvancePaymentDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_advanceOriginalInvoice(self):
        return self.advanceOriginalInvoice
    def set_advanceOriginalInvoice(self, advanceOriginalInvoice):
        self.advanceOriginalInvoice = advanceOriginalInvoice
    def get_advancePaymentDate(self):
        return self.advancePaymentDate
    def set_advancePaymentDate(self, advancePaymentDate):
        self.advancePaymentDate = advancePaymentDate
    def get_advanceExchangeRate(self):
        return self.advanceExchangeRate
    def set_advanceExchangeRate(self, advanceExchangeRate):
        self.advanceExchangeRate = advanceExchangeRate
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceDateType(self, value):
        result = True
        # Validate type InvoiceDateType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.strptime('2010-01-01', '%Y-%m-%d').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceDateType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceDateType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceDateType_patterns_, ))
                result = False
        return result
    validate_InvoiceDateType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2})$']]
    def validate_ExchangeRateType(self, value):
        result = True
        # Validate type ExchangeRateType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value <= 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on ExchangeRateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on ExchangeRateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.advanceOriginalInvoice is not None or
            self.advancePaymentDate is not None or
            self.advanceExchangeRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='AdvancePaymentDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdvancePaymentDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AdvancePaymentDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdvancePaymentDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AdvancePaymentDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdvancePaymentDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='AdvancePaymentDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.advanceOriginalInvoice is not None:
            namespaceprefix_ = self.advanceOriginalInvoice_nsprefix_ + ':' if (UseCapturedNS_ and self.advanceOriginalInvoice_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadvanceOriginalInvoice>%s</%sadvanceOriginalInvoice>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.advanceOriginalInvoice), input_name='advanceOriginalInvoice')), namespaceprefix_ , eol_))
        if self.advancePaymentDate is not None:
            namespaceprefix_ = self.advancePaymentDate_nsprefix_ + ':' if (UseCapturedNS_ and self.advancePaymentDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadvancePaymentDate>%s</%sadvancePaymentDate>%s' % (namespaceprefix_ , self.gds_format_date(self.advancePaymentDate, input_name='advancePaymentDate'), namespaceprefix_ , eol_))
        if self.advanceExchangeRate is not None:
            namespaceprefix_ = self.advanceExchangeRate_nsprefix_ + ':' if (UseCapturedNS_ and self.advanceExchangeRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadvanceExchangeRate>%s</%sadvanceExchangeRate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.advanceExchangeRate, input_name='advanceExchangeRate'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='AdvancePaymentDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.advanceOriginalInvoice is not None:
            advanceOriginalInvoice_ = self.advanceOriginalInvoice
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}advanceOriginalInvoice').text = self.gds_format_string(advanceOriginalInvoice_)
        if self.advancePaymentDate is not None:
            advancePaymentDate_ = self.advancePaymentDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}advancePaymentDate').text = self.gds_format_date(advancePaymentDate_)
        if self.advanceExchangeRate is not None:
            advanceExchangeRate_ = self.advanceExchangeRate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}advanceExchangeRate').text = self.gds_format_decimal(advanceExchangeRate_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AdvancePaymentDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.advanceOriginalInvoice is not None:
            showIndent(outfile, level)
            outfile.write('advanceOriginalInvoice=%s,\n' % self.gds_encode(quote_python(self.advanceOriginalInvoice)))
        if self.advancePaymentDate is not None:
            showIndent(outfile, level)
            outfile.write('advancePaymentDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.advancePaymentDate, input_name='advancePaymentDate'))
        if self.advanceExchangeRate is not None:
            showIndent(outfile, level)
            outfile.write('advanceExchangeRate=%f,\n' % self.advanceExchangeRate)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'advanceOriginalInvoice':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'advanceOriginalInvoice')
            value_ = self.gds_validate_string(value_, node, 'advanceOriginalInvoice')
            self.advanceOriginalInvoice = value_
            self.advanceOriginalInvoice_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.advanceOriginalInvoice)
        elif nodeName_ == 'advancePaymentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.advancePaymentDate = dval_
            self.advancePaymentDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.advancePaymentDate)
        elif nodeName_ == 'advanceExchangeRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'advanceExchangeRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'advanceExchangeRate')
            self.advanceExchangeRate = fval_
            self.advanceExchangeRate_nsprefix_ = child_.prefix
            # validate type ExchangeRateType
            self.validate_ExchangeRateType(self.advanceExchangeRate)
# end class AdvancePaymentDataType


class AggregateInvoiceLineDataType(GeneratedsSuper):
    """AggregateInvoiceLineDataType -- A gy
    ű
    jt
    ő
    sz
    á
    ml
    á
    ra vonatkoz
    ó
    speci
    á
    lis adatokat tartalmaz
    ó
    t
    í
    pus
    Field type including aggregate invoice special data
    lineExchangeRate -- A t
    é
    telhez tartoz
    ó
    á
    rfolyam, 1 (egy) egys
    é
    gre vonatkoztatva. Csak k
    ü
    lf
    ö
    ldi p
    é
    nznemben ki
    á
    ll
    í
    tott gy
    ű
    jt
    ő
    sz
    á
    mla eset
    é
    n kit
    ö
    ltend
    ő
    The exchange rate applied to the item, pertaining to 1 (one) unit. This should be filled in only if an aggregate invoice in foreign currency is issued
    lineDeliveryDate -- Gy
    ű
    jt
    ő
    sz
    á
    mla eset
    é
    n az adott t
    é
    tel teljes
    í
    t
    é
    si d
    á
    tuma
    Delivery date of the given item in the case of an aggregate invoice

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lineExchangeRate=None, lineDeliveryDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lineExchangeRate = lineExchangeRate
        self.validate_ExchangeRateType(self.lineExchangeRate)
        self.lineExchangeRate_nsprefix_ = None
        if isinstance(lineDeliveryDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(lineDeliveryDate, '%Y-%m-%d').date()
        else:
            initvalue_ = lineDeliveryDate
        self.lineDeliveryDate = initvalue_
        self.lineDeliveryDate_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregateInvoiceLineDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregateInvoiceLineDataType.subclass:
            return AggregateInvoiceLineDataType.subclass(*args_, **kwargs_)
        else:
            return AggregateInvoiceLineDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lineExchangeRate(self):
        return self.lineExchangeRate
    def set_lineExchangeRate(self, lineExchangeRate):
        self.lineExchangeRate = lineExchangeRate
    def get_lineDeliveryDate(self):
        return self.lineDeliveryDate
    def set_lineDeliveryDate(self, lineDeliveryDate):
        self.lineDeliveryDate = lineDeliveryDate
    def validate_ExchangeRateType(self, value):
        result = True
        # Validate type ExchangeRateType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value <= 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on ExchangeRateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on ExchangeRateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceDateType(self, value):
        result = True
        # Validate type InvoiceDateType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.strptime('2010-01-01', '%Y-%m-%d').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceDateType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceDateType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceDateType_patterns_, ))
                result = False
        return result
    validate_InvoiceDateType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2})$']]
    def _hasContent(self):
        if (
            self.lineExchangeRate is not None or
            self.lineDeliveryDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='AggregateInvoiceLineDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregateInvoiceLineDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AggregateInvoiceLineDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregateInvoiceLineDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AggregateInvoiceLineDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AggregateInvoiceLineDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='AggregateInvoiceLineDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lineExchangeRate is not None:
            namespaceprefix_ = self.lineExchangeRate_nsprefix_ + ':' if (UseCapturedNS_ and self.lineExchangeRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineExchangeRate>%s</%slineExchangeRate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.lineExchangeRate, input_name='lineExchangeRate'), namespaceprefix_ , eol_))
        if self.lineDeliveryDate is not None:
            namespaceprefix_ = self.lineDeliveryDate_nsprefix_ + ':' if (UseCapturedNS_ and self.lineDeliveryDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineDeliveryDate>%s</%slineDeliveryDate>%s' % (namespaceprefix_ , self.gds_format_date(self.lineDeliveryDate, input_name='lineDeliveryDate'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='AggregateInvoiceLineDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.lineExchangeRate is not None:
            lineExchangeRate_ = self.lineExchangeRate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineExchangeRate').text = self.gds_format_decimal(lineExchangeRate_)
        if self.lineDeliveryDate is not None:
            lineDeliveryDate_ = self.lineDeliveryDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineDeliveryDate').text = self.gds_format_date(lineDeliveryDate_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AggregateInvoiceLineDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.lineExchangeRate is not None:
            showIndent(outfile, level)
            outfile.write('lineExchangeRate=%f,\n' % self.lineExchangeRate)
        if self.lineDeliveryDate is not None:
            showIndent(outfile, level)
            outfile.write('lineDeliveryDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.lineDeliveryDate, input_name='lineDeliveryDate'))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lineExchangeRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'lineExchangeRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'lineExchangeRate')
            self.lineExchangeRate = fval_
            self.lineExchangeRate_nsprefix_ = child_.prefix
            # validate type ExchangeRateType
            self.validate_ExchangeRateType(self.lineExchangeRate)
        elif nodeName_ == 'lineDeliveryDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.lineDeliveryDate = dval_
            self.lineDeliveryDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.lineDeliveryDate)
# end class AggregateInvoiceLineDataType


class AircraftType(GeneratedsSuper):
    """AircraftType -- L
    é
    gi k
    ö
    zleked
    é
    si eszk
    ö
    z
    Aircraft
    takeOffWeight -- Felsz
    á
    ll
    á
    si t
    ö
    meg kilogrammban
    Take-off weight in kilogram
    airCargo -- É
    rt
    é
    ke true ha a j
    á
    rm
    ű
    az
    Á
    FA tv. 259.
    §
    25. c) szerinti kiv
    é
    tel al
    á
    tartozik
    The value is true if the means of transport is exempt from VAT as per section 259 [25] (c)
    operationHours -- Rep
    ü
    lt
    ó
    r
    á
    k sz
    á
    ma
    Number of aviated hours

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, takeOffWeight=None, airCargo=None, operationHours=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.takeOffWeight = takeOffWeight
        self.validate_QuantityType(self.takeOffWeight)
        self.takeOffWeight_nsprefix_ = None
        self.airCargo = airCargo
        self.airCargo_nsprefix_ = "xs"
        self.operationHours = operationHours
        self.validate_QuantityType(self.operationHours)
        self.operationHours_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AircraftType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AircraftType.subclass:
            return AircraftType.subclass(*args_, **kwargs_)
        else:
            return AircraftType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_takeOffWeight(self):
        return self.takeOffWeight
    def set_takeOffWeight(self, takeOffWeight):
        self.takeOffWeight = takeOffWeight
    def get_airCargo(self):
        return self.airCargo
    def set_airCargo(self, airCargo):
        self.airCargo = airCargo
    def get_operationHours(self):
        return self.operationHours
    def set_operationHours(self, operationHours):
        self.operationHours = operationHours
    def validate_QuantityType(self, value):
        result = True
        # Validate type QuantityType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 22:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.takeOffWeight is not None or
            self.airCargo is not None or
            self.operationHours is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='AircraftType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AircraftType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AircraftType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AircraftType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AircraftType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AircraftType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='AircraftType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.takeOffWeight is not None:
            namespaceprefix_ = self.takeOffWeight_nsprefix_ + ':' if (UseCapturedNS_ and self.takeOffWeight_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stakeOffWeight>%s</%stakeOffWeight>%s' % (namespaceprefix_ , self.gds_format_decimal(self.takeOffWeight, input_name='takeOffWeight'), namespaceprefix_ , eol_))
        if self.airCargo is not None:
            namespaceprefix_ = self.airCargo_nsprefix_ + ':' if (UseCapturedNS_ and self.airCargo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sairCargo>%s</%sairCargo>%s' % (namespaceprefix_ , self.gds_format_boolean(self.airCargo, input_name='airCargo'), namespaceprefix_ , eol_))
        if self.operationHours is not None:
            namespaceprefix_ = self.operationHours_nsprefix_ + ':' if (UseCapturedNS_ and self.operationHours_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soperationHours>%s</%soperationHours>%s' % (namespaceprefix_ , self.gds_format_decimal(self.operationHours, input_name='operationHours'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='AircraftType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.takeOffWeight is not None:
            takeOffWeight_ = self.takeOffWeight
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}takeOffWeight').text = self.gds_format_decimal(takeOffWeight_)
        if self.airCargo is not None:
            airCargo_ = self.airCargo
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}airCargo').text = self.gds_format_boolean(airCargo_)
        if self.operationHours is not None:
            operationHours_ = self.operationHours
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}operationHours').text = self.gds_format_decimal(operationHours_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AircraftType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.takeOffWeight is not None:
            showIndent(outfile, level)
            outfile.write('takeOffWeight=%f,\n' % self.takeOffWeight)
        if self.airCargo is not None:
            showIndent(outfile, level)
            outfile.write('airCargo=%s,\n' % self.airCargo)
        if self.operationHours is not None:
            showIndent(outfile, level)
            outfile.write('operationHours=%f,\n' % self.operationHours)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'takeOffWeight' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'takeOffWeight')
            fval_ = self.gds_validate_decimal(fval_, node, 'takeOffWeight')
            self.takeOffWeight = fval_
            self.takeOffWeight_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.takeOffWeight)
        elif nodeName_ == 'airCargo':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'airCargo')
            ival_ = self.gds_validate_boolean(ival_, node, 'airCargo')
            self.airCargo = ival_
            self.airCargo_nsprefix_ = child_.prefix
        elif nodeName_ == 'operationHours' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'operationHours')
            fval_ = self.gds_validate_decimal(fval_, node, 'operationHours')
            self.operationHours = fval_
            self.operationHours_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.operationHours)
# end class AircraftType


class BatchInvoiceType(GeneratedsSuper):
    """BatchInvoiceType -- K
    ö
    tegelt m
    ó
    dos
    í
    t
    ó
    okirat adatai
    Data of a batch of modification documents
    batchIndex -- A m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma a k
    ö
    tegen bel
    ü
    l
    Sequence number of the modification document within the batch
    invoice -- Egy sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat adatai
    Data of a single invoice or modification document

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, batchIndex=None, invoice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.batchIndex = batchIndex
        self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        self.batchIndex_nsprefix_ = "base"
        self.invoice = invoice
        self.invoice_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BatchInvoiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BatchInvoiceType.subclass:
            return BatchInvoiceType.subclass(*args_, **kwargs_)
        else:
            return BatchInvoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_batchIndex(self):
        return self.batchIndex
    def set_batchIndex(self, batchIndex):
        self.batchIndex = batchIndex
    def get_invoice(self):
        return self.invoice
    def set_invoice(self, invoice):
        self.invoice = invoice
    def validate_InvoiceUnboundedIndexType(self, value):
        result = True
        # Validate type InvoiceUnboundedIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceUnboundedIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.batchIndex is not None or
            self.invoice is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BatchInvoiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BatchInvoiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BatchInvoiceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BatchInvoiceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BatchInvoiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BatchInvoiceType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='BatchInvoiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.batchIndex is not None:
            namespaceprefix_ = self.batchIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.batchIndex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbatchIndex>%s</%sbatchIndex>%s' % (namespaceprefix_ , self.gds_format_integer(self.batchIndex, input_name='batchIndex'), namespaceprefix_ , eol_))
        if self.invoice is not None:
            namespaceprefix_ = self.invoice_nsprefix_ + ':' if (UseCapturedNS_ and self.invoice_nsprefix_) else ''
            self.invoice.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoice', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BatchInvoiceType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.batchIndex is not None:
            batchIndex_ = self.batchIndex
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}batchIndex').text = self.gds_format_integer(batchIndex_)
        if self.invoice is not None:
            invoice_ = self.invoice
            invoice_.to_etree(element, name_='invoice', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='BatchInvoiceType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.batchIndex is not None:
            showIndent(outfile, level)
            outfile.write('batchIndex=%d,\n' % self.batchIndex)
        if self.invoice is not None:
            showIndent(outfile, level)
            outfile.write('invoice=model_.InvoiceType(\n')
            self.invoice.exportLiteral(outfile, level, name_='invoice')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'batchIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'batchIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'batchIndex')
            self.batchIndex = ival_
            self.batchIndex_nsprefix_ = child_.prefix
            # validate type InvoiceUnboundedIndexType
            self.validate_InvoiceUnboundedIndexType(self.batchIndex)
        elif nodeName_ == 'invoice':
            obj_ = InvoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoice = obj_
            obj_.original_tagname_ = 'invoice'
# end class BatchInvoiceType


class ContractNumbersType(GeneratedsSuper):
    """ContractNumbersType -- Szerz
    ő
    d
    é
    ssz
    á
    mok
    Contract numbers
    contractNumber -- Szerz
    ő
    d
    é
    ssz
    á
    m
    Contract number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, contractNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if contractNumber is None:
            self.contractNumber = []
        else:
            self.contractNumber = contractNumber
        self.contractNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContractNumbersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContractNumbersType.subclass:
            return ContractNumbersType.subclass(*args_, **kwargs_)
        else:
            return ContractNumbersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contractNumber(self):
        return self.contractNumber
    def set_contractNumber(self, contractNumber):
        self.contractNumber = contractNumber
    def add_contractNumber(self, value):
        self.contractNumber.append(value)
    def insert_contractNumber_at(self, index, value):
        self.contractNumber.insert(index, value)
    def replace_contractNumber_at(self, index, value):
        self.contractNumber[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.contractNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='ContractNumbersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContractNumbersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContractNumbersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContractNumbersType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContractNumbersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContractNumbersType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='ContractNumbersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for contractNumber_ in self.contractNumber:
            namespaceprefix_ = self.contractNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.contractNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontractNumber>%s</%scontractNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(contractNumber_), input_name='contractNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='ContractNumbersType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for contractNumber_ in self.contractNumber:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}contractNumber').text = self.gds_format_string(contractNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ContractNumbersType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('contractNumber=[\n')
        level += 1
        for contractNumber_ in self.contractNumber:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(contractNumber_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contractNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'contractNumber')
            value_ = self.gds_validate_string(value_, node, 'contractNumber')
            self.contractNumber.append(value_)
            self.contractNumber_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.contractNumber[-1])
# end class ContractNumbersType


class ConventionalInvoiceInfoType(GeneratedsSuper):
    """ConventionalInvoiceInfoType -- A sz
    á
    mlafeldolgoz
    á
    st seg
    í
    t
    ő
    , egyezm
    é
    nyesen neves
    í
    tett egy
    é
    b adatok
    Other conventionally named data to assist in invoice processing
    orderNumbers -- Megrendel
    é
    ssz
    á
    m(ok)
    Order numbers
    deliveryNotes -- Sz
    á
    ll
    í
    t
    ó
    lev
    é
    l sz
    á
    m(ok)
    Delivery notes
    shippingDates -- Sz
    á
    ll
    í
    t
    á
    si d
    á
    tum(ok)
    Shipping dates
    contractNumbers -- Szerz
    ő
    d
    é
    ssz
    á
    m(ok)
    Contract numbers
    supplierCompanyCodes -- Az elad
    ó
    v
    á
    llalati k
    ó
    dja(i)
    Company codes of the supplier
    customerCompanyCodes -- A vev
    ő
    v
    á
    llalati k
    ó
    dja(i)
    Company codes of the customer
    dealerCodes -- Besz
    á
    ll
    í
    t
    ó
    k
    ó
    d(ok)
    Dealer codes
    costCenters -- K
    ö
    lts
    é
    ghely(ek)
    Cost centers
    projectNumbers -- Projektsz
    á
    m(ok)
    Project numbers
    generalLedgerAccountNumbers -- F
    ő
    k
    ö
    nyvi sz
    á
    mlasz
    á
    m(ok)
    General ledger account numbers
    glnNumbersSupplier -- Ki
    á
    ll
    í
    t
    ó
    i glob
    á
    lis helyazonos
    í
    t
    ó
    sz
    á
    m(ok)
    Supplier's global location numbers
    glnNumbersCustomer -- Vev
    ő
    i glob
    á
    lis helyazonos
    í
    t
    ó
    sz
    á
    m(ok)
    Customer's global location numbers
    materialNumbers -- Anyagsz
    á
    m(ok)
    Material numbers
    itemNumbers -- Cikksz
    á
    m(ok)
    Item number(s)
    ekaerIds -- EK
    Á
    ER azonos
    í
    t
    ó
    (k)
    EKAER ID-s

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, orderNumbers=None, deliveryNotes=None, shippingDates=None, contractNumbers=None, supplierCompanyCodes=None, customerCompanyCodes=None, dealerCodes=None, costCenters=None, projectNumbers=None, generalLedgerAccountNumbers=None, glnNumbersSupplier=None, glnNumbersCustomer=None, materialNumbers=None, itemNumbers=None, ekaerIds=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.orderNumbers = orderNumbers
        self.orderNumbers_nsprefix_ = None
        self.deliveryNotes = deliveryNotes
        self.deliveryNotes_nsprefix_ = None
        self.shippingDates = shippingDates
        self.shippingDates_nsprefix_ = None
        self.contractNumbers = contractNumbers
        self.contractNumbers_nsprefix_ = None
        self.supplierCompanyCodes = supplierCompanyCodes
        self.supplierCompanyCodes_nsprefix_ = None
        self.customerCompanyCodes = customerCompanyCodes
        self.customerCompanyCodes_nsprefix_ = None
        self.dealerCodes = dealerCodes
        self.dealerCodes_nsprefix_ = None
        self.costCenters = costCenters
        self.costCenters_nsprefix_ = None
        self.projectNumbers = projectNumbers
        self.projectNumbers_nsprefix_ = None
        self.generalLedgerAccountNumbers = generalLedgerAccountNumbers
        self.generalLedgerAccountNumbers_nsprefix_ = None
        self.glnNumbersSupplier = glnNumbersSupplier
        self.glnNumbersSupplier_nsprefix_ = None
        self.glnNumbersCustomer = glnNumbersCustomer
        self.glnNumbersCustomer_nsprefix_ = None
        self.materialNumbers = materialNumbers
        self.materialNumbers_nsprefix_ = None
        self.itemNumbers = itemNumbers
        self.itemNumbers_nsprefix_ = None
        self.ekaerIds = ekaerIds
        self.ekaerIds_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConventionalInvoiceInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConventionalInvoiceInfoType.subclass:
            return ConventionalInvoiceInfoType.subclass(*args_, **kwargs_)
        else:
            return ConventionalInvoiceInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_orderNumbers(self):
        return self.orderNumbers
    def set_orderNumbers(self, orderNumbers):
        self.orderNumbers = orderNumbers
    def get_deliveryNotes(self):
        return self.deliveryNotes
    def set_deliveryNotes(self, deliveryNotes):
        self.deliveryNotes = deliveryNotes
    def get_shippingDates(self):
        return self.shippingDates
    def set_shippingDates(self, shippingDates):
        self.shippingDates = shippingDates
    def get_contractNumbers(self):
        return self.contractNumbers
    def set_contractNumbers(self, contractNumbers):
        self.contractNumbers = contractNumbers
    def get_supplierCompanyCodes(self):
        return self.supplierCompanyCodes
    def set_supplierCompanyCodes(self, supplierCompanyCodes):
        self.supplierCompanyCodes = supplierCompanyCodes
    def get_customerCompanyCodes(self):
        return self.customerCompanyCodes
    def set_customerCompanyCodes(self, customerCompanyCodes):
        self.customerCompanyCodes = customerCompanyCodes
    def get_dealerCodes(self):
        return self.dealerCodes
    def set_dealerCodes(self, dealerCodes):
        self.dealerCodes = dealerCodes
    def get_costCenters(self):
        return self.costCenters
    def set_costCenters(self, costCenters):
        self.costCenters = costCenters
    def get_projectNumbers(self):
        return self.projectNumbers
    def set_projectNumbers(self, projectNumbers):
        self.projectNumbers = projectNumbers
    def get_generalLedgerAccountNumbers(self):
        return self.generalLedgerAccountNumbers
    def set_generalLedgerAccountNumbers(self, generalLedgerAccountNumbers):
        self.generalLedgerAccountNumbers = generalLedgerAccountNumbers
    def get_glnNumbersSupplier(self):
        return self.glnNumbersSupplier
    def set_glnNumbersSupplier(self, glnNumbersSupplier):
        self.glnNumbersSupplier = glnNumbersSupplier
    def get_glnNumbersCustomer(self):
        return self.glnNumbersCustomer
    def set_glnNumbersCustomer(self, glnNumbersCustomer):
        self.glnNumbersCustomer = glnNumbersCustomer
    def get_materialNumbers(self):
        return self.materialNumbers
    def set_materialNumbers(self, materialNumbers):
        self.materialNumbers = materialNumbers
    def get_itemNumbers(self):
        return self.itemNumbers
    def set_itemNumbers(self, itemNumbers):
        self.itemNumbers = itemNumbers
    def get_ekaerIds(self):
        return self.ekaerIds
    def set_ekaerIds(self, ekaerIds):
        self.ekaerIds = ekaerIds
    def _hasContent(self):
        if (
            self.orderNumbers is not None or
            self.deliveryNotes is not None or
            self.shippingDates is not None or
            self.contractNumbers is not None or
            self.supplierCompanyCodes is not None or
            self.customerCompanyCodes is not None or
            self.dealerCodes is not None or
            self.costCenters is not None or
            self.projectNumbers is not None or
            self.generalLedgerAccountNumbers is not None or
            self.glnNumbersSupplier is not None or
            self.glnNumbersCustomer is not None or
            self.materialNumbers is not None or
            self.itemNumbers is not None or
            self.ekaerIds is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ConventionalInvoiceInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConventionalInvoiceInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConventionalInvoiceInfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConventionalInvoiceInfoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConventionalInvoiceInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConventionalInvoiceInfoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ConventionalInvoiceInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orderNumbers is not None:
            namespaceprefix_ = self.orderNumbers_nsprefix_ + ':' if (UseCapturedNS_ and self.orderNumbers_nsprefix_) else ''
            self.orderNumbers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='orderNumbers', pretty_print=pretty_print)
        if self.deliveryNotes is not None:
            namespaceprefix_ = self.deliveryNotes_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryNotes_nsprefix_) else ''
            self.deliveryNotes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deliveryNotes', pretty_print=pretty_print)
        if self.shippingDates is not None:
            namespaceprefix_ = self.shippingDates_nsprefix_ + ':' if (UseCapturedNS_ and self.shippingDates_nsprefix_) else ''
            self.shippingDates.export(outfile, level, namespaceprefix_, namespacedef_='', name_='shippingDates', pretty_print=pretty_print)
        if self.contractNumbers is not None:
            namespaceprefix_ = self.contractNumbers_nsprefix_ + ':' if (UseCapturedNS_ and self.contractNumbers_nsprefix_) else ''
            self.contractNumbers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contractNumbers', pretty_print=pretty_print)
        if self.supplierCompanyCodes is not None:
            namespaceprefix_ = self.supplierCompanyCodes_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierCompanyCodes_nsprefix_) else ''
            self.supplierCompanyCodes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supplierCompanyCodes', pretty_print=pretty_print)
        if self.customerCompanyCodes is not None:
            namespaceprefix_ = self.customerCompanyCodes_nsprefix_ + ':' if (UseCapturedNS_ and self.customerCompanyCodes_nsprefix_) else ''
            self.customerCompanyCodes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='customerCompanyCodes', pretty_print=pretty_print)
        if self.dealerCodes is not None:
            namespaceprefix_ = self.dealerCodes_nsprefix_ + ':' if (UseCapturedNS_ and self.dealerCodes_nsprefix_) else ''
            self.dealerCodes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dealerCodes', pretty_print=pretty_print)
        if self.costCenters is not None:
            namespaceprefix_ = self.costCenters_nsprefix_ + ':' if (UseCapturedNS_ and self.costCenters_nsprefix_) else ''
            self.costCenters.export(outfile, level, namespaceprefix_, namespacedef_='', name_='costCenters', pretty_print=pretty_print)
        if self.projectNumbers is not None:
            namespaceprefix_ = self.projectNumbers_nsprefix_ + ':' if (UseCapturedNS_ and self.projectNumbers_nsprefix_) else ''
            self.projectNumbers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='projectNumbers', pretty_print=pretty_print)
        if self.generalLedgerAccountNumbers is not None:
            namespaceprefix_ = self.generalLedgerAccountNumbers_nsprefix_ + ':' if (UseCapturedNS_ and self.generalLedgerAccountNumbers_nsprefix_) else ''
            self.generalLedgerAccountNumbers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generalLedgerAccountNumbers', pretty_print=pretty_print)
        if self.glnNumbersSupplier is not None:
            namespaceprefix_ = self.glnNumbersSupplier_nsprefix_ + ':' if (UseCapturedNS_ and self.glnNumbersSupplier_nsprefix_) else ''
            self.glnNumbersSupplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glnNumbersSupplier', pretty_print=pretty_print)
        if self.glnNumbersCustomer is not None:
            namespaceprefix_ = self.glnNumbersCustomer_nsprefix_ + ':' if (UseCapturedNS_ and self.glnNumbersCustomer_nsprefix_) else ''
            self.glnNumbersCustomer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='glnNumbersCustomer', pretty_print=pretty_print)
        if self.materialNumbers is not None:
            namespaceprefix_ = self.materialNumbers_nsprefix_ + ':' if (UseCapturedNS_ and self.materialNumbers_nsprefix_) else ''
            self.materialNumbers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='materialNumbers', pretty_print=pretty_print)
        if self.itemNumbers is not None:
            namespaceprefix_ = self.itemNumbers_nsprefix_ + ':' if (UseCapturedNS_ and self.itemNumbers_nsprefix_) else ''
            self.itemNumbers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='itemNumbers', pretty_print=pretty_print)
        if self.ekaerIds is not None:
            namespaceprefix_ = self.ekaerIds_nsprefix_ + ':' if (UseCapturedNS_ and self.ekaerIds_nsprefix_) else ''
            self.ekaerIds.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ekaerIds', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ConventionalInvoiceInfoType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.orderNumbers is not None:
            orderNumbers_ = self.orderNumbers
            orderNumbers_.to_etree(element, name_='orderNumbers', mapping_=mapping_, nsmap_=nsmap_)
        if self.deliveryNotes is not None:
            deliveryNotes_ = self.deliveryNotes
            deliveryNotes_.to_etree(element, name_='deliveryNotes', mapping_=mapping_, nsmap_=nsmap_)
        if self.shippingDates is not None:
            shippingDates_ = self.shippingDates
            shippingDates_.to_etree(element, name_='shippingDates', mapping_=mapping_, nsmap_=nsmap_)
        if self.contractNumbers is not None:
            contractNumbers_ = self.contractNumbers
            contractNumbers_.to_etree(element, name_='contractNumbers', mapping_=mapping_, nsmap_=nsmap_)
        if self.supplierCompanyCodes is not None:
            supplierCompanyCodes_ = self.supplierCompanyCodes
            supplierCompanyCodes_.to_etree(element, name_='supplierCompanyCodes', mapping_=mapping_, nsmap_=nsmap_)
        if self.customerCompanyCodes is not None:
            customerCompanyCodes_ = self.customerCompanyCodes
            customerCompanyCodes_.to_etree(element, name_='customerCompanyCodes', mapping_=mapping_, nsmap_=nsmap_)
        if self.dealerCodes is not None:
            dealerCodes_ = self.dealerCodes
            dealerCodes_.to_etree(element, name_='dealerCodes', mapping_=mapping_, nsmap_=nsmap_)
        if self.costCenters is not None:
            costCenters_ = self.costCenters
            costCenters_.to_etree(element, name_='costCenters', mapping_=mapping_, nsmap_=nsmap_)
        if self.projectNumbers is not None:
            projectNumbers_ = self.projectNumbers
            projectNumbers_.to_etree(element, name_='projectNumbers', mapping_=mapping_, nsmap_=nsmap_)
        if self.generalLedgerAccountNumbers is not None:
            generalLedgerAccountNumbers_ = self.generalLedgerAccountNumbers
            generalLedgerAccountNumbers_.to_etree(element, name_='generalLedgerAccountNumbers', mapping_=mapping_, nsmap_=nsmap_)
        if self.glnNumbersSupplier is not None:
            glnNumbersSupplier_ = self.glnNumbersSupplier
            glnNumbersSupplier_.to_etree(element, name_='glnNumbersSupplier', mapping_=mapping_, nsmap_=nsmap_)
        if self.glnNumbersCustomer is not None:
            glnNumbersCustomer_ = self.glnNumbersCustomer
            glnNumbersCustomer_.to_etree(element, name_='glnNumbersCustomer', mapping_=mapping_, nsmap_=nsmap_)
        if self.materialNumbers is not None:
            materialNumbers_ = self.materialNumbers
            materialNumbers_.to_etree(element, name_='materialNumbers', mapping_=mapping_, nsmap_=nsmap_)
        if self.itemNumbers is not None:
            itemNumbers_ = self.itemNumbers
            itemNumbers_.to_etree(element, name_='itemNumbers', mapping_=mapping_, nsmap_=nsmap_)
        if self.ekaerIds is not None:
            ekaerIds_ = self.ekaerIds
            ekaerIds_.to_etree(element, name_='ekaerIds', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ConventionalInvoiceInfoType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.orderNumbers is not None:
            showIndent(outfile, level)
            outfile.write('orderNumbers=model_.OrderNumbersType(\n')
            self.orderNumbers.exportLiteral(outfile, level, name_='orderNumbers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deliveryNotes is not None:
            showIndent(outfile, level)
            outfile.write('deliveryNotes=model_.DeliveryNotesType(\n')
            self.deliveryNotes.exportLiteral(outfile, level, name_='deliveryNotes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.shippingDates is not None:
            showIndent(outfile, level)
            outfile.write('shippingDates=model_.ShippingDatesType(\n')
            self.shippingDates.exportLiteral(outfile, level, name_='shippingDates')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.contractNumbers is not None:
            showIndent(outfile, level)
            outfile.write('contractNumbers=model_.ContractNumbersType(\n')
            self.contractNumbers.exportLiteral(outfile, level, name_='contractNumbers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.supplierCompanyCodes is not None:
            showIndent(outfile, level)
            outfile.write('supplierCompanyCodes=model_.SupplierCompanyCodesType(\n')
            self.supplierCompanyCodes.exportLiteral(outfile, level, name_='supplierCompanyCodes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.customerCompanyCodes is not None:
            showIndent(outfile, level)
            outfile.write('customerCompanyCodes=model_.CustomerCompanyCodesType(\n')
            self.customerCompanyCodes.exportLiteral(outfile, level, name_='customerCompanyCodes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dealerCodes is not None:
            showIndent(outfile, level)
            outfile.write('dealerCodes=model_.DealerCodesType(\n')
            self.dealerCodes.exportLiteral(outfile, level, name_='dealerCodes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.costCenters is not None:
            showIndent(outfile, level)
            outfile.write('costCenters=model_.CostCentersType(\n')
            self.costCenters.exportLiteral(outfile, level, name_='costCenters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.projectNumbers is not None:
            showIndent(outfile, level)
            outfile.write('projectNumbers=model_.ProjectNumbersType(\n')
            self.projectNumbers.exportLiteral(outfile, level, name_='projectNumbers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generalLedgerAccountNumbers is not None:
            showIndent(outfile, level)
            outfile.write('generalLedgerAccountNumbers=model_.GeneralLedgerAccountNumbersType(\n')
            self.generalLedgerAccountNumbers.exportLiteral(outfile, level, name_='generalLedgerAccountNumbers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.glnNumbersSupplier is not None:
            showIndent(outfile, level)
            outfile.write('glnNumbersSupplier=model_.GlnNumbersType(\n')
            self.glnNumbersSupplier.exportLiteral(outfile, level, name_='glnNumbersSupplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.glnNumbersCustomer is not None:
            showIndent(outfile, level)
            outfile.write('glnNumbersCustomer=model_.GlnNumbersType(\n')
            self.glnNumbersCustomer.exportLiteral(outfile, level, name_='glnNumbersCustomer')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.materialNumbers is not None:
            showIndent(outfile, level)
            outfile.write('materialNumbers=model_.MaterialNumbersType(\n')
            self.materialNumbers.exportLiteral(outfile, level, name_='materialNumbers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.itemNumbers is not None:
            showIndent(outfile, level)
            outfile.write('itemNumbers=model_.ItemNumbersType(\n')
            self.itemNumbers.exportLiteral(outfile, level, name_='itemNumbers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ekaerIds is not None:
            showIndent(outfile, level)
            outfile.write('ekaerIds=model_.EkaerIdsType(\n')
            self.ekaerIds.exportLiteral(outfile, level, name_='ekaerIds')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'orderNumbers':
            obj_ = OrderNumbersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.orderNumbers = obj_
            obj_.original_tagname_ = 'orderNumbers'
        elif nodeName_ == 'deliveryNotes':
            obj_ = DeliveryNotesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deliveryNotes = obj_
            obj_.original_tagname_ = 'deliveryNotes'
        elif nodeName_ == 'shippingDates':
            obj_ = ShippingDatesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.shippingDates = obj_
            obj_.original_tagname_ = 'shippingDates'
        elif nodeName_ == 'contractNumbers':
            obj_ = ContractNumbersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contractNumbers = obj_
            obj_.original_tagname_ = 'contractNumbers'
        elif nodeName_ == 'supplierCompanyCodes':
            obj_ = SupplierCompanyCodesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supplierCompanyCodes = obj_
            obj_.original_tagname_ = 'supplierCompanyCodes'
        elif nodeName_ == 'customerCompanyCodes':
            obj_ = CustomerCompanyCodesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customerCompanyCodes = obj_
            obj_.original_tagname_ = 'customerCompanyCodes'
        elif nodeName_ == 'dealerCodes':
            obj_ = DealerCodesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dealerCodes = obj_
            obj_.original_tagname_ = 'dealerCodes'
        elif nodeName_ == 'costCenters':
            obj_ = CostCentersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.costCenters = obj_
            obj_.original_tagname_ = 'costCenters'
        elif nodeName_ == 'projectNumbers':
            obj_ = ProjectNumbersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.projectNumbers = obj_
            obj_.original_tagname_ = 'projectNumbers'
        elif nodeName_ == 'generalLedgerAccountNumbers':
            obj_ = GeneralLedgerAccountNumbersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generalLedgerAccountNumbers = obj_
            obj_.original_tagname_ = 'generalLedgerAccountNumbers'
        elif nodeName_ == 'glnNumbersSupplier':
            obj_ = GlnNumbersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glnNumbersSupplier = obj_
            obj_.original_tagname_ = 'glnNumbersSupplier'
        elif nodeName_ == 'glnNumbersCustomer':
            obj_ = GlnNumbersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.glnNumbersCustomer = obj_
            obj_.original_tagname_ = 'glnNumbersCustomer'
        elif nodeName_ == 'materialNumbers':
            obj_ = MaterialNumbersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.materialNumbers = obj_
            obj_.original_tagname_ = 'materialNumbers'
        elif nodeName_ == 'itemNumbers':
            obj_ = ItemNumbersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.itemNumbers = obj_
            obj_.original_tagname_ = 'itemNumbers'
        elif nodeName_ == 'ekaerIds':
            obj_ = EkaerIdsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ekaerIds = obj_
            obj_.original_tagname_ = 'ekaerIds'
# end class ConventionalInvoiceInfoType


class CostCentersType(GeneratedsSuper):
    """CostCentersType -- K
    ö
    lts
    é
    ghelyek
    Cost centers
    costCenter -- K
    ö
    lts
    é
    ghely
    Cost center

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, costCenter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if costCenter is None:
            self.costCenter = []
        else:
            self.costCenter = costCenter
        self.costCenter_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CostCentersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CostCentersType.subclass:
            return CostCentersType.subclass(*args_, **kwargs_)
        else:
            return CostCentersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_costCenter(self):
        return self.costCenter
    def set_costCenter(self, costCenter):
        self.costCenter = costCenter
    def add_costCenter(self, value):
        self.costCenter.append(value)
    def insert_costCenter_at(self, index, value):
        self.costCenter.insert(index, value)
    def replace_costCenter_at(self, index, value):
        self.costCenter[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.costCenter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='CostCentersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CostCentersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CostCentersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CostCentersType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CostCentersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CostCentersType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='CostCentersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for costCenter_ in self.costCenter:
            namespaceprefix_ = self.costCenter_nsprefix_ + ':' if (UseCapturedNS_ and self.costCenter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scostCenter>%s</%scostCenter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(costCenter_), input_name='costCenter')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='CostCentersType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for costCenter_ in self.costCenter:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}costCenter').text = self.gds_format_string(costCenter_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='CostCentersType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('costCenter=[\n')
        level += 1
        for costCenter_ in self.costCenter:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(costCenter_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'costCenter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'costCenter')
            value_ = self.gds_validate_string(value_, node, 'costCenter')
            self.costCenter.append(value_)
            self.costCenter_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.costCenter[-1])
# end class CostCentersType


class CustomerCompanyCodesType(GeneratedsSuper):
    """CustomerCompanyCodesType -- A vev
    ő
    v
    á
    llalati k
    ó
    djai
    Company codes of the customer
    customerCompanyCode -- A vev
    ő
    v
    á
    llalati k
    ó
    dja
    Company code of the customer

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, customerCompanyCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if customerCompanyCode is None:
            self.customerCompanyCode = []
        else:
            self.customerCompanyCode = customerCompanyCode
        self.customerCompanyCode_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerCompanyCodesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerCompanyCodesType.subclass:
            return CustomerCompanyCodesType.subclass(*args_, **kwargs_)
        else:
            return CustomerCompanyCodesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_customerCompanyCode(self):
        return self.customerCompanyCode
    def set_customerCompanyCode(self, customerCompanyCode):
        self.customerCompanyCode = customerCompanyCode
    def add_customerCompanyCode(self, value):
        self.customerCompanyCode.append(value)
    def insert_customerCompanyCode_at(self, index, value):
        self.customerCompanyCode.insert(index, value)
    def replace_customerCompanyCode_at(self, index, value):
        self.customerCompanyCode[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.customerCompanyCode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='CustomerCompanyCodesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerCompanyCodesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerCompanyCodesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerCompanyCodesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerCompanyCodesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerCompanyCodesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='CustomerCompanyCodesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for customerCompanyCode_ in self.customerCompanyCode:
            namespaceprefix_ = self.customerCompanyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.customerCompanyCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerCompanyCode>%s</%scustomerCompanyCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(customerCompanyCode_), input_name='customerCompanyCode')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='CustomerCompanyCodesType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for customerCompanyCode_ in self.customerCompanyCode:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}customerCompanyCode').text = self.gds_format_string(customerCompanyCode_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='CustomerCompanyCodesType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('customerCompanyCode=[\n')
        level += 1
        for customerCompanyCode_ in self.customerCompanyCode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(customerCompanyCode_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'customerCompanyCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerCompanyCode')
            value_ = self.gds_validate_string(value_, node, 'customerCompanyCode')
            self.customerCompanyCode.append(value_)
            self.customerCompanyCode_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.customerCompanyCode[-1])
# end class CustomerCompanyCodesType


class CustomerDeclarationType(GeneratedsSuper):
    """CustomerDeclarationType -- Ha az elad
    ó
    a vev
    ő
    nyilatkozata alapj
    á
    n mentes
    ü
    l a term
    é
    kd
    í
    j megfizet
    é
    se al
    ó
    l, akkor az
    é
    rintett term
    é
    k
    á
    ram
    Should the supplier, based on statement given by the purchaser, be exempted from paying product fee, then the product stream affected
    productStream -- Term
    é
    k
    á
    ram
    Product stream
    productFeeWeight -- Term
    é
    kd
    í
    j k
    ö
    teles term
    é
    k t
    ö
    mege kilogrammban
    Weight of product fee obliged product in kilogram

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, productStream=None, productFeeWeight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.productStream = productStream
        self.validate_ProductStreamType(self.productStream)
        self.productStream_nsprefix_ = None
        self.productFeeWeight = productFeeWeight
        self.validate_QuantityType(self.productFeeWeight)
        self.productFeeWeight_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerDeclarationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerDeclarationType.subclass:
            return CustomerDeclarationType.subclass(*args_, **kwargs_)
        else:
            return CustomerDeclarationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_productStream(self):
        return self.productStream
    def set_productStream(self, productStream):
        self.productStream = productStream
    def get_productFeeWeight(self):
        return self.productFeeWeight
    def set_productFeeWeight(self, productFeeWeight):
        self.productFeeWeight = productFeeWeight
    def validate_ProductStreamType(self, value):
        result = True
        # Validate type ProductStreamType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['BATTERY', 'PACKAGING', 'OTHER_PETROL', 'ELECTRONIC', 'TIRE', 'COMMERCIAL', 'PLASTIC', 'OTHER_CHEMICAL', 'PAPER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ProductStreamType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ProductStreamType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ProductStreamType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_QuantityType(self, value):
        result = True
        # Validate type QuantityType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 22:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.productStream is not None or
            self.productFeeWeight is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='CustomerDeclarationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerDeclarationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerDeclarationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerDeclarationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerDeclarationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerDeclarationType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='CustomerDeclarationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.productStream is not None:
            namespaceprefix_ = self.productStream_nsprefix_ + ':' if (UseCapturedNS_ and self.productStream_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductStream>%s</%sproductStream>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.productStream), input_name='productStream')), namespaceprefix_ , eol_))
        if self.productFeeWeight is not None:
            namespaceprefix_ = self.productFeeWeight_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeWeight_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductFeeWeight>%s</%sproductFeeWeight>%s' % (namespaceprefix_ , self.gds_format_decimal(self.productFeeWeight, input_name='productFeeWeight'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='CustomerDeclarationType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.productStream is not None:
            productStream_ = self.productStream
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productStream').text = self.gds_format_string(productStream_)
        if self.productFeeWeight is not None:
            productFeeWeight_ = self.productFeeWeight
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productFeeWeight').text = self.gds_format_decimal(productFeeWeight_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='CustomerDeclarationType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.productStream is not None:
            showIndent(outfile, level)
            outfile.write('productStream=%s,\n' % self.gds_encode(quote_python(self.productStream)))
        if self.productFeeWeight is not None:
            showIndent(outfile, level)
            outfile.write('productFeeWeight=%f,\n' % self.productFeeWeight)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'productStream':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'productStream')
            value_ = self.gds_validate_string(value_, node, 'productStream')
            self.productStream = value_
            self.productStream_nsprefix_ = child_.prefix
            # validate type ProductStreamType
            self.validate_ProductStreamType(self.productStream)
        elif nodeName_ == 'productFeeWeight' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'productFeeWeight')
            fval_ = self.gds_validate_decimal(fval_, node, 'productFeeWeight')
            self.productFeeWeight = fval_
            self.productFeeWeight_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.productFeeWeight)
# end class CustomerDeclarationType


class CustomerInfoType(GeneratedsSuper):
    """CustomerInfoType -- A vev
    ő
    adatai
    Customer data
    customerVatStatus -- Vev
    ő
    Á
    FA szerinti st
    á
    tusza
    Customers status by VAT
    customerVatData -- A vev
    ő
    Á
    FA alanyis
    á
    gi adatai
    VAT subjectivity data of the customer
    customerName -- A vev
    ő
    neve
    Name of the customer
    customerAddress -- A vev
    ő
    c
    í
    me
    Address of the customer
    customerBankAccountNumber -- Vev
    ő
    banksz
    á
    mlasz
    á
    ma
    Bank account number of the customer

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, customerVatStatus=None, customerVatData=None, customerName=None, customerAddress=None, customerBankAccountNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.customerVatStatus = customerVatStatus
        self.validate_CustomerVatStatusType(self.customerVatStatus)
        self.customerVatStatus_nsprefix_ = None
        self.customerVatData = customerVatData
        self.customerVatData_nsprefix_ = None
        self.customerName = customerName
        self.validate_SimpleText512NotBlankType(self.customerName)
        self.customerName_nsprefix_ = "common"
        self.customerAddress = customerAddress
        self.customerAddress_nsprefix_ = "base"
        self.customerBankAccountNumber = customerBankAccountNumber
        self.validate_BankAccountNumberType(self.customerBankAccountNumber)
        self.customerBankAccountNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerInfoType.subclass:
            return CustomerInfoType.subclass(*args_, **kwargs_)
        else:
            return CustomerInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_customerVatStatus(self):
        return self.customerVatStatus
    def set_customerVatStatus(self, customerVatStatus):
        self.customerVatStatus = customerVatStatus
    def get_customerVatData(self):
        return self.customerVatData
    def set_customerVatData(self, customerVatData):
        self.customerVatData = customerVatData
    def get_customerName(self):
        return self.customerName
    def set_customerName(self, customerName):
        self.customerName = customerName
    def get_customerAddress(self):
        return self.customerAddress
    def set_customerAddress(self, customerAddress):
        self.customerAddress = customerAddress
    def get_customerBankAccountNumber(self):
        return self.customerBankAccountNumber
    def set_customerBankAccountNumber(self, customerBankAccountNumber):
        self.customerBankAccountNumber = customerBankAccountNumber
    def validate_CustomerVatStatusType(self, value):
        result = True
        # Validate type CustomerVatStatusType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['DOMESTIC', 'OTHER', 'PRIVATE_PERSON']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CustomerVatStatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CustomerVatStatusType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CustomerVatStatusType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_BankAccountNumberType(self, value):
        result = True
        # Validate type BankAccountNumberType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 34:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on BankAccountNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on BankAccountNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on BankAccountNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on BankAccountNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_BankAccountNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_BankAccountNumberType_patterns_, ))
                result = False
        return result
    validate_BankAccountNumberType_patterns_ = [['^([0-9]{8}[-][0-9]{8}[-][0-9]{8}|[0-9]{8}[-][0-9]{8}|[A-Z]{2}[0-9]{2}[0-9A-Za-z]{11,30})$']]
    def _hasContent(self):
        if (
            self.customerVatStatus is not None or
            self.customerVatData is not None or
            self.customerName is not None or
            self.customerAddress is not None or
            self.customerBankAccountNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='CustomerInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerInfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerInfoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerInfoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='CustomerInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.customerVatStatus is not None:
            namespaceprefix_ = self.customerVatStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.customerVatStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerVatStatus>%s</%scustomerVatStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.customerVatStatus), input_name='customerVatStatus')), namespaceprefix_ , eol_))
        if self.customerVatData is not None:
            namespaceprefix_ = self.customerVatData_nsprefix_ + ':' if (UseCapturedNS_ and self.customerVatData_nsprefix_) else ''
            self.customerVatData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='customerVatData', pretty_print=pretty_print)
        if self.customerName is not None:
            namespaceprefix_ = self.customerName_nsprefix_ + ':' if (UseCapturedNS_ and self.customerName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerName>%s</%scustomerName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.customerName), input_name='customerName')), namespaceprefix_ , eol_))
        if self.customerAddress is not None:
            namespaceprefix_ = self.customerAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.customerAddress_nsprefix_) else ''
            self.customerAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='customerAddress', pretty_print=pretty_print)
        if self.customerBankAccountNumber is not None:
            namespaceprefix_ = self.customerBankAccountNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.customerBankAccountNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerBankAccountNumber>%s</%scustomerBankAccountNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.customerBankAccountNumber), input_name='customerBankAccountNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='CustomerInfoType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.customerVatStatus is not None:
            customerVatStatus_ = self.customerVatStatus
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}customerVatStatus').text = self.gds_format_string(customerVatStatus_)
        if self.customerVatData is not None:
            customerVatData_ = self.customerVatData
            customerVatData_.to_etree(element, name_='customerVatData', mapping_=mapping_, nsmap_=nsmap_)
        if self.customerName is not None:
            customerName_ = self.customerName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}customerName').text = self.gds_format_string(customerName_)
        if self.customerAddress is not None:
            customerAddress_ = self.customerAddress
            customerAddress_.to_etree(element, name_='customerAddress', mapping_=mapping_, nsmap_=nsmap_)
        if self.customerBankAccountNumber is not None:
            customerBankAccountNumber_ = self.customerBankAccountNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}customerBankAccountNumber').text = self.gds_format_string(customerBankAccountNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='CustomerInfoType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.customerVatStatus is not None:
            showIndent(outfile, level)
            outfile.write('customerVatStatus=%s,\n' % self.gds_encode(quote_python(self.customerVatStatus)))
        if self.customerVatData is not None:
            showIndent(outfile, level)
            outfile.write('customerVatData=model_.CustomerVatDataType(\n')
            self.customerVatData.exportLiteral(outfile, level, name_='customerVatData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.customerName is not None:
            showIndent(outfile, level)
            outfile.write('customerName=%s,\n' % self.gds_encode(quote_python(self.customerName)))
        if self.customerAddress is not None:
            showIndent(outfile, level)
            outfile.write('customerAddress=model_.AddressType(\n')
            self.customerAddress.exportLiteral(outfile, level, name_='customerAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.customerBankAccountNumber is not None:
            showIndent(outfile, level)
            outfile.write('customerBankAccountNumber=%s,\n' % self.gds_encode(quote_python(self.customerBankAccountNumber)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'customerVatStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerVatStatus')
            value_ = self.gds_validate_string(value_, node, 'customerVatStatus')
            self.customerVatStatus = value_
            self.customerVatStatus_nsprefix_ = child_.prefix
            # validate type CustomerVatStatusType
            self.validate_CustomerVatStatusType(self.customerVatStatus)
        elif nodeName_ == 'customerVatData':
            obj_ = CustomerVatDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customerVatData = obj_
            obj_.original_tagname_ = 'customerVatData'
        elif nodeName_ == 'customerName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerName')
            value_ = self.gds_validate_string(value_, node, 'customerName')
            self.customerName = value_
            self.customerName_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.customerName)
        elif nodeName_ == 'customerAddress':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customerAddress = obj_
            obj_.original_tagname_ = 'customerAddress'
        elif nodeName_ == 'customerBankAccountNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerBankAccountNumber')
            value_ = self.gds_validate_string(value_, node, 'customerBankAccountNumber')
            self.customerBankAccountNumber = value_
            self.customerBankAccountNumber_nsprefix_ = child_.prefix
            # validate type BankAccountNumberType
            self.validate_BankAccountNumberType(self.customerBankAccountNumber)
# end class CustomerInfoType


class CustomerTaxNumberType(TaxNumberType):
    """CustomerTaxNumberType -- Ad
    ó
    sz
    á
    m, amely alatt a sz
    á
    ml
    á
    n szerepl
    ő
    term
    é
    kbeszerz
    é
    s vagy szolg
    á
    ltat
    á
    s ig
    é
    nybev
    é
    tele t
    ö
    rt
    é
    nt. Lehet csoportazonos
    í
    t
    ó
    sz
    á
    m is
    Tax number or group identification number, under which the purchase of goods or services is done
    groupMemberTaxNumber -- Csoport tag ad
    ó
    sz
    á
    ma, ha a term
    é
    kbeszerz
    é
    s vagy szolg
    á
    ltat
    á
    s ig
    é
    nybev
    é
    tele csoportazonos
    í
    t
    ó
    sz
    á
    m alatt t
    ö
    rt
    é
    nt
    Tax number of group member, when the purchase of goods or services is done under group identification number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TaxNumberType
    def __init__(self, taxpayerId=None, vatCode=None, countyCode=None, groupMemberTaxNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CustomerTaxNumberType"), self).__init__(taxpayerId, vatCode, countyCode,  **kwargs_)
        self.groupMemberTaxNumber = groupMemberTaxNumber
        self.groupMemberTaxNumber_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerTaxNumberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerTaxNumberType.subclass:
            return CustomerTaxNumberType.subclass(*args_, **kwargs_)
        else:
            return CustomerTaxNumberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_groupMemberTaxNumber(self):
        return self.groupMemberTaxNumber
    def set_groupMemberTaxNumber(self, groupMemberTaxNumber):
        self.groupMemberTaxNumber = groupMemberTaxNumber
    def _hasContent(self):
        if (
            self.groupMemberTaxNumber is not None or
            super(CustomerTaxNumberType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='CustomerTaxNumberType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerTaxNumberType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerTaxNumberType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerTaxNumberType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerTaxNumberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerTaxNumberType'):
        super(CustomerTaxNumberType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerTaxNumberType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='CustomerTaxNumberType', fromsubclass_=False, pretty_print=True):
        super(CustomerTaxNumberType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.groupMemberTaxNumber is not None:
            namespaceprefix_ = self.groupMemberTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.groupMemberTaxNumber_nsprefix_) else ''
            self.groupMemberTaxNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='groupMemberTaxNumber', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CustomerTaxNumberType', mapping_=None, nsmap_=None):
        element = super(CustomerTaxNumberType, self).to_etree(parent_element, name_, mapping_)
        if self.groupMemberTaxNumber is not None:
            groupMemberTaxNumber_ = self.groupMemberTaxNumber
            groupMemberTaxNumber_.to_etree(element, name_='groupMemberTaxNumber', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='CustomerTaxNumberType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CustomerTaxNumberType, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(CustomerTaxNumberType, self)._exportLiteralChildren(outfile, level, name_)
        if self.groupMemberTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('groupMemberTaxNumber=model_.TaxNumberType(\n')
            self.groupMemberTaxNumber.exportLiteral(outfile, level, name_='groupMemberTaxNumber')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CustomerTaxNumberType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'groupMemberTaxNumber':
            class_obj_ = self.get_class_obj_(child_, TaxNumberType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groupMemberTaxNumber = obj_
            obj_.original_tagname_ = 'groupMemberTaxNumber'
        super(CustomerTaxNumberType, self)._buildChildren(child_, node, nodeName_, True)
# end class CustomerTaxNumberType


class CustomerVatDataType(GeneratedsSuper):
    """CustomerVatDataType -- A vev
    ő
    Á
    FA alanyis
    á
    gi adatai
    VAT subjectivity data of the customer
    customerTaxNumber -- Belf
    ö
    ldi ad
    ó
    sz
    á
    m, amely alatt a sz
    á
    ml
    á
    n szerepl
    ő
    term
    é
    kbeszerz
    é
    s vagy szolg
    á
    ltat
    á
    s ig
    é
    nybev
    é
    tele t
    ö
    rt
    é
    nt. Lehet csoportazonos
    í
    t
    ó
    sz
    á
    m is
    Domestic tax number or group identification number, under which the purchase of goods or services is done
    communityVatNumber -- K
    ö
    z
    ö
    ss
    é
    gi ad
    ó
    sz
    á
    m
    Community tax number
    thirdStateTaxId -- Harmadik orsz
    á
    gbeli ad
    ó
    azonos
    í
    t
    ó
    Third state tax identification number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, customerTaxNumber=None, communityVatNumber=None, thirdStateTaxId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.customerTaxNumber = customerTaxNumber
        self.customerTaxNumber_nsprefix_ = None
        self.communityVatNumber = communityVatNumber
        self.validate_CommunityVatNumberType(self.communityVatNumber)
        self.communityVatNumber_nsprefix_ = "common"
        self.thirdStateTaxId = thirdStateTaxId
        self.validate_SimpleText50NotBlankType(self.thirdStateTaxId)
        self.thirdStateTaxId_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerVatDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerVatDataType.subclass:
            return CustomerVatDataType.subclass(*args_, **kwargs_)
        else:
            return CustomerVatDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_customerTaxNumber(self):
        return self.customerTaxNumber
    def set_customerTaxNumber(self, customerTaxNumber):
        self.customerTaxNumber = customerTaxNumber
    def get_communityVatNumber(self):
        return self.communityVatNumber
    def set_communityVatNumber(self, communityVatNumber):
        self.communityVatNumber = communityVatNumber
    def get_thirdStateTaxId(self):
        return self.thirdStateTaxId
    def set_thirdStateTaxId(self, thirdStateTaxId):
        self.thirdStateTaxId = thirdStateTaxId
    def validate_CommunityVatNumberType(self, value):
        result = True
        # Validate type CommunityVatNumberType, a restriction on AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CommunityVatNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CommunityVatNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CommunityVatNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CommunityVatNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CommunityVatNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CommunityVatNumberType_patterns_, ))
                result = False
        return result
    validate_CommunityVatNumberType_patterns_ = [['^([A-Z]{2}[0-9A-Z]{2,13})$']]
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.customerTaxNumber is not None or
            self.communityVatNumber is not None or
            self.thirdStateTaxId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='CustomerVatDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerVatDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerVatDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerVatDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerVatDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerVatDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='CustomerVatDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.customerTaxNumber is not None:
            namespaceprefix_ = self.customerTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.customerTaxNumber_nsprefix_) else ''
            self.customerTaxNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='customerTaxNumber', pretty_print=pretty_print)
        if self.communityVatNumber is not None:
            namespaceprefix_ = self.communityVatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.communityVatNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunityVatNumber>%s</%scommunityVatNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.communityVatNumber), input_name='communityVatNumber')), namespaceprefix_ , eol_))
        if self.thirdStateTaxId is not None:
            namespaceprefix_ = self.thirdStateTaxId_nsprefix_ + ':' if (UseCapturedNS_ and self.thirdStateTaxId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sthirdStateTaxId>%s</%sthirdStateTaxId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.thirdStateTaxId), input_name='thirdStateTaxId')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='CustomerVatDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.customerTaxNumber is not None:
            customerTaxNumber_ = self.customerTaxNumber
            customerTaxNumber_.to_etree(element, name_='customerTaxNumber', mapping_=mapping_, nsmap_=nsmap_)
        if self.communityVatNumber is not None:
            communityVatNumber_ = self.communityVatNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}communityVatNumber').text = self.gds_format_string(communityVatNumber_)
        if self.thirdStateTaxId is not None:
            thirdStateTaxId_ = self.thirdStateTaxId
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}thirdStateTaxId').text = self.gds_format_string(thirdStateTaxId_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='CustomerVatDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.customerTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('customerTaxNumber=model_.CustomerTaxNumberType(\n')
            self.customerTaxNumber.exportLiteral(outfile, level, name_='customerTaxNumber')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.communityVatNumber is not None:
            showIndent(outfile, level)
            outfile.write('communityVatNumber=%s,\n' % self.gds_encode(quote_python(self.communityVatNumber)))
        if self.thirdStateTaxId is not None:
            showIndent(outfile, level)
            outfile.write('thirdStateTaxId=%s,\n' % self.gds_encode(quote_python(self.thirdStateTaxId)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'customerTaxNumber':
            obj_ = CustomerTaxNumberType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customerTaxNumber = obj_
            obj_.original_tagname_ = 'customerTaxNumber'
        elif nodeName_ == 'communityVatNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'communityVatNumber')
            value_ = self.gds_validate_string(value_, node, 'communityVatNumber')
            self.communityVatNumber = value_
            self.communityVatNumber_nsprefix_ = child_.prefix
            # validate type CommunityVatNumberType
            self.validate_CommunityVatNumberType(self.communityVatNumber)
        elif nodeName_ == 'thirdStateTaxId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'thirdStateTaxId')
            value_ = self.gds_validate_string(value_, node, 'thirdStateTaxId')
            self.thirdStateTaxId = value_
            self.thirdStateTaxId_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.thirdStateTaxId)
# end class CustomerVatDataType


class DealerCodesType(GeneratedsSuper):
    """DealerCodesType -- Besz
    á
    ll
    í
    t
    ó
    k
    ó
    dok
    Dealer codes
    dealerCode -- Besz
    á
    ll
    í
    t
    ó
    k
    ó
    d
    Dealer code

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dealerCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if dealerCode is None:
            self.dealerCode = []
        else:
            self.dealerCode = dealerCode
        self.dealerCode_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DealerCodesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DealerCodesType.subclass:
            return DealerCodesType.subclass(*args_, **kwargs_)
        else:
            return DealerCodesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dealerCode(self):
        return self.dealerCode
    def set_dealerCode(self, dealerCode):
        self.dealerCode = dealerCode
    def add_dealerCode(self, value):
        self.dealerCode.append(value)
    def insert_dealerCode_at(self, index, value):
        self.dealerCode.insert(index, value)
    def replace_dealerCode_at(self, index, value):
        self.dealerCode[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.dealerCode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='DealerCodesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DealerCodesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DealerCodesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DealerCodesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DealerCodesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DealerCodesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='DealerCodesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dealerCode_ in self.dealerCode:
            namespaceprefix_ = self.dealerCode_nsprefix_ + ':' if (UseCapturedNS_ and self.dealerCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdealerCode>%s</%sdealerCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(dealerCode_), input_name='dealerCode')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='DealerCodesType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for dealerCode_ in self.dealerCode:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}dealerCode').text = self.gds_format_string(dealerCode_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DealerCodesType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('dealerCode=[\n')
        level += 1
        for dealerCode_ in self.dealerCode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(dealerCode_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dealerCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dealerCode')
            value_ = self.gds_validate_string(value_, node, 'dealerCode')
            self.dealerCode.append(value_)
            self.dealerCode_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.dealerCode[-1])
# end class DealerCodesType


class DeliveryNotesType(GeneratedsSuper):
    """DeliveryNotesType -- Sz
    á
    ll
    í
    t
    ó
    lev
    é
    l sz
    á
    mok
    Delivery notes
    deliveryNote -- Sz
    á
    ll
    í
    t
    ó
    lev
    é
    l sz
    á
    m
    Delivery note

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, deliveryNote=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if deliveryNote is None:
            self.deliveryNote = []
        else:
            self.deliveryNote = deliveryNote
        self.deliveryNote_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryNotesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryNotesType.subclass:
            return DeliveryNotesType.subclass(*args_, **kwargs_)
        else:
            return DeliveryNotesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_deliveryNote(self):
        return self.deliveryNote
    def set_deliveryNote(self, deliveryNote):
        self.deliveryNote = deliveryNote
    def add_deliveryNote(self, value):
        self.deliveryNote.append(value)
    def insert_deliveryNote_at(self, index, value):
        self.deliveryNote.insert(index, value)
    def replace_deliveryNote_at(self, index, value):
        self.deliveryNote[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.deliveryNote
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='DeliveryNotesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeliveryNotesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeliveryNotesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeliveryNotesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeliveryNotesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DeliveryNotesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='DeliveryNotesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for deliveryNote_ in self.deliveryNote:
            namespaceprefix_ = self.deliveryNote_nsprefix_ + ':' if (UseCapturedNS_ and self.deliveryNote_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeliveryNote>%s</%sdeliveryNote>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(deliveryNote_), input_name='deliveryNote')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='DeliveryNotesType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for deliveryNote_ in self.deliveryNote:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}deliveryNote').text = self.gds_format_string(deliveryNote_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DeliveryNotesType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('deliveryNote=[\n')
        level += 1
        for deliveryNote_ in self.deliveryNote:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(deliveryNote_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'deliveryNote':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'deliveryNote')
            value_ = self.gds_validate_string(value_, node, 'deliveryNote')
            self.deliveryNote.append(value_)
            self.deliveryNote_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.deliveryNote[-1])
# end class DeliveryNotesType


class DetailedReasonType(GeneratedsSuper):
    """DetailedReasonType -- Mentess
    é
    g, kiv
    é
    tel r
    é
    szletes indokol
    á
    sa
    Detailed justification of exemption
    case -- Az eset le
    í
    r
    á
    sa k
    ó
    ddal
    Case notation with code
    reason -- Az eset le
    í
    r
    á
    sa sz
    ö
    veggel
    Case notation with text

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, case=None, reason=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.case = case
        self.validate_SimpleText50NotBlankType(self.case)
        self.case_nsprefix_ = "common"
        self.reason = reason
        self.validate_SimpleText200NotBlankType(self.reason)
        self.reason_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailedReasonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailedReasonType.subclass:
            return DetailedReasonType.subclass(*args_, **kwargs_)
        else:
            return DetailedReasonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_case(self):
        return self.case
    def set_case(self, case):
        self.case = case
    def get_reason(self):
        return self.reason
    def set_reason(self, reason):
        self.reason = reason
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText200NotBlankType(self, value):
        result = True
        # Validate type SimpleText200NotBlankType, a restriction on AtomicStringType200.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText200NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText200NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText200NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText200NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText200NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.case is not None or
            self.reason is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='DetailedReasonType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DetailedReasonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DetailedReasonType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DetailedReasonType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DetailedReasonType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DetailedReasonType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='DetailedReasonType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.case is not None:
            namespaceprefix_ = self.case_nsprefix_ + ':' if (UseCapturedNS_ and self.case_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scase>%s</%scase>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.case), input_name='case')), namespaceprefix_ , eol_))
        if self.reason is not None:
            namespaceprefix_ = self.reason_nsprefix_ + ':' if (UseCapturedNS_ and self.reason_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreason>%s</%sreason>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.reason), input_name='reason')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='DetailedReasonType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.case is not None:
            case_ = self.case
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}case').text = self.gds_format_string(case_)
        if self.reason is not None:
            reason_ = self.reason
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}reason').text = self.gds_format_string(reason_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DetailedReasonType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.case is not None:
            showIndent(outfile, level)
            outfile.write('case=%s,\n' % self.gds_encode(quote_python(self.case)))
        if self.reason is not None:
            showIndent(outfile, level)
            outfile.write('reason=%s,\n' % self.gds_encode(quote_python(self.reason)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'case':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'case')
            value_ = self.gds_validate_string(value_, node, 'case')
            self.case = value_
            self.case_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.case)
        elif nodeName_ == 'reason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reason')
            value_ = self.gds_validate_string(value_, node, 'reason')
            self.reason = value_
            self.reason_nsprefix_ = child_.prefix
            # validate type SimpleText200NotBlankType
            self.validate_SimpleText200NotBlankType(self.reason)
# end class DetailedReasonType


class DieselOilPurchaseType(GeneratedsSuper):
    """DieselOilPurchaseType -- G
    á
    zolaj ad
    ó
    zottan t
    ö
    rt
    é
    n
    ő
    beszerz
    é
    s
    é
    nek adatai
    –
    45/2016 (XI. 29.) NGM rendelet 75.
    §
    (1) a)
    Data of gas oil acquisition after taxation
    –
    point a), paragraph (1) of Section 75 of the NGM Decree No. 45/2016. (XI. 29.)
    purchaseLocation -- G
    á
    zolaj beszerz
    é
    s helye
    Place of purchase of the gas oil
    purchaseDate -- G
    á
    zolaj beszerz
    é
    s d
    á
    tuma
    Date of purchase of gas oil
    vehicleRegistrationNumber -- Kereskedelmi j
    á
    rm
    ű
    forgalmi rendsz
    á
    ma (csak bet
    ű
    k
    é
    s sz
    á
    mok)
    Registration number of vehicle (letters and numbers only)
    dieselOilQuantity -- G
    é
    pi b
    é
    rmunka-szolg
    á
    ltat
    á
    s sor
    á
    n felhaszn
    á
    lt g
    á
    zolaj mennyis
    é
    ge literben
    –
    J
    ö
    t. 117.
    §
    (2)
    Ford
    í
    tand
    ó
    helyett: Quantity of diesel oil used for contract work and machinery hire service in liter
    –
    Act LXVIII of 2016 on Excise Tax section 117 (2)

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, purchaseLocation=None, purchaseDate=None, vehicleRegistrationNumber=None, dieselOilQuantity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.purchaseLocation = purchaseLocation
        self.purchaseLocation_nsprefix_ = "base"
        if isinstance(purchaseDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(purchaseDate, '%Y-%m-%d').date()
        else:
            initvalue_ = purchaseDate
        self.purchaseDate = initvalue_
        self.purchaseDate_nsprefix_ = "base"
        self.vehicleRegistrationNumber = vehicleRegistrationNumber
        self.validate_PlateNumberType(self.vehicleRegistrationNumber)
        self.vehicleRegistrationNumber_nsprefix_ = "common"
        self.dieselOilQuantity = dieselOilQuantity
        self.validate_QuantityType(self.dieselOilQuantity)
        self.dieselOilQuantity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DieselOilPurchaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DieselOilPurchaseType.subclass:
            return DieselOilPurchaseType.subclass(*args_, **kwargs_)
        else:
            return DieselOilPurchaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_purchaseLocation(self):
        return self.purchaseLocation
    def set_purchaseLocation(self, purchaseLocation):
        self.purchaseLocation = purchaseLocation
    def get_purchaseDate(self):
        return self.purchaseDate
    def set_purchaseDate(self, purchaseDate):
        self.purchaseDate = purchaseDate
    def get_vehicleRegistrationNumber(self):
        return self.vehicleRegistrationNumber
    def set_vehicleRegistrationNumber(self, vehicleRegistrationNumber):
        self.vehicleRegistrationNumber = vehicleRegistrationNumber
    def get_dieselOilQuantity(self):
        return self.dieselOilQuantity
    def set_dieselOilQuantity(self, dieselOilQuantity):
        self.dieselOilQuantity = dieselOilQuantity
    def validate_InvoiceDateType(self, value):
        result = True
        # Validate type InvoiceDateType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.strptime('2010-01-01', '%Y-%m-%d').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceDateType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceDateType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceDateType_patterns_, ))
                result = False
        return result
    validate_InvoiceDateType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2})$']]
    def validate_PlateNumberType(self, value):
        result = True
        # Validate type PlateNumberType, a restriction on AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PlateNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PlateNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PlateNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PlateNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_PlateNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_PlateNumberType_patterns_, ))
                result = False
        return result
    validate_PlateNumberType_patterns_ = [['^([A-Z0-9ÖŐÜŰ]{2,30})$']]
    def validate_QuantityType(self, value):
        result = True
        # Validate type QuantityType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 22:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.purchaseLocation is not None or
            self.purchaseDate is not None or
            self.vehicleRegistrationNumber is not None or
            self.dieselOilQuantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='DieselOilPurchaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DieselOilPurchaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DieselOilPurchaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DieselOilPurchaseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DieselOilPurchaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DieselOilPurchaseType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='DieselOilPurchaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.purchaseLocation is not None:
            namespaceprefix_ = self.purchaseLocation_nsprefix_ + ':' if (UseCapturedNS_ and self.purchaseLocation_nsprefix_) else ''
            self.purchaseLocation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='purchaseLocation', pretty_print=pretty_print)
        if self.purchaseDate is not None:
            namespaceprefix_ = self.purchaseDate_nsprefix_ + ':' if (UseCapturedNS_ and self.purchaseDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spurchaseDate>%s</%spurchaseDate>%s' % (namespaceprefix_ , self.gds_format_date(self.purchaseDate, input_name='purchaseDate'), namespaceprefix_ , eol_))
        if self.vehicleRegistrationNumber is not None:
            namespaceprefix_ = self.vehicleRegistrationNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.vehicleRegistrationNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svehicleRegistrationNumber>%s</%svehicleRegistrationNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vehicleRegistrationNumber), input_name='vehicleRegistrationNumber')), namespaceprefix_ , eol_))
        if self.dieselOilQuantity is not None:
            namespaceprefix_ = self.dieselOilQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.dieselOilQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdieselOilQuantity>%s</%sdieselOilQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.dieselOilQuantity, input_name='dieselOilQuantity'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='DieselOilPurchaseType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.purchaseLocation is not None:
            purchaseLocation_ = self.purchaseLocation
            purchaseLocation_.to_etree(element, name_='purchaseLocation', mapping_=mapping_, nsmap_=nsmap_)
        if self.purchaseDate is not None:
            purchaseDate_ = self.purchaseDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}purchaseDate').text = self.gds_format_date(purchaseDate_)
        if self.vehicleRegistrationNumber is not None:
            vehicleRegistrationNumber_ = self.vehicleRegistrationNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vehicleRegistrationNumber').text = self.gds_format_string(vehicleRegistrationNumber_)
        if self.dieselOilQuantity is not None:
            dieselOilQuantity_ = self.dieselOilQuantity
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}dieselOilQuantity').text = self.gds_format_decimal(dieselOilQuantity_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DieselOilPurchaseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.purchaseLocation is not None:
            showIndent(outfile, level)
            outfile.write('purchaseLocation=model_.SimpleAddressType(\n')
            self.purchaseLocation.exportLiteral(outfile, level, name_='purchaseLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.purchaseDate is not None:
            showIndent(outfile, level)
            outfile.write('purchaseDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.purchaseDate, input_name='purchaseDate'))
        if self.vehicleRegistrationNumber is not None:
            showIndent(outfile, level)
            outfile.write('vehicleRegistrationNumber=%s,\n' % self.gds_encode(quote_python(self.vehicleRegistrationNumber)))
        if self.dieselOilQuantity is not None:
            showIndent(outfile, level)
            outfile.write('dieselOilQuantity=%f,\n' % self.dieselOilQuantity)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'purchaseLocation':
            obj_ = SimpleAddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.purchaseLocation = obj_
            obj_.original_tagname_ = 'purchaseLocation'
        elif nodeName_ == 'purchaseDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.purchaseDate = dval_
            self.purchaseDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.purchaseDate)
        elif nodeName_ == 'vehicleRegistrationNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vehicleRegistrationNumber')
            value_ = self.gds_validate_string(value_, node, 'vehicleRegistrationNumber')
            self.vehicleRegistrationNumber = value_
            self.vehicleRegistrationNumber_nsprefix_ = child_.prefix
            # validate type PlateNumberType
            self.validate_PlateNumberType(self.vehicleRegistrationNumber)
        elif nodeName_ == 'dieselOilQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'dieselOilQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'dieselOilQuantity')
            self.dieselOilQuantity = fval_
            self.dieselOilQuantity_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.dieselOilQuantity)
# end class DieselOilPurchaseType


class DiscountDataType(GeneratedsSuper):
    """DiscountDataType -- Á
    rengedm
    é
    ny adatok
    Discount data
    discountDescription -- Az
    á
    rengedm
    é
    ny le
    í
    r
    á
    sa
    Description of the discount
    discountValue -- T
    é
    telhez tartoz
    ó
    á
    rengedm
    é
    ny
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben, ha az egys
    é
    g
    á
    r nem tartalmazza
    Total amount of discount per item expressed in the currency of the invoice if not included in the unit price
    discountRate -- T
    é
    telhez tartoz
    ó
    á
    rengedm
    é
    ny ar
    á
    nya, ha az egys
    é
    g
    á
    r nem tartalmazza
    Rate of discount per item expressed in the currency of the invoice if not included in the unit price

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, discountDescription=None, discountValue=None, discountRate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.discountDescription = discountDescription
        self.validate_SimpleText255NotBlankType(self.discountDescription)
        self.discountDescription_nsprefix_ = "common"
        self.discountValue = discountValue
        self.validate_MonetaryType(self.discountValue)
        self.discountValue_nsprefix_ = "base"
        self.discountRate = discountRate
        self.validate_RateType(self.discountRate)
        self.discountRate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscountDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscountDataType.subclass:
            return DiscountDataType.subclass(*args_, **kwargs_)
        else:
            return DiscountDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_discountDescription(self):
        return self.discountDescription
    def set_discountDescription(self, discountDescription):
        self.discountDescription = discountDescription
    def get_discountValue(self):
        return self.discountValue
    def set_discountValue(self, discountValue):
        self.discountValue = discountValue
    def get_discountRate(self):
        return self.discountRate
    def set_discountRate(self, discountRate):
        self.discountRate = discountRate
    def validate_SimpleText255NotBlankType(self, value):
        result = True
        # Validate type SimpleText255NotBlankType, a restriction on AtomicStringType255.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText255NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText255NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText255NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText255NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText255NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_RateType(self, value):
        result = True
        # Validate type RateType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on RateType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on RateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on RateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.discountDescription is not None or
            self.discountValue is not None or
            self.discountRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='DiscountDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscountDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DiscountDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DiscountDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DiscountDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DiscountDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='DiscountDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.discountDescription is not None:
            namespaceprefix_ = self.discountDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.discountDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountDescription>%s</%sdiscountDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.discountDescription), input_name='discountDescription')), namespaceprefix_ , eol_))
        if self.discountValue is not None:
            namespaceprefix_ = self.discountValue_nsprefix_ + ':' if (UseCapturedNS_ and self.discountValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountValue>%s</%sdiscountValue>%s' % (namespaceprefix_ , self.gds_format_decimal(self.discountValue, input_name='discountValue'), namespaceprefix_ , eol_))
        if self.discountRate is not None:
            namespaceprefix_ = self.discountRate_nsprefix_ + ':' if (UseCapturedNS_ and self.discountRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountRate>%s</%sdiscountRate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.discountRate, input_name='discountRate'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='DiscountDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.discountDescription is not None:
            discountDescription_ = self.discountDescription
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}discountDescription').text = self.gds_format_string(discountDescription_)
        if self.discountValue is not None:
            discountValue_ = self.discountValue
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}discountValue').text = self.gds_format_decimal(discountValue_)
        if self.discountRate is not None:
            discountRate_ = self.discountRate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}discountRate').text = self.gds_format_decimal(discountRate_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DiscountDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.discountDescription is not None:
            showIndent(outfile, level)
            outfile.write('discountDescription=%s,\n' % self.gds_encode(quote_python(self.discountDescription)))
        if self.discountValue is not None:
            showIndent(outfile, level)
            outfile.write('discountValue=%f,\n' % self.discountValue)
        if self.discountRate is not None:
            showIndent(outfile, level)
            outfile.write('discountRate=%f,\n' % self.discountRate)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'discountDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'discountDescription')
            value_ = self.gds_validate_string(value_, node, 'discountDescription')
            self.discountDescription = value_
            self.discountDescription_nsprefix_ = child_.prefix
            # validate type SimpleText255NotBlankType
            self.validate_SimpleText255NotBlankType(self.discountDescription)
        elif nodeName_ == 'discountValue' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'discountValue')
            fval_ = self.gds_validate_decimal(fval_, node, 'discountValue')
            self.discountValue = fval_
            self.discountValue_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.discountValue)
        elif nodeName_ == 'discountRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'discountRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'discountRate')
            self.discountRate = fval_
            self.discountRate_nsprefix_ = child_.prefix
            # validate type RateType
            self.validate_RateType(self.discountRate)
# end class DiscountDataType


class EkaerIdsType(GeneratedsSuper):
    """EkaerIdsType -- EK
    Á
    ER azonos
    í
    t
    ó
    (k)
    EKAER ID-s
    ekaerId -- EK
    Á
    ER azonos
    í
    t
    ó
    EKAER numbers; EKAER stands for Electronic Trade and Transport Control System

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ekaerId=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ekaerId is None:
            self.ekaerId = []
        else:
            self.ekaerId = ekaerId
        self.ekaerId_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EkaerIdsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EkaerIdsType.subclass:
            return EkaerIdsType.subclass(*args_, **kwargs_)
        else:
            return EkaerIdsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ekaerId(self):
        return self.ekaerId
    def set_ekaerId(self, ekaerId):
        self.ekaerId = ekaerId
    def add_ekaerId(self, value):
        self.ekaerId.append(value)
    def insert_ekaerId_at(self, index, value):
        self.ekaerId.insert(index, value)
    def replace_ekaerId_at(self, index, value):
        self.ekaerId[index] = value
    def validate_EkaerIdType(self, value):
        result = True
        # Validate type EkaerIdType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on EkaerIdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on EkaerIdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_EkaerIdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_EkaerIdType_patterns_, ))
                result = False
        return result
    validate_EkaerIdType_patterns_ = [['^([E]{1}[0-9]{6}[0-9A-F]{8})$']]
    def _hasContent(self):
        if (
            self.ekaerId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='EkaerIdsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EkaerIdsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EkaerIdsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EkaerIdsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EkaerIdsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EkaerIdsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='EkaerIdsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ekaerId_ in self.ekaerId:
            namespaceprefix_ = self.ekaerId_nsprefix_ + ':' if (UseCapturedNS_ and self.ekaerId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sekaerId>%s</%sekaerId>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ekaerId_), input_name='ekaerId')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='EkaerIdsType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for ekaerId_ in self.ekaerId:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}ekaerId').text = self.gds_format_string(ekaerId_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='EkaerIdsType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ekaerId=[\n')
        level += 1
        for ekaerId_ in self.ekaerId:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(ekaerId_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ekaerId':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ekaerId')
            value_ = self.gds_validate_string(value_, node, 'ekaerId')
            self.ekaerId.append(value_)
            self.ekaerId_nsprefix_ = child_.prefix
            # validate type EkaerIdType
            self.validate_EkaerIdType(self.ekaerId[-1])
# end class EkaerIdsType


class FiscalRepresentativeType(GeneratedsSuper):
    """FiscalRepresentativeType -- A p
    é
    nz
    ü
    gyi k
    é
    pvisel
    ő
    adatai
    Fiscal representative data
    fiscalRepresentativeTaxNumber -- A p
    é
    nz
    ü
    gyi k
    é
    pvisel
    ő
    ad
    ó
    sz
    á
    ma
    Tax number of the fiscal representative
    fiscalRepresentativeName -- A p
    é
    nz
    ü
    gyi k
    é
    pvisel
    ő
    neve
    Name of the fiscal representative
    fiscalRepresentativeAddress -- P
    é
    nz
    ü
    gyi k
    é
    pvisel
    ő
    c
    í
    me
    Address of the fiscal representative
    fiscalRepresentativeBankAccountNumber -- P
    é
    nz
    ü
    gyi k
    é
    pvisel
    ő
    á
    ltal a sz
    á
    mla kibocs
    á
    t
    ó
    (elad
    ó
    ) sz
    á
    m
    á
    ra megnyitott banksz
    á
    mla banksz
    á
    mlasz
    á
    ma
    Bank account number opened by the fiscal representative for the issuer of the invoice (supplier)

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fiscalRepresentativeTaxNumber=None, fiscalRepresentativeName=None, fiscalRepresentativeAddress=None, fiscalRepresentativeBankAccountNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fiscalRepresentativeTaxNumber = fiscalRepresentativeTaxNumber
        self.fiscalRepresentativeTaxNumber_nsprefix_ = "base"
        self.fiscalRepresentativeName = fiscalRepresentativeName
        self.validate_SimpleText512NotBlankType(self.fiscalRepresentativeName)
        self.fiscalRepresentativeName_nsprefix_ = "common"
        self.fiscalRepresentativeAddress = fiscalRepresentativeAddress
        self.fiscalRepresentativeAddress_nsprefix_ = "base"
        self.fiscalRepresentativeBankAccountNumber = fiscalRepresentativeBankAccountNumber
        self.validate_BankAccountNumberType(self.fiscalRepresentativeBankAccountNumber)
        self.fiscalRepresentativeBankAccountNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FiscalRepresentativeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FiscalRepresentativeType.subclass:
            return FiscalRepresentativeType.subclass(*args_, **kwargs_)
        else:
            return FiscalRepresentativeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fiscalRepresentativeTaxNumber(self):
        return self.fiscalRepresentativeTaxNumber
    def set_fiscalRepresentativeTaxNumber(self, fiscalRepresentativeTaxNumber):
        self.fiscalRepresentativeTaxNumber = fiscalRepresentativeTaxNumber
    def get_fiscalRepresentativeName(self):
        return self.fiscalRepresentativeName
    def set_fiscalRepresentativeName(self, fiscalRepresentativeName):
        self.fiscalRepresentativeName = fiscalRepresentativeName
    def get_fiscalRepresentativeAddress(self):
        return self.fiscalRepresentativeAddress
    def set_fiscalRepresentativeAddress(self, fiscalRepresentativeAddress):
        self.fiscalRepresentativeAddress = fiscalRepresentativeAddress
    def get_fiscalRepresentativeBankAccountNumber(self):
        return self.fiscalRepresentativeBankAccountNumber
    def set_fiscalRepresentativeBankAccountNumber(self, fiscalRepresentativeBankAccountNumber):
        self.fiscalRepresentativeBankAccountNumber = fiscalRepresentativeBankAccountNumber
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_BankAccountNumberType(self, value):
        result = True
        # Validate type BankAccountNumberType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 34:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on BankAccountNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on BankAccountNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on BankAccountNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on BankAccountNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_BankAccountNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_BankAccountNumberType_patterns_, ))
                result = False
        return result
    validate_BankAccountNumberType_patterns_ = [['^([0-9]{8}[-][0-9]{8}[-][0-9]{8}|[0-9]{8}[-][0-9]{8}|[A-Z]{2}[0-9]{2}[0-9A-Za-z]{11,30})$']]
    def _hasContent(self):
        if (
            self.fiscalRepresentativeTaxNumber is not None or
            self.fiscalRepresentativeName is not None or
            self.fiscalRepresentativeAddress is not None or
            self.fiscalRepresentativeBankAccountNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='FiscalRepresentativeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FiscalRepresentativeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FiscalRepresentativeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FiscalRepresentativeType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FiscalRepresentativeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FiscalRepresentativeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='FiscalRepresentativeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fiscalRepresentativeTaxNumber is not None:
            namespaceprefix_ = self.fiscalRepresentativeTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.fiscalRepresentativeTaxNumber_nsprefix_) else ''
            self.fiscalRepresentativeTaxNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fiscalRepresentativeTaxNumber', pretty_print=pretty_print)
        if self.fiscalRepresentativeName is not None:
            namespaceprefix_ = self.fiscalRepresentativeName_nsprefix_ + ':' if (UseCapturedNS_ and self.fiscalRepresentativeName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfiscalRepresentativeName>%s</%sfiscalRepresentativeName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fiscalRepresentativeName), input_name='fiscalRepresentativeName')), namespaceprefix_ , eol_))
        if self.fiscalRepresentativeAddress is not None:
            namespaceprefix_ = self.fiscalRepresentativeAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.fiscalRepresentativeAddress_nsprefix_) else ''
            self.fiscalRepresentativeAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fiscalRepresentativeAddress', pretty_print=pretty_print)
        if self.fiscalRepresentativeBankAccountNumber is not None:
            namespaceprefix_ = self.fiscalRepresentativeBankAccountNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.fiscalRepresentativeBankAccountNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfiscalRepresentativeBankAccountNumber>%s</%sfiscalRepresentativeBankAccountNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fiscalRepresentativeBankAccountNumber), input_name='fiscalRepresentativeBankAccountNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='FiscalRepresentativeType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.fiscalRepresentativeTaxNumber is not None:
            fiscalRepresentativeTaxNumber_ = self.fiscalRepresentativeTaxNumber
            fiscalRepresentativeTaxNumber_.to_etree(element, name_='fiscalRepresentativeTaxNumber', mapping_=mapping_, nsmap_=nsmap_)
        if self.fiscalRepresentativeName is not None:
            fiscalRepresentativeName_ = self.fiscalRepresentativeName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}fiscalRepresentativeName').text = self.gds_format_string(fiscalRepresentativeName_)
        if self.fiscalRepresentativeAddress is not None:
            fiscalRepresentativeAddress_ = self.fiscalRepresentativeAddress
            fiscalRepresentativeAddress_.to_etree(element, name_='fiscalRepresentativeAddress', mapping_=mapping_, nsmap_=nsmap_)
        if self.fiscalRepresentativeBankAccountNumber is not None:
            fiscalRepresentativeBankAccountNumber_ = self.fiscalRepresentativeBankAccountNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}fiscalRepresentativeBankAccountNumber').text = self.gds_format_string(fiscalRepresentativeBankAccountNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='FiscalRepresentativeType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.fiscalRepresentativeTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('fiscalRepresentativeTaxNumber=model_.TaxNumberType(\n')
            self.fiscalRepresentativeTaxNumber.exportLiteral(outfile, level, name_='fiscalRepresentativeTaxNumber')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fiscalRepresentativeName is not None:
            showIndent(outfile, level)
            outfile.write('fiscalRepresentativeName=%s,\n' % self.gds_encode(quote_python(self.fiscalRepresentativeName)))
        if self.fiscalRepresentativeAddress is not None:
            showIndent(outfile, level)
            outfile.write('fiscalRepresentativeAddress=model_.AddressType(\n')
            self.fiscalRepresentativeAddress.exportLiteral(outfile, level, name_='fiscalRepresentativeAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fiscalRepresentativeBankAccountNumber is not None:
            showIndent(outfile, level)
            outfile.write('fiscalRepresentativeBankAccountNumber=%s,\n' % self.gds_encode(quote_python(self.fiscalRepresentativeBankAccountNumber)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fiscalRepresentativeTaxNumber':
            class_obj_ = self.get_class_obj_(child_, TaxNumberType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fiscalRepresentativeTaxNumber = obj_
            obj_.original_tagname_ = 'fiscalRepresentativeTaxNumber'
        elif nodeName_ == 'fiscalRepresentativeName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fiscalRepresentativeName')
            value_ = self.gds_validate_string(value_, node, 'fiscalRepresentativeName')
            self.fiscalRepresentativeName = value_
            self.fiscalRepresentativeName_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.fiscalRepresentativeName)
        elif nodeName_ == 'fiscalRepresentativeAddress':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fiscalRepresentativeAddress = obj_
            obj_.original_tagname_ = 'fiscalRepresentativeAddress'
        elif nodeName_ == 'fiscalRepresentativeBankAccountNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fiscalRepresentativeBankAccountNumber')
            value_ = self.gds_validate_string(value_, node, 'fiscalRepresentativeBankAccountNumber')
            self.fiscalRepresentativeBankAccountNumber = value_
            self.fiscalRepresentativeBankAccountNumber_nsprefix_ = child_.prefix
            # validate type BankAccountNumberType
            self.validate_BankAccountNumberType(self.fiscalRepresentativeBankAccountNumber)
# end class FiscalRepresentativeType


class GeneralLedgerAccountNumbersType(GeneratedsSuper):
    """GeneralLedgerAccountNumbersType -- F
    ő
    k
    ö
    nyvi sz
    á
    mlasz
    á
    mok
    General ledger account numbers
    generalLedgerAccountNumber -- F
    ő
    k
    ö
    nyvi sz
    á
    mlasz
    á
    m
    General ledger account number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, generalLedgerAccountNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if generalLedgerAccountNumber is None:
            self.generalLedgerAccountNumber = []
        else:
            self.generalLedgerAccountNumber = generalLedgerAccountNumber
        self.generalLedgerAccountNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralLedgerAccountNumbersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralLedgerAccountNumbersType.subclass:
            return GeneralLedgerAccountNumbersType.subclass(*args_, **kwargs_)
        else:
            return GeneralLedgerAccountNumbersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_generalLedgerAccountNumber(self):
        return self.generalLedgerAccountNumber
    def set_generalLedgerAccountNumber(self, generalLedgerAccountNumber):
        self.generalLedgerAccountNumber = generalLedgerAccountNumber
    def add_generalLedgerAccountNumber(self, value):
        self.generalLedgerAccountNumber.append(value)
    def insert_generalLedgerAccountNumber_at(self, index, value):
        self.generalLedgerAccountNumber.insert(index, value)
    def replace_generalLedgerAccountNumber_at(self, index, value):
        self.generalLedgerAccountNumber[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.generalLedgerAccountNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='GeneralLedgerAccountNumbersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralLedgerAccountNumbersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeneralLedgerAccountNumbersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralLedgerAccountNumbersType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeneralLedgerAccountNumbersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeneralLedgerAccountNumbersType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='GeneralLedgerAccountNumbersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for generalLedgerAccountNumber_ in self.generalLedgerAccountNumber:
            namespaceprefix_ = self.generalLedgerAccountNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.generalLedgerAccountNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgeneralLedgerAccountNumber>%s</%sgeneralLedgerAccountNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(generalLedgerAccountNumber_), input_name='generalLedgerAccountNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='GeneralLedgerAccountNumbersType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for generalLedgerAccountNumber_ in self.generalLedgerAccountNumber:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}generalLedgerAccountNumber').text = self.gds_format_string(generalLedgerAccountNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='GeneralLedgerAccountNumbersType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('generalLedgerAccountNumber=[\n')
        level += 1
        for generalLedgerAccountNumber_ in self.generalLedgerAccountNumber:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(generalLedgerAccountNumber_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'generalLedgerAccountNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'generalLedgerAccountNumber')
            value_ = self.gds_validate_string(value_, node, 'generalLedgerAccountNumber')
            self.generalLedgerAccountNumber.append(value_)
            self.generalLedgerAccountNumber_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.generalLedgerAccountNumber[-1])
# end class GeneralLedgerAccountNumbersType


class GlnNumbersType(GeneratedsSuper):
    """GlnNumbersType -- Glob
    á
    lis helyazonos
    í
    t
    ó
    sz
    á
    mok
    Global location numbers
    glnNumber -- Glob
    á
    lis helyazonos
    í
    t
    ó
    sz
    á
    m
    Global location number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, glnNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if glnNumber is None:
            self.glnNumber = []
        else:
            self.glnNumber = glnNumber
        self.glnNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlnNumbersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlnNumbersType.subclass:
            return GlnNumbersType.subclass(*args_, **kwargs_)
        else:
            return GlnNumbersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_glnNumber(self):
        return self.glnNumber
    def set_glnNumber(self, glnNumber):
        self.glnNumber = glnNumber
    def add_glnNumber(self, value):
        self.glnNumber.append(value)
    def insert_glnNumber_at(self, index, value):
        self.glnNumber.insert(index, value)
    def replace_glnNumber_at(self, index, value):
        self.glnNumber[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.glnNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='GlnNumbersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GlnNumbersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GlnNumbersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GlnNumbersType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GlnNumbersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GlnNumbersType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='GlnNumbersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for glnNumber_ in self.glnNumber:
            namespaceprefix_ = self.glnNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.glnNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sglnNumber>%s</%sglnNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(glnNumber_), input_name='glnNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='GlnNumbersType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for glnNumber_ in self.glnNumber:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}glnNumber').text = self.gds_format_string(glnNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='GlnNumbersType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('glnNumber=[\n')
        level += 1
        for glnNumber_ in self.glnNumber:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(glnNumber_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'glnNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'glnNumber')
            value_ = self.gds_validate_string(value_, node, 'glnNumber')
            self.glnNumber.append(value_)
            self.glnNumber_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.glnNumber[-1])
# end class GlnNumbersType


class InvoiceDetailType(GeneratedsSuper):
    """InvoiceDetailType -- Sz
    á
    mla r
    é
    szletez
    ő
    adatok
    Invoice detail data
    invoiceCategory -- A sz
    á
    mla t
    í
    pusa, m
    ó
    dos
    í
    t
    ó
    okirat eset
    é
    n az eredeti sz
    á
    mla t
    í
    pusa
    Type of invoice. In case of modification document the type of original invoice
    invoiceDeliveryDate -- Teljes
    í
    t
    é
    s d
    á
    tuma (ha nem szerepel a sz
    á
    ml
    á
    n, akkor azonos a sz
    á
    mla kelt
    é
    vel) -
    Á
    FA tv. 169.
    §
    g)
    Delivery date (if this field does not exist on the invoice, the date of the invoice should be considered as such) - section 169 (g) of the VAT law
    invoiceDeliveryPeriodStart -- Amennyiben a sz
    á
    mla egy id
    ő
    szakra vonatkozik, akkor az id
    ő
    szak els
    ő
    napja
    The first day of the delivery, if the invoice delivery is a period
    invoiceDeliveryPeriodEnd -- Amennyiben a sz
    á
    mla egy id
    ő
    szakra vonatkozik, akkor az id
    ő
    szak utols
    ó
    napja
    The last day of the delivery, if the invoice delivery is a period
    invoiceAccountingDeliveryDate -- Sz
    á
    mviteli teljes
    í
    t
    é
    s d
    á
    tuma. Id
    ő
    szak eset
    é
    n az id
    ő
    szak utols
    ó
    napja
    Date of accounting accomplishment. In the event of a period, the last day of the period
    periodicalSettlement -- Annak jelz
    é
    se, ha a felek a term
    é
    k
    é
    rt
    é
    kes
    í
    t
    é
    s, szolg
    á
    ltat
    á
    s ny
    ú
    jt
    á
    s sor
    á
    n id
    ő
    szakonk
    é
    nti elsz
    á
    mol
    á
    sban vagy fizet
    é
    sben
    á
    llapodnak meg, vagy a term
    é
    k
    é
    rt
    é
    kes
    í
    t
    é
    s, szolg
    á
    ltat
    á
    s ny
    ú
    jt
    á
    s ellen
    é
    rt
    é
    k
    é
    t meghat
    á
    rozott id
    ő
    pontra
    á
    llap
    í
    tj
    á
    k meg.
    Indicates where by agreement of the parties it gives rise to successive statements of account or successive payments relating to the supply of goods, or the supply of services, or if the consideration agreed upon for such goods and/or services applies to specific periods.
    smallBusinessIndicator -- Kisad
    ó
    z
    ó
    jelz
    é
    se
    Marking of low tax-bracket enterprise
    currencyCode -- A sz
    á
    mla p
    é
    nzneme az ISO 4217 szabv
    á
    ny szerint
    ISO 4217 currency code on the invoice
    exchangeRate -- HUF-t
    ó
    l k
    ü
    l
    ö
    nb
    ö
    z
    ő
    p
    é
    nznem eset
    é
    n az alkalmazott
    á
    rfolyam: egy egys
    é
    g
    é
    rt
    é
    ke HUF-ban
    In case any currency is used other than HUF, the applied exchange rate should be mentioned: 1 unit of the foreign currency expressed in HUF
    utilitySettlementIndicator -- K
    ö
    zm
    ű
    elsz
    á
    mol
    ó
    sz
    á
    mla jel
    ö
    l
    é
    se (2013.
    é
    vi CLXXXVIII t
    ö
    rv
    é
    ny szerinti elsz
    á
    mol
    ó
    sz
    á
    mla)
    Marking the fact of utility settlement invoice (invoice according to Act CLXXXVIII of 2013)
    selfBillingIndicator -- Ö
    nsz
    á
    ml
    á
    z
    á
    s jel
    ö
    l
    é
    se (
    ö
    nsz
    á
    ml
    á
    z
    á
    s eset
    é
    n true)
    Marking the fact of self-billing (in the case of self-billing the value is true)
    paymentMethod -- Fizet
    é
    s m
    ó
    dja
    Method of payment
    paymentDate -- Fizet
    é
    si hat
    á
    rid
    ő
    Deadline for payment
    cashAccountingIndicator -- P
    é
    nzforgalmi elsz
    á
    mol
    á
    s jel
    ö
    l
    é
    se, ha az szerepel a sz
    á
    ml
    á
    n -
    Á
    FA tv. 169.
    §
    h).
    É
    rt
    é
    ke true p
    é
    nzforgalmi elsz
    á
    mol
    á
    s eset
    é
    n
    Marking the fact of cash accounting if this is indicated on the invoice - section 169 (h) of the VAT law. The value is true in case of cash accounting
    invoiceAppearance -- A sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat megjelen
    é
    si form
    á
    ja
    Form of appearance of the invoice or modification document
    conventionalInvoiceInfo -- A sz
    á
    mlafeldolgoz
    á
    st seg
    í
    t
    ő
    , egyezm
    é
    nyesen neves
    í
    tett egy
    é
    b adatok
    Other conventionally named data to assist in invoice processing
    additionalInvoiceData -- A sz
    á
    ml
    á
    ra vonatkoz
    ó
    egy
    é
    b adat
    Other data in relation to the invoice

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceCategory=None, invoiceDeliveryDate=None, invoiceDeliveryPeriodStart=None, invoiceDeliveryPeriodEnd=None, invoiceAccountingDeliveryDate=None, periodicalSettlement=None, smallBusinessIndicator=None, currencyCode=None, exchangeRate=None, utilitySettlementIndicator=None, selfBillingIndicator=None, paymentMethod=None, paymentDate=None, cashAccountingIndicator=None, invoiceAppearance=None, conventionalInvoiceInfo=None, additionalInvoiceData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceCategory = invoiceCategory
        self.validate_InvoiceCategoryType(self.invoiceCategory)
        self.invoiceCategory_nsprefix_ = "base"
        if isinstance(invoiceDeliveryDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(invoiceDeliveryDate, '%Y-%m-%d').date()
        else:
            initvalue_ = invoiceDeliveryDate
        self.invoiceDeliveryDate = initvalue_
        self.invoiceDeliveryDate_nsprefix_ = "base"
        if isinstance(invoiceDeliveryPeriodStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(invoiceDeliveryPeriodStart, '%Y-%m-%d').date()
        else:
            initvalue_ = invoiceDeliveryPeriodStart
        self.invoiceDeliveryPeriodStart = initvalue_
        self.invoiceDeliveryPeriodStart_nsprefix_ = "base"
        if isinstance(invoiceDeliveryPeriodEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(invoiceDeliveryPeriodEnd, '%Y-%m-%d').date()
        else:
            initvalue_ = invoiceDeliveryPeriodEnd
        self.invoiceDeliveryPeriodEnd = initvalue_
        self.invoiceDeliveryPeriodEnd_nsprefix_ = "base"
        if isinstance(invoiceAccountingDeliveryDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(invoiceAccountingDeliveryDate, '%Y-%m-%d').date()
        else:
            initvalue_ = invoiceAccountingDeliveryDate
        self.invoiceAccountingDeliveryDate = initvalue_
        self.invoiceAccountingDeliveryDate_nsprefix_ = "base"
        self.periodicalSettlement = periodicalSettlement
        self.periodicalSettlement_nsprefix_ = "xs"
        self.smallBusinessIndicator = smallBusinessIndicator
        self.smallBusinessIndicator_nsprefix_ = "xs"
        self.currencyCode = currencyCode
        self.validate_CurrencyType(self.currencyCode)
        self.currencyCode_nsprefix_ = "common"
        self.exchangeRate = exchangeRate
        self.validate_ExchangeRateType(self.exchangeRate)
        self.exchangeRate_nsprefix_ = None
        self.utilitySettlementIndicator = utilitySettlementIndicator
        self.utilitySettlementIndicator_nsprefix_ = "xs"
        self.selfBillingIndicator = selfBillingIndicator
        self.selfBillingIndicator_nsprefix_ = "xs"
        self.paymentMethod = paymentMethod
        self.validate_PaymentMethodType(self.paymentMethod)
        self.paymentMethod_nsprefix_ = "base"
        if isinstance(paymentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(paymentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = paymentDate
        self.paymentDate = initvalue_
        self.paymentDate_nsprefix_ = "base"
        self.cashAccountingIndicator = cashAccountingIndicator
        self.cashAccountingIndicator_nsprefix_ = "xs"
        self.invoiceAppearance = invoiceAppearance
        self.validate_InvoiceAppearanceType(self.invoiceAppearance)
        self.invoiceAppearance_nsprefix_ = "base"
        self.conventionalInvoiceInfo = conventionalInvoiceInfo
        self.conventionalInvoiceInfo_nsprefix_ = None
        if additionalInvoiceData is None:
            self.additionalInvoiceData = []
        else:
            self.additionalInvoiceData = additionalInvoiceData
        self.additionalInvoiceData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceDetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceDetailType.subclass:
            return InvoiceDetailType.subclass(*args_, **kwargs_)
        else:
            return InvoiceDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceCategory(self):
        return self.invoiceCategory
    def set_invoiceCategory(self, invoiceCategory):
        self.invoiceCategory = invoiceCategory
    def get_invoiceDeliveryDate(self):
        return self.invoiceDeliveryDate
    def set_invoiceDeliveryDate(self, invoiceDeliveryDate):
        self.invoiceDeliveryDate = invoiceDeliveryDate
    def get_invoiceDeliveryPeriodStart(self):
        return self.invoiceDeliveryPeriodStart
    def set_invoiceDeliveryPeriodStart(self, invoiceDeliveryPeriodStart):
        self.invoiceDeliveryPeriodStart = invoiceDeliveryPeriodStart
    def get_invoiceDeliveryPeriodEnd(self):
        return self.invoiceDeliveryPeriodEnd
    def set_invoiceDeliveryPeriodEnd(self, invoiceDeliveryPeriodEnd):
        self.invoiceDeliveryPeriodEnd = invoiceDeliveryPeriodEnd
    def get_invoiceAccountingDeliveryDate(self):
        return self.invoiceAccountingDeliveryDate
    def set_invoiceAccountingDeliveryDate(self, invoiceAccountingDeliveryDate):
        self.invoiceAccountingDeliveryDate = invoiceAccountingDeliveryDate
    def get_periodicalSettlement(self):
        return self.periodicalSettlement
    def set_periodicalSettlement(self, periodicalSettlement):
        self.periodicalSettlement = periodicalSettlement
    def get_smallBusinessIndicator(self):
        return self.smallBusinessIndicator
    def set_smallBusinessIndicator(self, smallBusinessIndicator):
        self.smallBusinessIndicator = smallBusinessIndicator
    def get_currencyCode(self):
        return self.currencyCode
    def set_currencyCode(self, currencyCode):
        self.currencyCode = currencyCode
    def get_exchangeRate(self):
        return self.exchangeRate
    def set_exchangeRate(self, exchangeRate):
        self.exchangeRate = exchangeRate
    def get_utilitySettlementIndicator(self):
        return self.utilitySettlementIndicator
    def set_utilitySettlementIndicator(self, utilitySettlementIndicator):
        self.utilitySettlementIndicator = utilitySettlementIndicator
    def get_selfBillingIndicator(self):
        return self.selfBillingIndicator
    def set_selfBillingIndicator(self, selfBillingIndicator):
        self.selfBillingIndicator = selfBillingIndicator
    def get_paymentMethod(self):
        return self.paymentMethod
    def set_paymentMethod(self, paymentMethod):
        self.paymentMethod = paymentMethod
    def get_paymentDate(self):
        return self.paymentDate
    def set_paymentDate(self, paymentDate):
        self.paymentDate = paymentDate
    def get_cashAccountingIndicator(self):
        return self.cashAccountingIndicator
    def set_cashAccountingIndicator(self, cashAccountingIndicator):
        self.cashAccountingIndicator = cashAccountingIndicator
    def get_invoiceAppearance(self):
        return self.invoiceAppearance
    def set_invoiceAppearance(self, invoiceAppearance):
        self.invoiceAppearance = invoiceAppearance
    def get_conventionalInvoiceInfo(self):
        return self.conventionalInvoiceInfo
    def set_conventionalInvoiceInfo(self, conventionalInvoiceInfo):
        self.conventionalInvoiceInfo = conventionalInvoiceInfo
    def get_additionalInvoiceData(self):
        return self.additionalInvoiceData
    def set_additionalInvoiceData(self, additionalInvoiceData):
        self.additionalInvoiceData = additionalInvoiceData
    def add_additionalInvoiceData(self, value):
        self.additionalInvoiceData.append(value)
    def insert_additionalInvoiceData_at(self, index, value):
        self.additionalInvoiceData.insert(index, value)
    def replace_additionalInvoiceData_at(self, index, value):
        self.additionalInvoiceData[index] = value
    def validate_InvoiceCategoryType(self, value):
        result = True
        # Validate type InvoiceCategoryType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['NORMAL', 'SIMPLIFIED', 'AGGREGATE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvoiceCategoryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on InvoiceCategoryType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on InvoiceCategoryType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceDateType(self, value):
        result = True
        # Validate type InvoiceDateType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.strptime('2010-01-01', '%Y-%m-%d').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceDateType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceDateType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceDateType_patterns_, ))
                result = False
        return result
    validate_InvoiceDateType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2})$']]
    def validate_CurrencyType(self, value):
        result = True
        # Validate type CurrencyType, a restriction on AtomicStringType4.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on CurrencyType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CurrencyType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CurrencyType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CurrencyType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CurrencyType_patterns_, ))
                result = False
        return result
    validate_CurrencyType_patterns_ = [['^([A-Z]{3})$']]
    def validate_ExchangeRateType(self, value):
        result = True
        # Validate type ExchangeRateType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value <= 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minExclusive restriction on ExchangeRateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on ExchangeRateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_PaymentMethodType(self, value):
        result = True
        # Validate type PaymentMethodType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['TRANSFER', 'CASH', 'CARD', 'VOUCHER', 'OTHER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PaymentMethodType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PaymentMethodType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PaymentMethodType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InvoiceAppearanceType(self, value):
        result = True
        # Validate type InvoiceAppearanceType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['PAPER', 'ELECTRONIC', 'EDI', 'UNKNOWN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on InvoiceAppearanceType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on InvoiceAppearanceType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on InvoiceAppearanceType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.invoiceCategory is not None or
            self.invoiceDeliveryDate is not None or
            self.invoiceDeliveryPeriodStart is not None or
            self.invoiceDeliveryPeriodEnd is not None or
            self.invoiceAccountingDeliveryDate is not None or
            self.periodicalSettlement is not None or
            self.smallBusinessIndicator is not None or
            self.currencyCode is not None or
            self.exchangeRate is not None or
            self.utilitySettlementIndicator is not None or
            self.selfBillingIndicator is not None or
            self.paymentMethod is not None or
            self.paymentDate is not None or
            self.cashAccountingIndicator is not None or
            self.invoiceAppearance is not None or
            self.conventionalInvoiceInfo is not None or
            self.additionalInvoiceData
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceDetailType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceDetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceDetailType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceDetailType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceDetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceDetailType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceDetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceCategory is not None:
            namespaceprefix_ = self.invoiceCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceCategory>%s</%sinvoiceCategory>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceCategory), input_name='invoiceCategory')), namespaceprefix_ , eol_))
        if self.invoiceDeliveryDate is not None:
            namespaceprefix_ = self.invoiceDeliveryDate_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDeliveryDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceDeliveryDate>%s</%sinvoiceDeliveryDate>%s' % (namespaceprefix_ , self.gds_format_date(self.invoiceDeliveryDate, input_name='invoiceDeliveryDate'), namespaceprefix_ , eol_))
        if self.invoiceDeliveryPeriodStart is not None:
            namespaceprefix_ = self.invoiceDeliveryPeriodStart_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDeliveryPeriodStart_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceDeliveryPeriodStart>%s</%sinvoiceDeliveryPeriodStart>%s' % (namespaceprefix_ , self.gds_format_date(self.invoiceDeliveryPeriodStart, input_name='invoiceDeliveryPeriodStart'), namespaceprefix_ , eol_))
        if self.invoiceDeliveryPeriodEnd is not None:
            namespaceprefix_ = self.invoiceDeliveryPeriodEnd_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDeliveryPeriodEnd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceDeliveryPeriodEnd>%s</%sinvoiceDeliveryPeriodEnd>%s' % (namespaceprefix_ , self.gds_format_date(self.invoiceDeliveryPeriodEnd, input_name='invoiceDeliveryPeriodEnd'), namespaceprefix_ , eol_))
        if self.invoiceAccountingDeliveryDate is not None:
            namespaceprefix_ = self.invoiceAccountingDeliveryDate_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceAccountingDeliveryDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceAccountingDeliveryDate>%s</%sinvoiceAccountingDeliveryDate>%s' % (namespaceprefix_ , self.gds_format_date(self.invoiceAccountingDeliveryDate, input_name='invoiceAccountingDeliveryDate'), namespaceprefix_ , eol_))
        if self.periodicalSettlement is not None:
            namespaceprefix_ = self.periodicalSettlement_nsprefix_ + ':' if (UseCapturedNS_ and self.periodicalSettlement_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriodicalSettlement>%s</%speriodicalSettlement>%s' % (namespaceprefix_ , self.gds_format_boolean(self.periodicalSettlement, input_name='periodicalSettlement'), namespaceprefix_ , eol_))
        if self.smallBusinessIndicator is not None:
            namespaceprefix_ = self.smallBusinessIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.smallBusinessIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssmallBusinessIndicator>%s</%ssmallBusinessIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.smallBusinessIndicator, input_name='smallBusinessIndicator'), namespaceprefix_ , eol_))
        if self.currencyCode is not None:
            namespaceprefix_ = self.currencyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.currencyCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrencyCode>%s</%scurrencyCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.currencyCode), input_name='currencyCode')), namespaceprefix_ , eol_))
        if self.exchangeRate is not None:
            namespaceprefix_ = self.exchangeRate_nsprefix_ + ':' if (UseCapturedNS_ and self.exchangeRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexchangeRate>%s</%sexchangeRate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.exchangeRate, input_name='exchangeRate'), namespaceprefix_ , eol_))
        if self.utilitySettlementIndicator is not None:
            namespaceprefix_ = self.utilitySettlementIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.utilitySettlementIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sutilitySettlementIndicator>%s</%sutilitySettlementIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.utilitySettlementIndicator, input_name='utilitySettlementIndicator'), namespaceprefix_ , eol_))
        if self.selfBillingIndicator is not None:
            namespaceprefix_ = self.selfBillingIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.selfBillingIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sselfBillingIndicator>%s</%sselfBillingIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.selfBillingIndicator, input_name='selfBillingIndicator'), namespaceprefix_ , eol_))
        if self.paymentMethod is not None:
            namespaceprefix_ = self.paymentMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.paymentMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaymentMethod>%s</%spaymentMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.paymentMethod), input_name='paymentMethod')), namespaceprefix_ , eol_))
        if self.paymentDate is not None:
            namespaceprefix_ = self.paymentDate_nsprefix_ + ':' if (UseCapturedNS_ and self.paymentDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaymentDate>%s</%spaymentDate>%s' % (namespaceprefix_ , self.gds_format_date(self.paymentDate, input_name='paymentDate'), namespaceprefix_ , eol_))
        if self.cashAccountingIndicator is not None:
            namespaceprefix_ = self.cashAccountingIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.cashAccountingIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scashAccountingIndicator>%s</%scashAccountingIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.cashAccountingIndicator, input_name='cashAccountingIndicator'), namespaceprefix_ , eol_))
        if self.invoiceAppearance is not None:
            namespaceprefix_ = self.invoiceAppearance_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceAppearance_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceAppearance>%s</%sinvoiceAppearance>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceAppearance), input_name='invoiceAppearance')), namespaceprefix_ , eol_))
        if self.conventionalInvoiceInfo is not None:
            namespaceprefix_ = self.conventionalInvoiceInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.conventionalInvoiceInfo_nsprefix_) else ''
            self.conventionalInvoiceInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='conventionalInvoiceInfo', pretty_print=pretty_print)
        for additionalInvoiceData_ in self.additionalInvoiceData:
            namespaceprefix_ = self.additionalInvoiceData_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalInvoiceData_nsprefix_) else ''
            additionalInvoiceData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalInvoiceData', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceDetailType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.invoiceCategory is not None:
            invoiceCategory_ = self.invoiceCategory
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceCategory').text = self.gds_format_string(invoiceCategory_)
        if self.invoiceDeliveryDate is not None:
            invoiceDeliveryDate_ = self.invoiceDeliveryDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceDeliveryDate').text = self.gds_format_date(invoiceDeliveryDate_)
        if self.invoiceDeliveryPeriodStart is not None:
            invoiceDeliveryPeriodStart_ = self.invoiceDeliveryPeriodStart
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceDeliveryPeriodStart').text = self.gds_format_date(invoiceDeliveryPeriodStart_)
        if self.invoiceDeliveryPeriodEnd is not None:
            invoiceDeliveryPeriodEnd_ = self.invoiceDeliveryPeriodEnd
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceDeliveryPeriodEnd').text = self.gds_format_date(invoiceDeliveryPeriodEnd_)
        if self.invoiceAccountingDeliveryDate is not None:
            invoiceAccountingDeliveryDate_ = self.invoiceAccountingDeliveryDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceAccountingDeliveryDate').text = self.gds_format_date(invoiceAccountingDeliveryDate_)
        if self.periodicalSettlement is not None:
            periodicalSettlement_ = self.periodicalSettlement
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}periodicalSettlement').text = self.gds_format_boolean(periodicalSettlement_)
        if self.smallBusinessIndicator is not None:
            smallBusinessIndicator_ = self.smallBusinessIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}smallBusinessIndicator').text = self.gds_format_boolean(smallBusinessIndicator_)
        if self.currencyCode is not None:
            currencyCode_ = self.currencyCode
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}currencyCode').text = self.gds_format_string(currencyCode_)
        if self.exchangeRate is not None:
            exchangeRate_ = self.exchangeRate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}exchangeRate').text = self.gds_format_decimal(exchangeRate_)
        if self.utilitySettlementIndicator is not None:
            utilitySettlementIndicator_ = self.utilitySettlementIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}utilitySettlementIndicator').text = self.gds_format_boolean(utilitySettlementIndicator_)
        if self.selfBillingIndicator is not None:
            selfBillingIndicator_ = self.selfBillingIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}selfBillingIndicator').text = self.gds_format_boolean(selfBillingIndicator_)
        if self.paymentMethod is not None:
            paymentMethod_ = self.paymentMethod
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}paymentMethod').text = self.gds_format_string(paymentMethod_)
        if self.paymentDate is not None:
            paymentDate_ = self.paymentDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}paymentDate').text = self.gds_format_date(paymentDate_)
        if self.cashAccountingIndicator is not None:
            cashAccountingIndicator_ = self.cashAccountingIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}cashAccountingIndicator').text = self.gds_format_boolean(cashAccountingIndicator_)
        if self.invoiceAppearance is not None:
            invoiceAppearance_ = self.invoiceAppearance
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceAppearance').text = self.gds_format_string(invoiceAppearance_)
        if self.conventionalInvoiceInfo is not None:
            conventionalInvoiceInfo_ = self.conventionalInvoiceInfo
            conventionalInvoiceInfo_.to_etree(element, name_='conventionalInvoiceInfo', mapping_=mapping_, nsmap_=nsmap_)
        for additionalInvoiceData_ in self.additionalInvoiceData:
            additionalInvoiceData_.to_etree(element, name_='additionalInvoiceData', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceDetailType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceCategory is not None:
            showIndent(outfile, level)
            outfile.write('invoiceCategory=%s,\n' % self.gds_encode(quote_python(self.invoiceCategory)))
        if self.invoiceDeliveryDate is not None:
            showIndent(outfile, level)
            outfile.write('invoiceDeliveryDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.invoiceDeliveryDate, input_name='invoiceDeliveryDate'))
        if self.invoiceDeliveryPeriodStart is not None:
            showIndent(outfile, level)
            outfile.write('invoiceDeliveryPeriodStart=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.invoiceDeliveryPeriodStart, input_name='invoiceDeliveryPeriodStart'))
        if self.invoiceDeliveryPeriodEnd is not None:
            showIndent(outfile, level)
            outfile.write('invoiceDeliveryPeriodEnd=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.invoiceDeliveryPeriodEnd, input_name='invoiceDeliveryPeriodEnd'))
        if self.invoiceAccountingDeliveryDate is not None:
            showIndent(outfile, level)
            outfile.write('invoiceAccountingDeliveryDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.invoiceAccountingDeliveryDate, input_name='invoiceAccountingDeliveryDate'))
        if self.periodicalSettlement is not None:
            showIndent(outfile, level)
            outfile.write('periodicalSettlement=%s,\n' % self.periodicalSettlement)
        if self.smallBusinessIndicator is not None:
            showIndent(outfile, level)
            outfile.write('smallBusinessIndicator=%s,\n' % self.smallBusinessIndicator)
        if self.currencyCode is not None:
            showIndent(outfile, level)
            outfile.write('currencyCode=%s,\n' % self.gds_encode(quote_python(self.currencyCode)))
        if self.exchangeRate is not None:
            showIndent(outfile, level)
            outfile.write('exchangeRate=%f,\n' % self.exchangeRate)
        if self.utilitySettlementIndicator is not None:
            showIndent(outfile, level)
            outfile.write('utilitySettlementIndicator=%s,\n' % self.utilitySettlementIndicator)
        if self.selfBillingIndicator is not None:
            showIndent(outfile, level)
            outfile.write('selfBillingIndicator=%s,\n' % self.selfBillingIndicator)
        if self.paymentMethod is not None:
            showIndent(outfile, level)
            outfile.write('paymentMethod=%s,\n' % self.gds_encode(quote_python(self.paymentMethod)))
        if self.paymentDate is not None:
            showIndent(outfile, level)
            outfile.write('paymentDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.paymentDate, input_name='paymentDate'))
        if self.cashAccountingIndicator is not None:
            showIndent(outfile, level)
            outfile.write('cashAccountingIndicator=%s,\n' % self.cashAccountingIndicator)
        if self.invoiceAppearance is not None:
            showIndent(outfile, level)
            outfile.write('invoiceAppearance=%s,\n' % self.gds_encode(quote_python(self.invoiceAppearance)))
        if self.conventionalInvoiceInfo is not None:
            showIndent(outfile, level)
            outfile.write('conventionalInvoiceInfo=model_.ConventionalInvoiceInfoType(\n')
            self.conventionalInvoiceInfo.exportLiteral(outfile, level, name_='conventionalInvoiceInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('additionalInvoiceData=[\n')
        level += 1
        for additionalInvoiceData_ in self.additionalInvoiceData:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalDataType(\n')
            additionalInvoiceData_.exportLiteral(outfile, level, name_='AdditionalDataType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceCategory':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceCategory')
            value_ = self.gds_validate_string(value_, node, 'invoiceCategory')
            self.invoiceCategory = value_
            self.invoiceCategory_nsprefix_ = child_.prefix
            # validate type InvoiceCategoryType
            self.validate_InvoiceCategoryType(self.invoiceCategory)
        elif nodeName_ == 'invoiceDeliveryDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.invoiceDeliveryDate = dval_
            self.invoiceDeliveryDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.invoiceDeliveryDate)
        elif nodeName_ == 'invoiceDeliveryPeriodStart':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.invoiceDeliveryPeriodStart = dval_
            self.invoiceDeliveryPeriodStart_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.invoiceDeliveryPeriodStart)
        elif nodeName_ == 'invoiceDeliveryPeriodEnd':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.invoiceDeliveryPeriodEnd = dval_
            self.invoiceDeliveryPeriodEnd_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.invoiceDeliveryPeriodEnd)
        elif nodeName_ == 'invoiceAccountingDeliveryDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.invoiceAccountingDeliveryDate = dval_
            self.invoiceAccountingDeliveryDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.invoiceAccountingDeliveryDate)
        elif nodeName_ == 'periodicalSettlement':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'periodicalSettlement')
            ival_ = self.gds_validate_boolean(ival_, node, 'periodicalSettlement')
            self.periodicalSettlement = ival_
            self.periodicalSettlement_nsprefix_ = child_.prefix
        elif nodeName_ == 'smallBusinessIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'smallBusinessIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'smallBusinessIndicator')
            self.smallBusinessIndicator = ival_
            self.smallBusinessIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'currencyCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'currencyCode')
            value_ = self.gds_validate_string(value_, node, 'currencyCode')
            self.currencyCode = value_
            self.currencyCode_nsprefix_ = child_.prefix
            # validate type CurrencyType
            self.validate_CurrencyType(self.currencyCode)
        elif nodeName_ == 'exchangeRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'exchangeRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'exchangeRate')
            self.exchangeRate = fval_
            self.exchangeRate_nsprefix_ = child_.prefix
            # validate type ExchangeRateType
            self.validate_ExchangeRateType(self.exchangeRate)
        elif nodeName_ == 'utilitySettlementIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'utilitySettlementIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'utilitySettlementIndicator')
            self.utilitySettlementIndicator = ival_
            self.utilitySettlementIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'selfBillingIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'selfBillingIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'selfBillingIndicator')
            self.selfBillingIndicator = ival_
            self.selfBillingIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'paymentMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'paymentMethod')
            value_ = self.gds_validate_string(value_, node, 'paymentMethod')
            self.paymentMethod = value_
            self.paymentMethod_nsprefix_ = child_.prefix
            # validate type PaymentMethodType
            self.validate_PaymentMethodType(self.paymentMethod)
        elif nodeName_ == 'paymentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.paymentDate = dval_
            self.paymentDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.paymentDate)
        elif nodeName_ == 'cashAccountingIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'cashAccountingIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'cashAccountingIndicator')
            self.cashAccountingIndicator = ival_
            self.cashAccountingIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'invoiceAppearance':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceAppearance')
            value_ = self.gds_validate_string(value_, node, 'invoiceAppearance')
            self.invoiceAppearance = value_
            self.invoiceAppearance_nsprefix_ = child_.prefix
            # validate type InvoiceAppearanceType
            self.validate_InvoiceAppearanceType(self.invoiceAppearance)
        elif nodeName_ == 'conventionalInvoiceInfo':
            obj_ = ConventionalInvoiceInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.conventionalInvoiceInfo = obj_
            obj_.original_tagname_ = 'conventionalInvoiceInfo'
        elif nodeName_ == 'additionalInvoiceData':
            obj_ = AdditionalDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalInvoiceData.append(obj_)
            obj_.original_tagname_ = 'additionalInvoiceData'
# end class InvoiceDetailType


class InvoiceDataType(GeneratedsSuper):
    """InvoiceDataType -- A sz
    á
    mla adatszolg
    á
    ltat
    á
    s adatai
    Invoice exchange data
    invoiceNumber -- Sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat sorsz
    á
    ma -
    Á
    FA tv. 169.
    §
    b) vagy 170.
    §
    (1) bek. b) pont
    Sequential number of the original invoice or modification document - section 169 (b) or section 170 (1) b) of the VAT law
    invoiceIssueDate -- Sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat kelte -
    Á
    FA tv. 169.
    §
    a),
    Á
    FA tv. 170.
    §
    (1) bek. a)
    Date of issue of the invoice or the modification document - section 169 (a) of the VAT law, section 170 (1) a) of the VAT law
    completenessIndicator -- Jel
    ö
    li, ha az adatszolg
    á
    ltat
    á
    s maga a sz
    á
    mla (a sz
    á
    ml
    á
    n nem szerepel t
    ö
    bb adat)
    Indicates whether the data exchange is identical with the invoice (the invoice does not contain any more data)
    invoiceMain -- Sz
    á
    mlaadatok le
    í
    r
    á
    s
    á
    ra szolg
    á
    l
    ó
    k
    ö
    z
    ö
    s t
    í
    pus
    A common type to describe invoice information

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceNumber=None, invoiceIssueDate=None, completenessIndicator=None, invoiceMain=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceNumber = invoiceNumber
        self.validate_SimpleText50NotBlankType(self.invoiceNumber)
        self.invoiceNumber_nsprefix_ = "common"
        if isinstance(invoiceIssueDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(invoiceIssueDate, '%Y-%m-%d').date()
        else:
            initvalue_ = invoiceIssueDate
        self.invoiceIssueDate = initvalue_
        self.invoiceIssueDate_nsprefix_ = "base"
        self.completenessIndicator = completenessIndicator
        self.completenessIndicator_nsprefix_ = "xs"
        self.invoiceMain = invoiceMain
        self.invoiceMain_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceDataType.subclass:
            return InvoiceDataType.subclass(*args_, **kwargs_)
        else:
            return InvoiceDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceNumber(self):
        return self.invoiceNumber
    def set_invoiceNumber(self, invoiceNumber):
        self.invoiceNumber = invoiceNumber
    def get_invoiceIssueDate(self):
        return self.invoiceIssueDate
    def set_invoiceIssueDate(self, invoiceIssueDate):
        self.invoiceIssueDate = invoiceIssueDate
    def get_completenessIndicator(self):
        return self.completenessIndicator
    def set_completenessIndicator(self, completenessIndicator):
        self.completenessIndicator = completenessIndicator
    def get_invoiceMain(self):
        return self.invoiceMain
    def set_invoiceMain(self, invoiceMain):
        self.invoiceMain = invoiceMain
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceDateType(self, value):
        result = True
        # Validate type InvoiceDateType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.strptime('2010-01-01', '%Y-%m-%d').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceDateType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceDateType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceDateType_patterns_, ))
                result = False
        return result
    validate_InvoiceDateType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2})$']]
    def _hasContent(self):
        if (
            self.invoiceNumber is not None or
            self.invoiceIssueDate is not None or
            self.completenessIndicator is not None or
            self.invoiceMain is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceDataType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceNumber is not None:
            namespaceprefix_ = self.invoiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceNumber>%s</%sinvoiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.invoiceNumber), input_name='invoiceNumber')), namespaceprefix_ , eol_))
        if self.invoiceIssueDate is not None:
            namespaceprefix_ = self.invoiceIssueDate_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceIssueDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceIssueDate>%s</%sinvoiceIssueDate>%s' % (namespaceprefix_ , self.gds_format_date(self.invoiceIssueDate, input_name='invoiceIssueDate'), namespaceprefix_ , eol_))
        if self.completenessIndicator is not None:
            namespaceprefix_ = self.completenessIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.completenessIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompletenessIndicator>%s</%scompletenessIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.completenessIndicator, input_name='completenessIndicator'), namespaceprefix_ , eol_))
        if self.invoiceMain is not None:
            namespaceprefix_ = self.invoiceMain_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceMain_nsprefix_) else ''
            self.invoiceMain.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceMain', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.invoiceNumber is not None:
            invoiceNumber_ = self.invoiceNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceNumber').text = self.gds_format_string(invoiceNumber_)
        if self.invoiceIssueDate is not None:
            invoiceIssueDate_ = self.invoiceIssueDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceIssueDate').text = self.gds_format_date(invoiceIssueDate_)
        if self.completenessIndicator is not None:
            completenessIndicator_ = self.completenessIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}completenessIndicator').text = self.gds_format_boolean(completenessIndicator_)
        if self.invoiceMain is not None:
            invoiceMain_ = self.invoiceMain
            invoiceMain_.to_etree(element, name_='invoiceMain', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('invoiceNumber=%s,\n' % self.gds_encode(quote_python(self.invoiceNumber)))
        if self.invoiceIssueDate is not None:
            showIndent(outfile, level)
            outfile.write('invoiceIssueDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.invoiceIssueDate, input_name='invoiceIssueDate'))
        if self.completenessIndicator is not None:
            showIndent(outfile, level)
            outfile.write('completenessIndicator=%s,\n' % self.completenessIndicator)
        if self.invoiceMain is not None:
            showIndent(outfile, level)
            outfile.write('invoiceMain=model_.InvoiceMainType(\n')
            self.invoiceMain.exportLiteral(outfile, level, name_='invoiceMain')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'invoiceNumber')
            value_ = self.gds_validate_string(value_, node, 'invoiceNumber')
            self.invoiceNumber = value_
            self.invoiceNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.invoiceNumber)
        elif nodeName_ == 'invoiceIssueDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.invoiceIssueDate = dval_
            self.invoiceIssueDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.invoiceIssueDate)
        elif nodeName_ == 'completenessIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'completenessIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'completenessIndicator')
            self.completenessIndicator = ival_
            self.completenessIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'invoiceMain':
            obj_ = InvoiceMainType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceMain = obj_
            obj_.original_tagname_ = 'invoiceMain'
# end class InvoiceDataType


class InvoiceHeadType(GeneratedsSuper):
    """InvoiceHeadType -- Sz
    á
    mla fejl
    é
    c adatai
    Data in header of invoice
    supplierInfo -- Sz
    á
    mla kibocs
    á
    t
    ó
    (elad
    ó
    ) adatai
    Data related to the issuer of the invoice (supplier)
    customerInfo -- Vev
    ő
    adatai
    Data related to the customer
    fiscalRepresentativeInfo -- P
    é
    nz
    ü
    gyi k
    é
    pvisel
    ő
    adatai
    Data related to the fiscal representative
    invoiceDetail -- Sz
    á
    mla r
    é
    szletez
    ő
    adatok
    Invoice detail adata

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, supplierInfo=None, customerInfo=None, fiscalRepresentativeInfo=None, invoiceDetail=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.supplierInfo = supplierInfo
        self.supplierInfo_nsprefix_ = None
        self.customerInfo = customerInfo
        self.customerInfo_nsprefix_ = None
        self.fiscalRepresentativeInfo = fiscalRepresentativeInfo
        self.fiscalRepresentativeInfo_nsprefix_ = None
        self.invoiceDetail = invoiceDetail
        self.invoiceDetail_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceHeadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceHeadType.subclass:
            return InvoiceHeadType.subclass(*args_, **kwargs_)
        else:
            return InvoiceHeadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_supplierInfo(self):
        return self.supplierInfo
    def set_supplierInfo(self, supplierInfo):
        self.supplierInfo = supplierInfo
    def get_customerInfo(self):
        return self.customerInfo
    def set_customerInfo(self, customerInfo):
        self.customerInfo = customerInfo
    def get_fiscalRepresentativeInfo(self):
        return self.fiscalRepresentativeInfo
    def set_fiscalRepresentativeInfo(self, fiscalRepresentativeInfo):
        self.fiscalRepresentativeInfo = fiscalRepresentativeInfo
    def get_invoiceDetail(self):
        return self.invoiceDetail
    def set_invoiceDetail(self, invoiceDetail):
        self.invoiceDetail = invoiceDetail
    def _hasContent(self):
        if (
            self.supplierInfo is not None or
            self.customerInfo is not None or
            self.fiscalRepresentativeInfo is not None or
            self.invoiceDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceHeadType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceHeadType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceHeadType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceHeadType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceHeadType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceHeadType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceHeadType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.supplierInfo is not None:
            namespaceprefix_ = self.supplierInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierInfo_nsprefix_) else ''
            self.supplierInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supplierInfo', pretty_print=pretty_print)
        if self.customerInfo is not None:
            namespaceprefix_ = self.customerInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.customerInfo_nsprefix_) else ''
            self.customerInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='customerInfo', pretty_print=pretty_print)
        if self.fiscalRepresentativeInfo is not None:
            namespaceprefix_ = self.fiscalRepresentativeInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.fiscalRepresentativeInfo_nsprefix_) else ''
            self.fiscalRepresentativeInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fiscalRepresentativeInfo', pretty_print=pretty_print)
        if self.invoiceDetail is not None:
            namespaceprefix_ = self.invoiceDetail_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceDetail_nsprefix_) else ''
            self.invoiceDetail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceDetail', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceHeadType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.supplierInfo is not None:
            supplierInfo_ = self.supplierInfo
            supplierInfo_.to_etree(element, name_='supplierInfo', mapping_=mapping_, nsmap_=nsmap_)
        if self.customerInfo is not None:
            customerInfo_ = self.customerInfo
            customerInfo_.to_etree(element, name_='customerInfo', mapping_=mapping_, nsmap_=nsmap_)
        if self.fiscalRepresentativeInfo is not None:
            fiscalRepresentativeInfo_ = self.fiscalRepresentativeInfo
            fiscalRepresentativeInfo_.to_etree(element, name_='fiscalRepresentativeInfo', mapping_=mapping_, nsmap_=nsmap_)
        if self.invoiceDetail is not None:
            invoiceDetail_ = self.invoiceDetail
            invoiceDetail_.to_etree(element, name_='invoiceDetail', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceHeadType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.supplierInfo is not None:
            showIndent(outfile, level)
            outfile.write('supplierInfo=model_.SupplierInfoType(\n')
            self.supplierInfo.exportLiteral(outfile, level, name_='supplierInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.customerInfo is not None:
            showIndent(outfile, level)
            outfile.write('customerInfo=model_.CustomerInfoType(\n')
            self.customerInfo.exportLiteral(outfile, level, name_='customerInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fiscalRepresentativeInfo is not None:
            showIndent(outfile, level)
            outfile.write('fiscalRepresentativeInfo=model_.FiscalRepresentativeType(\n')
            self.fiscalRepresentativeInfo.exportLiteral(outfile, level, name_='fiscalRepresentativeInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.invoiceDetail is not None:
            showIndent(outfile, level)
            outfile.write('invoiceDetail=model_.InvoiceDetailType(\n')
            self.invoiceDetail.exportLiteral(outfile, level, name_='invoiceDetail')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'supplierInfo':
            obj_ = SupplierInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supplierInfo = obj_
            obj_.original_tagname_ = 'supplierInfo'
        elif nodeName_ == 'customerInfo':
            obj_ = CustomerInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customerInfo = obj_
            obj_.original_tagname_ = 'customerInfo'
        elif nodeName_ == 'fiscalRepresentativeInfo':
            obj_ = FiscalRepresentativeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fiscalRepresentativeInfo = obj_
            obj_.original_tagname_ = 'fiscalRepresentativeInfo'
        elif nodeName_ == 'invoiceDetail':
            obj_ = InvoiceDetailType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceDetail = obj_
            obj_.original_tagname_ = 'invoiceDetail'
# end class InvoiceHeadType


class InvoiceMainType(GeneratedsSuper):
    """InvoiceMainType -- Sz
    á
    mlaadatok le
    í
    r
    á
    s
    á
    ra szolg
    á
    l
    ó
    k
    ö
    z
    ö
    s t
    í
    pus
    A common type to describe invoice information
    invoice -- Egy sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat adatai
    Data of a single invoice or modification document
    batchInvoice -- K
    ö
    tegelt m
    ó
    dos
    í
    t
    ó
    okirat adatai
    Data of a batch of modification documents

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoice=None, batchInvoice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoice = invoice
        self.invoice_nsprefix_ = None
        if batchInvoice is None:
            self.batchInvoice = []
        else:
            self.batchInvoice = batchInvoice
        self.batchInvoice_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceMainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceMainType.subclass:
            return InvoiceMainType.subclass(*args_, **kwargs_)
        else:
            return InvoiceMainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoice(self):
        return self.invoice
    def set_invoice(self, invoice):
        self.invoice = invoice
    def get_batchInvoice(self):
        return self.batchInvoice
    def set_batchInvoice(self, batchInvoice):
        self.batchInvoice = batchInvoice
    def add_batchInvoice(self, value):
        self.batchInvoice.append(value)
    def insert_batchInvoice_at(self, index, value):
        self.batchInvoice.insert(index, value)
    def replace_batchInvoice_at(self, index, value):
        self.batchInvoice[index] = value
    def _hasContent(self):
        if (
            self.invoice is not None or
            self.batchInvoice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceMainType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceMainType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceMainType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceMainType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceMainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceMainType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceMainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoice is not None:
            namespaceprefix_ = self.invoice_nsprefix_ + ':' if (UseCapturedNS_ and self.invoice_nsprefix_) else ''
            self.invoice.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoice', pretty_print=pretty_print)
        for batchInvoice_ in self.batchInvoice:
            namespaceprefix_ = self.batchInvoice_nsprefix_ + ':' if (UseCapturedNS_ and self.batchInvoice_nsprefix_) else ''
            batchInvoice_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='batchInvoice', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceMainType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.invoice is not None:
            invoice_ = self.invoice
            invoice_.to_etree(element, name_='invoice', mapping_=mapping_, nsmap_=nsmap_)
        for batchInvoice_ in self.batchInvoice:
            batchInvoice_.to_etree(element, name_='batchInvoice', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceMainType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoice is not None:
            showIndent(outfile, level)
            outfile.write('invoice=model_.InvoiceType(\n')
            self.invoice.exportLiteral(outfile, level, name_='invoice')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('batchInvoice=[\n')
        level += 1
        for batchInvoice_ in self.batchInvoice:
            showIndent(outfile, level)
            outfile.write('model_.BatchInvoiceType(\n')
            batchInvoice_.exportLiteral(outfile, level, name_='BatchInvoiceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoice':
            obj_ = InvoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoice = obj_
            obj_.original_tagname_ = 'invoice'
        elif nodeName_ == 'batchInvoice':
            obj_ = BatchInvoiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.batchInvoice.append(obj_)
            obj_.original_tagname_ = 'batchInvoice'
# end class InvoiceMainType


class InvoiceReferenceType(GeneratedsSuper):
    """InvoiceReferenceType -- A m
    ó
    dos
    í
    t
    á
    s vagy
    é
    rv
    é
    nytelen
    í
    t
    é
    s hivatkoz
    á
    si adatai
    Modification or cancellation reference data
    originalInvoiceNumber -- Az eredeti sz
    á
    mla sorsz
    á
    ma, melyre a m
    ó
    dos
    í
    t
    á
    s vonatkozik  -
    Á
    FA tv. 170.
    §
    (1) c)
    Sequence number of the original invoice, on which the modification occurs - section 170 (1) c) of the VAT law
    modifyWithoutMaster -- Annak jelz
    é
    se, hogy a m
    ó
    dos
    í
    t
    á
    s olyan alapsz
    á
    ml
    á
    ra hivatkozik, amelyr
    ő
    l nem t
    ö
    rt
    é
    nt
    é
    s nem is fog t
    ö
    rt
    é
    nni adatszolg
    á
    ltat
    á
    s
    Indicates whether the modification references to an original invoice which is not and will not be exchanged
    modificationIndex -- A sz
    á
    ml
    á
    ra vonatkoz
    ó
    m
    ó
    dos
    í
    t
    ó
    okirat egyedi sorsz
    á
    ma
    The unique sequence number referring to the original invoice

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, originalInvoiceNumber=None, modifyWithoutMaster=None, modificationIndex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.originalInvoiceNumber = originalInvoiceNumber
        self.validate_SimpleText50NotBlankType(self.originalInvoiceNumber)
        self.originalInvoiceNumber_nsprefix_ = "common"
        self.modifyWithoutMaster = modifyWithoutMaster
        self.modifyWithoutMaster_nsprefix_ = "xs"
        self.modificationIndex = modificationIndex
        self.validate_InvoiceUnboundedIndexType(self.modificationIndex)
        self.modificationIndex_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceReferenceType.subclass:
            return InvoiceReferenceType.subclass(*args_, **kwargs_)
        else:
            return InvoiceReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originalInvoiceNumber(self):
        return self.originalInvoiceNumber
    def set_originalInvoiceNumber(self, originalInvoiceNumber):
        self.originalInvoiceNumber = originalInvoiceNumber
    def get_modifyWithoutMaster(self):
        return self.modifyWithoutMaster
    def set_modifyWithoutMaster(self, modifyWithoutMaster):
        self.modifyWithoutMaster = modifyWithoutMaster
    def get_modificationIndex(self):
        return self.modificationIndex
    def set_modificationIndex(self, modificationIndex):
        self.modificationIndex = modificationIndex
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceUnboundedIndexType(self, value):
        result = True
        # Validate type InvoiceUnboundedIndexType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceUnboundedIndexType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.originalInvoiceNumber is not None or
            self.modifyWithoutMaster is not None or
            self.modificationIndex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='InvoiceReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceReferenceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceReferenceType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='InvoiceReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originalInvoiceNumber is not None:
            namespaceprefix_ = self.originalInvoiceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.originalInvoiceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginalInvoiceNumber>%s</%soriginalInvoiceNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originalInvoiceNumber), input_name='originalInvoiceNumber')), namespaceprefix_ , eol_))
        if self.modifyWithoutMaster is not None:
            namespaceprefix_ = self.modifyWithoutMaster_nsprefix_ + ':' if (UseCapturedNS_ and self.modifyWithoutMaster_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodifyWithoutMaster>%s</%smodifyWithoutMaster>%s' % (namespaceprefix_ , self.gds_format_boolean(self.modifyWithoutMaster, input_name='modifyWithoutMaster'), namespaceprefix_ , eol_))
        if self.modificationIndex is not None:
            namespaceprefix_ = self.modificationIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.modificationIndex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodificationIndex>%s</%smodificationIndex>%s' % (namespaceprefix_ , self.gds_format_integer(self.modificationIndex, input_name='modificationIndex'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='InvoiceReferenceType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.originalInvoiceNumber is not None:
            originalInvoiceNumber_ = self.originalInvoiceNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}originalInvoiceNumber').text = self.gds_format_string(originalInvoiceNumber_)
        if self.modifyWithoutMaster is not None:
            modifyWithoutMaster_ = self.modifyWithoutMaster
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}modifyWithoutMaster').text = self.gds_format_boolean(modifyWithoutMaster_)
        if self.modificationIndex is not None:
            modificationIndex_ = self.modificationIndex
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}modificationIndex').text = self.gds_format_integer(modificationIndex_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceReferenceType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.originalInvoiceNumber is not None:
            showIndent(outfile, level)
            outfile.write('originalInvoiceNumber=%s,\n' % self.gds_encode(quote_python(self.originalInvoiceNumber)))
        if self.modifyWithoutMaster is not None:
            showIndent(outfile, level)
            outfile.write('modifyWithoutMaster=%s,\n' % self.modifyWithoutMaster)
        if self.modificationIndex is not None:
            showIndent(outfile, level)
            outfile.write('modificationIndex=%d,\n' % self.modificationIndex)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originalInvoiceNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originalInvoiceNumber')
            value_ = self.gds_validate_string(value_, node, 'originalInvoiceNumber')
            self.originalInvoiceNumber = value_
            self.originalInvoiceNumber_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.originalInvoiceNumber)
        elif nodeName_ == 'modifyWithoutMaster':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'modifyWithoutMaster')
            ival_ = self.gds_validate_boolean(ival_, node, 'modifyWithoutMaster')
            self.modifyWithoutMaster = ival_
            self.modifyWithoutMaster_nsprefix_ = child_.prefix
        elif nodeName_ == 'modificationIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'modificationIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'modificationIndex')
            self.modificationIndex = ival_
            self.modificationIndex_nsprefix_ = child_.prefix
            # validate type InvoiceUnboundedIndexType
            self.validate_InvoiceUnboundedIndexType(self.modificationIndex)
# end class InvoiceReferenceType


class InvoiceType(GeneratedsSuper):
    """InvoiceType -- Egy sz
    á
    mla vagy m
    ó
    dos
    í
    t
    ó
    okirat adatai
    Data of a single invoice or modification document
    invoiceReference -- A m
    ó
    dos
    í
    t
    á
    s vagy
    é
    rv
    é
    nytelen
    í
    t
    é
    s adatai
    Modification or cancellation data
    invoiceHead -- A sz
    á
    mla eg
    é
    sz
    é
    t jellemz
    ő
    adatok
    Data concerning the whole invoice
    invoiceLines -- A sz
    á
    ml
    á
    n szerepl
    ő
    t
    é
    telek adatai
    Product/service data appearing on the invoice
    productFeeSummary -- Term
    é
    kd
    í
    jjal kapcsolatos
    ö
    sszes
    í
    t
    ő
    adatok
    Summary data of product charges
    invoiceSummary -- Az
    Á
    FA t
    ö
    rv
    é
    ny szerinti
    ö
    sszes
    í
    t
    ő
    adatok
    Summary data according to VAT law

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceReference=None, invoiceHead=None, invoiceLines=None, productFeeSummary=None, invoiceSummary=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceReference = invoiceReference
        self.invoiceReference_nsprefix_ = None
        self.invoiceHead = invoiceHead
        self.invoiceHead_nsprefix_ = None
        self.invoiceLines = invoiceLines
        self.invoiceLines_nsprefix_ = None
        if productFeeSummary is None:
            self.productFeeSummary = []
        else:
            self.productFeeSummary = productFeeSummary
        self.productFeeSummary_nsprefix_ = None
        self.invoiceSummary = invoiceSummary
        self.invoiceSummary_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceType.subclass:
            return InvoiceType.subclass(*args_, **kwargs_)
        else:
            return InvoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceReference(self):
        return self.invoiceReference
    def set_invoiceReference(self, invoiceReference):
        self.invoiceReference = invoiceReference
    def get_invoiceHead(self):
        return self.invoiceHead
    def set_invoiceHead(self, invoiceHead):
        self.invoiceHead = invoiceHead
    def get_invoiceLines(self):
        return self.invoiceLines
    def set_invoiceLines(self, invoiceLines):
        self.invoiceLines = invoiceLines
    def get_productFeeSummary(self):
        return self.productFeeSummary
    def set_productFeeSummary(self, productFeeSummary):
        self.productFeeSummary = productFeeSummary
    def add_productFeeSummary(self, value):
        self.productFeeSummary.append(value)
    def insert_productFeeSummary_at(self, index, value):
        self.productFeeSummary.insert(index, value)
    def replace_productFeeSummary_at(self, index, value):
        self.productFeeSummary[index] = value
    def get_invoiceSummary(self):
        return self.invoiceSummary
    def set_invoiceSummary(self, invoiceSummary):
        self.invoiceSummary = invoiceSummary
    def _hasContent(self):
        if (
            self.invoiceReference is not None or
            self.invoiceHead is not None or
            self.invoiceLines is not None or
            self.productFeeSummary or
            self.invoiceSummary is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='InvoiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceReference is not None:
            namespaceprefix_ = self.invoiceReference_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceReference_nsprefix_) else ''
            self.invoiceReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceReference', pretty_print=pretty_print)
        if self.invoiceHead is not None:
            namespaceprefix_ = self.invoiceHead_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceHead_nsprefix_) else ''
            self.invoiceHead.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceHead', pretty_print=pretty_print)
        if self.invoiceLines is not None:
            namespaceprefix_ = self.invoiceLines_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceLines_nsprefix_) else ''
            self.invoiceLines.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceLines', pretty_print=pretty_print)
        for productFeeSummary_ in self.productFeeSummary:
            namespaceprefix_ = self.productFeeSummary_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeSummary_nsprefix_) else ''
            productFeeSummary_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='productFeeSummary', pretty_print=pretty_print)
        if self.invoiceSummary is not None:
            namespaceprefix_ = self.invoiceSummary_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceSummary_nsprefix_) else ''
            self.invoiceSummary.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invoiceSummary', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.invoiceReference is not None:
            invoiceReference_ = self.invoiceReference
            invoiceReference_.to_etree(element, name_='invoiceReference', mapping_=mapping_, nsmap_=nsmap_)
        if self.invoiceHead is not None:
            invoiceHead_ = self.invoiceHead
            invoiceHead_.to_etree(element, name_='invoiceHead', mapping_=mapping_, nsmap_=nsmap_)
        if self.invoiceLines is not None:
            invoiceLines_ = self.invoiceLines
            invoiceLines_.to_etree(element, name_='invoiceLines', mapping_=mapping_, nsmap_=nsmap_)
        for productFeeSummary_ in self.productFeeSummary:
            productFeeSummary_.to_etree(element, name_='productFeeSummary', mapping_=mapping_, nsmap_=nsmap_)
        if self.invoiceSummary is not None:
            invoiceSummary_ = self.invoiceSummary
            invoiceSummary_.to_etree(element, name_='invoiceSummary', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceReference is not None:
            showIndent(outfile, level)
            outfile.write('invoiceReference=model_.InvoiceReferenceType(\n')
            self.invoiceReference.exportLiteral(outfile, level, name_='invoiceReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.invoiceHead is not None:
            showIndent(outfile, level)
            outfile.write('invoiceHead=model_.InvoiceHeadType(\n')
            self.invoiceHead.exportLiteral(outfile, level, name_='invoiceHead')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.invoiceLines is not None:
            showIndent(outfile, level)
            outfile.write('invoiceLines=model_.LinesType(\n')
            self.invoiceLines.exportLiteral(outfile, level, name_='invoiceLines')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('productFeeSummary=[\n')
        level += 1
        for productFeeSummary_ in self.productFeeSummary:
            showIndent(outfile, level)
            outfile.write('model_.ProductFeeSummaryType(\n')
            productFeeSummary_.exportLiteral(outfile, level, name_='ProductFeeSummaryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.invoiceSummary is not None:
            showIndent(outfile, level)
            outfile.write('invoiceSummary=model_.SummaryType(\n')
            self.invoiceSummary.exportLiteral(outfile, level, name_='invoiceSummary')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceReference':
            obj_ = InvoiceReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceReference = obj_
            obj_.original_tagname_ = 'invoiceReference'
        elif nodeName_ == 'invoiceHead':
            obj_ = InvoiceHeadType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceHead = obj_
            obj_.original_tagname_ = 'invoiceHead'
        elif nodeName_ == 'invoiceLines':
            obj_ = LinesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceLines = obj_
            obj_.original_tagname_ = 'invoiceLines'
        elif nodeName_ == 'productFeeSummary':
            obj_ = ProductFeeSummaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productFeeSummary.append(obj_)
            obj_.original_tagname_ = 'productFeeSummary'
        elif nodeName_ == 'invoiceSummary':
            obj_ = SummaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invoiceSummary = obj_
            obj_.original_tagname_ = 'invoiceSummary'
# end class InvoiceType


class ItemNumbersType(GeneratedsSuper):
    """ItemNumbersType -- Cikksz
    á
    mok
    Item numbers
    itemNumber -- Cikksz
    á
    m
    Item number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, itemNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if itemNumber is None:
            self.itemNumber = []
        else:
            self.itemNumber = itemNumber
        self.itemNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ItemNumbersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ItemNumbersType.subclass:
            return ItemNumbersType.subclass(*args_, **kwargs_)
        else:
            return ItemNumbersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_itemNumber(self):
        return self.itemNumber
    def set_itemNumber(self, itemNumber):
        self.itemNumber = itemNumber
    def add_itemNumber(self, value):
        self.itemNumber.append(value)
    def insert_itemNumber_at(self, index, value):
        self.itemNumber.insert(index, value)
    def replace_itemNumber_at(self, index, value):
        self.itemNumber[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.itemNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='ItemNumbersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ItemNumbersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ItemNumbersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ItemNumbersType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ItemNumbersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ItemNumbersType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='ItemNumbersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for itemNumber_ in self.itemNumber:
            namespaceprefix_ = self.itemNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.itemNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sitemNumber>%s</%sitemNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(itemNumber_), input_name='itemNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='ItemNumbersType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for itemNumber_ in self.itemNumber:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}itemNumber').text = self.gds_format_string(itemNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ItemNumbersType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('itemNumber=[\n')
        level += 1
        for itemNumber_ in self.itemNumber:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(itemNumber_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'itemNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'itemNumber')
            value_ = self.gds_validate_string(value_, node, 'itemNumber')
            self.itemNumber.append(value_)
            self.itemNumber_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.itemNumber[-1])
# end class ItemNumbersType


class LineAmountsNormalType(GeneratedsSuper):
    """LineAmountsNormalType -- Norm
    á
    l vagy gy
    ű
    jt
    ő
    sz
    á
    mla eset
    é
    n kit
    ö
    ltend
    ő
    t
    é
    tel
    é
    rt
    é
    k adatok
    Item value data to be completed in case of normal or aggregate invoice
    lineNetAmountData -- T
    é
    tel nett
    ó
    adatok
    Line net data
    lineVatRate -- Ad
    ó
    m
    é
    rt
    é
    k vagy ad
    ó
    mentess
    é
    g jel
    ö
    l
    é
    se
    Tax rate or tax exemption marking
    lineVatData -- T
    é
    tel
    Á
    FA adatok
    Line VAT data
    lineGrossAmountData -- T
    é
    tel brutt
    ó
    adatok
    Line gross data

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lineNetAmountData=None, lineVatRate=None, lineVatData=None, lineGrossAmountData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lineNetAmountData = lineNetAmountData
        self.lineNetAmountData_nsprefix_ = None
        self.lineVatRate = lineVatRate
        self.lineVatRate_nsprefix_ = None
        self.lineVatData = lineVatData
        self.lineVatData_nsprefix_ = None
        self.lineGrossAmountData = lineGrossAmountData
        self.lineGrossAmountData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineAmountsNormalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineAmountsNormalType.subclass:
            return LineAmountsNormalType.subclass(*args_, **kwargs_)
        else:
            return LineAmountsNormalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lineNetAmountData(self):
        return self.lineNetAmountData
    def set_lineNetAmountData(self, lineNetAmountData):
        self.lineNetAmountData = lineNetAmountData
    def get_lineVatRate(self):
        return self.lineVatRate
    def set_lineVatRate(self, lineVatRate):
        self.lineVatRate = lineVatRate
    def get_lineVatData(self):
        return self.lineVatData
    def set_lineVatData(self, lineVatData):
        self.lineVatData = lineVatData
    def get_lineGrossAmountData(self):
        return self.lineGrossAmountData
    def set_lineGrossAmountData(self, lineGrossAmountData):
        self.lineGrossAmountData = lineGrossAmountData
    def _hasContent(self):
        if (
            self.lineNetAmountData is not None or
            self.lineVatRate is not None or
            self.lineVatData is not None or
            self.lineGrossAmountData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='LineAmountsNormalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineAmountsNormalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineAmountsNormalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineAmountsNormalType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineAmountsNormalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineAmountsNormalType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='LineAmountsNormalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lineNetAmountData is not None:
            namespaceprefix_ = self.lineNetAmountData_nsprefix_ + ':' if (UseCapturedNS_ and self.lineNetAmountData_nsprefix_) else ''
            self.lineNetAmountData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lineNetAmountData', pretty_print=pretty_print)
        if self.lineVatRate is not None:
            namespaceprefix_ = self.lineVatRate_nsprefix_ + ':' if (UseCapturedNS_ and self.lineVatRate_nsprefix_) else ''
            self.lineVatRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lineVatRate', pretty_print=pretty_print)
        if self.lineVatData is not None:
            namespaceprefix_ = self.lineVatData_nsprefix_ + ':' if (UseCapturedNS_ and self.lineVatData_nsprefix_) else ''
            self.lineVatData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lineVatData', pretty_print=pretty_print)
        if self.lineGrossAmountData is not None:
            namespaceprefix_ = self.lineGrossAmountData_nsprefix_ + ':' if (UseCapturedNS_ and self.lineGrossAmountData_nsprefix_) else ''
            self.lineGrossAmountData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lineGrossAmountData', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='LineAmountsNormalType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.lineNetAmountData is not None:
            lineNetAmountData_ = self.lineNetAmountData
            lineNetAmountData_.to_etree(element, name_='lineNetAmountData', mapping_=mapping_, nsmap_=nsmap_)
        if self.lineVatRate is not None:
            lineVatRate_ = self.lineVatRate
            lineVatRate_.to_etree(element, name_='lineVatRate', mapping_=mapping_, nsmap_=nsmap_)
        if self.lineVatData is not None:
            lineVatData_ = self.lineVatData
            lineVatData_.to_etree(element, name_='lineVatData', mapping_=mapping_, nsmap_=nsmap_)
        if self.lineGrossAmountData is not None:
            lineGrossAmountData_ = self.lineGrossAmountData
            lineGrossAmountData_.to_etree(element, name_='lineGrossAmountData', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='LineAmountsNormalType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.lineNetAmountData is not None:
            showIndent(outfile, level)
            outfile.write('lineNetAmountData=model_.LineNetAmountDataType(\n')
            self.lineNetAmountData.exportLiteral(outfile, level, name_='lineNetAmountData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lineVatRate is not None:
            showIndent(outfile, level)
            outfile.write('lineVatRate=model_.VatRateType(\n')
            self.lineVatRate.exportLiteral(outfile, level, name_='lineVatRate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lineVatData is not None:
            showIndent(outfile, level)
            outfile.write('lineVatData=model_.LineVatDataType(\n')
            self.lineVatData.exportLiteral(outfile, level, name_='lineVatData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lineGrossAmountData is not None:
            showIndent(outfile, level)
            outfile.write('lineGrossAmountData=model_.LineGrossAmountDataType(\n')
            self.lineGrossAmountData.exportLiteral(outfile, level, name_='lineGrossAmountData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lineNetAmountData':
            obj_ = LineNetAmountDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lineNetAmountData = obj_
            obj_.original_tagname_ = 'lineNetAmountData'
        elif nodeName_ == 'lineVatRate':
            obj_ = VatRateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lineVatRate = obj_
            obj_.original_tagname_ = 'lineVatRate'
        elif nodeName_ == 'lineVatData':
            obj_ = LineVatDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lineVatData = obj_
            obj_.original_tagname_ = 'lineVatData'
        elif nodeName_ == 'lineGrossAmountData':
            obj_ = LineGrossAmountDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lineGrossAmountData = obj_
            obj_.original_tagname_ = 'lineGrossAmountData'
# end class LineAmountsNormalType


class LineAmountsSimplifiedType(GeneratedsSuper):
    """LineAmountsSimplifiedType -- Egyszer
    ű
    s
    í
    tett sz
    á
    mla eset
    é
    n kit
    ö
    ltend
    ő
    t
    é
    tel
    é
    rt
    é
    k adatok
    Item value data to be completed in case of simplified invoice
    lineVatRate -- Ad
    ó
    m
    é
    rt
    é
    k vagy ad
    ó
    mentess
    é
    g jel
    ö
    l
    é
    se
    Tax rate or tax exemption marking
    lineGrossAmountSimplified -- T
    é
    tel brutt
    ó
    é
    rt
    é
    ke a sz
    á
    mla p
    é
    nznem
    é
    ben
    Gross amount of the item expressed in the currency of the invoice
    lineGrossAmountSimplifiedHUF -- T
    é
    tel brutt
    ó
    é
    rt
    é
    ke forintban
    Gross amount of the item expressed in HUF

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lineVatRate=None, lineGrossAmountSimplified=None, lineGrossAmountSimplifiedHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lineVatRate = lineVatRate
        self.lineVatRate_nsprefix_ = None
        self.lineGrossAmountSimplified = lineGrossAmountSimplified
        self.validate_MonetaryType(self.lineGrossAmountSimplified)
        self.lineGrossAmountSimplified_nsprefix_ = "base"
        self.lineGrossAmountSimplifiedHUF = lineGrossAmountSimplifiedHUF
        self.validate_MonetaryType(self.lineGrossAmountSimplifiedHUF)
        self.lineGrossAmountSimplifiedHUF_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineAmountsSimplifiedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineAmountsSimplifiedType.subclass:
            return LineAmountsSimplifiedType.subclass(*args_, **kwargs_)
        else:
            return LineAmountsSimplifiedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lineVatRate(self):
        return self.lineVatRate
    def set_lineVatRate(self, lineVatRate):
        self.lineVatRate = lineVatRate
    def get_lineGrossAmountSimplified(self):
        return self.lineGrossAmountSimplified
    def set_lineGrossAmountSimplified(self, lineGrossAmountSimplified):
        self.lineGrossAmountSimplified = lineGrossAmountSimplified
    def get_lineGrossAmountSimplifiedHUF(self):
        return self.lineGrossAmountSimplifiedHUF
    def set_lineGrossAmountSimplifiedHUF(self, lineGrossAmountSimplifiedHUF):
        self.lineGrossAmountSimplifiedHUF = lineGrossAmountSimplifiedHUF
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.lineVatRate is not None or
            self.lineGrossAmountSimplified is not None or
            self.lineGrossAmountSimplifiedHUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='LineAmountsSimplifiedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineAmountsSimplifiedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineAmountsSimplifiedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineAmountsSimplifiedType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineAmountsSimplifiedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineAmountsSimplifiedType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='LineAmountsSimplifiedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lineVatRate is not None:
            namespaceprefix_ = self.lineVatRate_nsprefix_ + ':' if (UseCapturedNS_ and self.lineVatRate_nsprefix_) else ''
            self.lineVatRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lineVatRate', pretty_print=pretty_print)
        if self.lineGrossAmountSimplified is not None:
            namespaceprefix_ = self.lineGrossAmountSimplified_nsprefix_ + ':' if (UseCapturedNS_ and self.lineGrossAmountSimplified_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineGrossAmountSimplified>%s</%slineGrossAmountSimplified>%s' % (namespaceprefix_ , self.gds_format_decimal(self.lineGrossAmountSimplified, input_name='lineGrossAmountSimplified'), namespaceprefix_ , eol_))
        if self.lineGrossAmountSimplifiedHUF is not None:
            namespaceprefix_ = self.lineGrossAmountSimplifiedHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.lineGrossAmountSimplifiedHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineGrossAmountSimplifiedHUF>%s</%slineGrossAmountSimplifiedHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.lineGrossAmountSimplifiedHUF, input_name='lineGrossAmountSimplifiedHUF'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='LineAmountsSimplifiedType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.lineVatRate is not None:
            lineVatRate_ = self.lineVatRate
            lineVatRate_.to_etree(element, name_='lineVatRate', mapping_=mapping_, nsmap_=nsmap_)
        if self.lineGrossAmountSimplified is not None:
            lineGrossAmountSimplified_ = self.lineGrossAmountSimplified
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineGrossAmountSimplified').text = self.gds_format_decimal(lineGrossAmountSimplified_)
        if self.lineGrossAmountSimplifiedHUF is not None:
            lineGrossAmountSimplifiedHUF_ = self.lineGrossAmountSimplifiedHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineGrossAmountSimplifiedHUF').text = self.gds_format_decimal(lineGrossAmountSimplifiedHUF_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='LineAmountsSimplifiedType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.lineVatRate is not None:
            showIndent(outfile, level)
            outfile.write('lineVatRate=model_.VatRateType(\n')
            self.lineVatRate.exportLiteral(outfile, level, name_='lineVatRate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lineGrossAmountSimplified is not None:
            showIndent(outfile, level)
            outfile.write('lineGrossAmountSimplified=%f,\n' % self.lineGrossAmountSimplified)
        if self.lineGrossAmountSimplifiedHUF is not None:
            showIndent(outfile, level)
            outfile.write('lineGrossAmountSimplifiedHUF=%f,\n' % self.lineGrossAmountSimplifiedHUF)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lineVatRate':
            obj_ = VatRateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lineVatRate = obj_
            obj_.original_tagname_ = 'lineVatRate'
        elif nodeName_ == 'lineGrossAmountSimplified' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'lineGrossAmountSimplified')
            fval_ = self.gds_validate_decimal(fval_, node, 'lineGrossAmountSimplified')
            self.lineGrossAmountSimplified = fval_
            self.lineGrossAmountSimplified_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.lineGrossAmountSimplified)
        elif nodeName_ == 'lineGrossAmountSimplifiedHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'lineGrossAmountSimplifiedHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'lineGrossAmountSimplifiedHUF')
            self.lineGrossAmountSimplifiedHUF = fval_
            self.lineGrossAmountSimplifiedHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.lineGrossAmountSimplifiedHUF)
# end class LineAmountsSimplifiedType


class LineGrossAmountDataType(GeneratedsSuper):
    """LineGrossAmountDataType -- T
    é
    tel brutt
    ó
    adatok
    Line gross data
    lineGrossAmountNormal -- T
    é
    tel brutt
    ó
    é
    rt
    é
    ke a sz
    á
    mla p
    é
    nznem
    é
    ben.
    Á
    FA tartalm
    ú
    k
    ü
    l
    ö
    nb
    ö
    zeti ad
    ó
    z
    á
    s eset
    é
    n az ellen
    é
    rt
    é
    k.
    Gross amount of the item expressed in the currency of the invoice. In case of margin scheme taxation containing VAT, the amount of consideration expressed in the currency of the invoice.
    lineGrossAmountNormalHUF -- T
    é
    tel brutt
    ó
    é
    rt
    é
    ke forintban
    Gross amount of the item expressed in HUF

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lineGrossAmountNormal=None, lineGrossAmountNormalHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lineGrossAmountNormal = lineGrossAmountNormal
        self.validate_MonetaryType(self.lineGrossAmountNormal)
        self.lineGrossAmountNormal_nsprefix_ = "base"
        self.lineGrossAmountNormalHUF = lineGrossAmountNormalHUF
        self.validate_MonetaryType(self.lineGrossAmountNormalHUF)
        self.lineGrossAmountNormalHUF_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineGrossAmountDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineGrossAmountDataType.subclass:
            return LineGrossAmountDataType.subclass(*args_, **kwargs_)
        else:
            return LineGrossAmountDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lineGrossAmountNormal(self):
        return self.lineGrossAmountNormal
    def set_lineGrossAmountNormal(self, lineGrossAmountNormal):
        self.lineGrossAmountNormal = lineGrossAmountNormal
    def get_lineGrossAmountNormalHUF(self):
        return self.lineGrossAmountNormalHUF
    def set_lineGrossAmountNormalHUF(self, lineGrossAmountNormalHUF):
        self.lineGrossAmountNormalHUF = lineGrossAmountNormalHUF
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.lineGrossAmountNormal is not None or
            self.lineGrossAmountNormalHUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='LineGrossAmountDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineGrossAmountDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineGrossAmountDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineGrossAmountDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineGrossAmountDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineGrossAmountDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='LineGrossAmountDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lineGrossAmountNormal is not None:
            namespaceprefix_ = self.lineGrossAmountNormal_nsprefix_ + ':' if (UseCapturedNS_ and self.lineGrossAmountNormal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineGrossAmountNormal>%s</%slineGrossAmountNormal>%s' % (namespaceprefix_ , self.gds_format_decimal(self.lineGrossAmountNormal, input_name='lineGrossAmountNormal'), namespaceprefix_ , eol_))
        if self.lineGrossAmountNormalHUF is not None:
            namespaceprefix_ = self.lineGrossAmountNormalHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.lineGrossAmountNormalHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineGrossAmountNormalHUF>%s</%slineGrossAmountNormalHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.lineGrossAmountNormalHUF, input_name='lineGrossAmountNormalHUF'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='LineGrossAmountDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.lineGrossAmountNormal is not None:
            lineGrossAmountNormal_ = self.lineGrossAmountNormal
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineGrossAmountNormal').text = self.gds_format_decimal(lineGrossAmountNormal_)
        if self.lineGrossAmountNormalHUF is not None:
            lineGrossAmountNormalHUF_ = self.lineGrossAmountNormalHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineGrossAmountNormalHUF').text = self.gds_format_decimal(lineGrossAmountNormalHUF_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='LineGrossAmountDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.lineGrossAmountNormal is not None:
            showIndent(outfile, level)
            outfile.write('lineGrossAmountNormal=%f,\n' % self.lineGrossAmountNormal)
        if self.lineGrossAmountNormalHUF is not None:
            showIndent(outfile, level)
            outfile.write('lineGrossAmountNormalHUF=%f,\n' % self.lineGrossAmountNormalHUF)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lineGrossAmountNormal' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'lineGrossAmountNormal')
            fval_ = self.gds_validate_decimal(fval_, node, 'lineGrossAmountNormal')
            self.lineGrossAmountNormal = fval_
            self.lineGrossAmountNormal_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.lineGrossAmountNormal)
        elif nodeName_ == 'lineGrossAmountNormalHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'lineGrossAmountNormalHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'lineGrossAmountNormalHUF')
            self.lineGrossAmountNormalHUF = fval_
            self.lineGrossAmountNormalHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.lineGrossAmountNormalHUF)
# end class LineGrossAmountDataType


class LineModificationReferenceType(GeneratedsSuper):
    """LineModificationReferenceType -- M
    ó
    dos
    í
    t
    á
    sr
    ó
    l t
    ö
    rt
    é
    n
    ő
    adatszolg
    á
    ltat
    á
    s eset
    é
    n a t
    é
    telsor m
    ó
    dos
    í
    t
    á
    s jelleg
    é
    nek jel
    ö
    l
    é
    se
    Marking the goal of modification of the line (in the case of data supply about changes/updates only)
    lineNumberReference -- Az eredeti sz
    á
    mla m
    ó
    dos
    í
    t
    á
    ssal
    é
    rintett t
    é
    tel
    é
    nek sorsz
    á
    ma (lineNumber).
    Ú
    j t
    é
    tel l
    é
    trehoz
    á
    sa eset
    é
    n az
    ú
    j t
    é
    tel sorsz
    á
    ma, a megl
    é
    v
    ő
    t
    é
    telsorok sz
    á
    moz
    á
    s
    á
    nak folytat
    á
    sak
    é
    nt
    Line number of the original invoice, which the modification occurs with. In case of create operation the tag shall contain the new line number, as a sequential increment of the the existing lines set
    lineOperation -- A sz
    á
    mlat
    é
    tel m
    ó
    dos
    í
    t
    á
    s
    á
    nak jellege
    Line modification type

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lineNumberReference=None, lineOperation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lineNumberReference = lineNumberReference
        self.validate_LineNumberType(self.lineNumberReference)
        self.lineNumberReference_nsprefix_ = "base"
        self.lineOperation = lineOperation
        self.validate_LineOperationType(self.lineOperation)
        self.lineOperation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineModificationReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineModificationReferenceType.subclass:
            return LineModificationReferenceType.subclass(*args_, **kwargs_)
        else:
            return LineModificationReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lineNumberReference(self):
        return self.lineNumberReference
    def set_lineNumberReference(self, lineNumberReference):
        self.lineNumberReference = lineNumberReference
    def get_lineOperation(self):
        return self.lineOperation
    def set_lineOperation(self, lineOperation):
        self.lineOperation = lineOperation
    def validate_LineNumberType(self, value):
        result = True
        # Validate type LineNumberType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_LineOperationType(self, value):
        result = True
        # Validate type LineOperationType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['CREATE', 'MODIFY']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on LineOperationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LineOperationType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LineOperationType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.lineNumberReference is not None or
            self.lineOperation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='LineModificationReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineModificationReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineModificationReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineModificationReferenceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineModificationReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineModificationReferenceType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='LineModificationReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lineNumberReference is not None:
            namespaceprefix_ = self.lineNumberReference_nsprefix_ + ':' if (UseCapturedNS_ and self.lineNumberReference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineNumberReference>%s</%slineNumberReference>%s' % (namespaceprefix_ , self.gds_format_integer(self.lineNumberReference, input_name='lineNumberReference'), namespaceprefix_ , eol_))
        if self.lineOperation is not None:
            namespaceprefix_ = self.lineOperation_nsprefix_ + ':' if (UseCapturedNS_ and self.lineOperation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineOperation>%s</%slineOperation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.lineOperation), input_name='lineOperation')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='LineModificationReferenceType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.lineNumberReference is not None:
            lineNumberReference_ = self.lineNumberReference
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineNumberReference').text = self.gds_format_integer(lineNumberReference_)
        if self.lineOperation is not None:
            lineOperation_ = self.lineOperation
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineOperation').text = self.gds_format_string(lineOperation_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='LineModificationReferenceType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.lineNumberReference is not None:
            showIndent(outfile, level)
            outfile.write('lineNumberReference=%d,\n' % self.lineNumberReference)
        if self.lineOperation is not None:
            showIndent(outfile, level)
            outfile.write('lineOperation=%s,\n' % self.gds_encode(quote_python(self.lineOperation)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lineNumberReference' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lineNumberReference')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'lineNumberReference')
            self.lineNumberReference = ival_
            self.lineNumberReference_nsprefix_ = child_.prefix
            # validate type LineNumberType
            self.validate_LineNumberType(self.lineNumberReference)
        elif nodeName_ == 'lineOperation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lineOperation')
            value_ = self.gds_validate_string(value_, node, 'lineOperation')
            self.lineOperation = value_
            self.lineOperation_nsprefix_ = child_.prefix
            # validate type LineOperationType
            self.validate_LineOperationType(self.lineOperation)
# end class LineModificationReferenceType


class LineNetAmountDataType(GeneratedsSuper):
    """LineNetAmountDataType -- T
    é
    tel nett
    ó
    adatok
    Line net data
    lineNetAmount -- T
    é
    tel nett
    ó
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben.
    Á
    FA tartalm
    ú
    k
    ü
    l
    ö
    nb
    ö
    zeti ad
    ó
    z
    á
    s eset
    é
    n az ellen
    é
    rt
    é
    k
    á
    fa
    ö
    sszeg
    é
    vel cs
    ö
    kkentett
    é
    rt
    é
    ke a sz
    á
    mla p
    é
    nznem
    é
    ben.
    Net amount of the item expressed in the currency of the invoice. In case of margin scheme taxation containing VAT, the amount of consideration reduced with the amount of VAT, expressed in the currency of the invoice.
    lineNetAmountHUF -- T
    é
    tel nett
    ó
    ö
    sszege forintban.
    Á
    FA tartalm
    ú
    k
    ü
    l
    ö
    nb
    ö
    zeti ad
    ó
    z
    á
    s eset
    é
    n az ellen
    é
    rt
    é
    k
    á
    fa
    ö
    sszeg
    é
    vel cs
    ö
    kkentett
    é
    rt
    é
    ke forintban.
    Net amount of the item expressed in HUF. Net amount of the item expressed in the currency of the invoice. In case of margin scheme taxation containing VAT, the amount of consideration reduced with the amount of VAT, expressed in HUF.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lineNetAmount=None, lineNetAmountHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lineNetAmount = lineNetAmount
        self.validate_MonetaryType(self.lineNetAmount)
        self.lineNetAmount_nsprefix_ = "base"
        self.lineNetAmountHUF = lineNetAmountHUF
        self.validate_MonetaryType(self.lineNetAmountHUF)
        self.lineNetAmountHUF_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineNetAmountDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineNetAmountDataType.subclass:
            return LineNetAmountDataType.subclass(*args_, **kwargs_)
        else:
            return LineNetAmountDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lineNetAmount(self):
        return self.lineNetAmount
    def set_lineNetAmount(self, lineNetAmount):
        self.lineNetAmount = lineNetAmount
    def get_lineNetAmountHUF(self):
        return self.lineNetAmountHUF
    def set_lineNetAmountHUF(self, lineNetAmountHUF):
        self.lineNetAmountHUF = lineNetAmountHUF
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.lineNetAmount is not None or
            self.lineNetAmountHUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='LineNetAmountDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineNetAmountDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineNetAmountDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineNetAmountDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineNetAmountDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineNetAmountDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='LineNetAmountDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lineNetAmount is not None:
            namespaceprefix_ = self.lineNetAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.lineNetAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineNetAmount>%s</%slineNetAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.lineNetAmount, input_name='lineNetAmount'), namespaceprefix_ , eol_))
        if self.lineNetAmountHUF is not None:
            namespaceprefix_ = self.lineNetAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.lineNetAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineNetAmountHUF>%s</%slineNetAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.lineNetAmountHUF, input_name='lineNetAmountHUF'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='LineNetAmountDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.lineNetAmount is not None:
            lineNetAmount_ = self.lineNetAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineNetAmount').text = self.gds_format_decimal(lineNetAmount_)
        if self.lineNetAmountHUF is not None:
            lineNetAmountHUF_ = self.lineNetAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineNetAmountHUF').text = self.gds_format_decimal(lineNetAmountHUF_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='LineNetAmountDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.lineNetAmount is not None:
            showIndent(outfile, level)
            outfile.write('lineNetAmount=%f,\n' % self.lineNetAmount)
        if self.lineNetAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('lineNetAmountHUF=%f,\n' % self.lineNetAmountHUF)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lineNetAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'lineNetAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'lineNetAmount')
            self.lineNetAmount = fval_
            self.lineNetAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.lineNetAmount)
        elif nodeName_ == 'lineNetAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'lineNetAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'lineNetAmountHUF')
            self.lineNetAmountHUF = fval_
            self.lineNetAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.lineNetAmountHUF)
# end class LineNetAmountDataType


class LinesType(GeneratedsSuper):
    """LinesType -- Term
    é
    k/szolg
    á
    ltat
    á
    s t
    é
    telek
    Product / service items
    mergedItemIndicator -- Jel
    ö
    li, ha az adatszolg
    á
    ltat
    á
    s m
    é
    retcs
    ö
    kkent
    é
    s miatt
    ö
    sszevont soradatokat tartalmaz
    Indicates whether the data exchange contains merged line data due to size reduction
    line -- Term
    é
    k/szolg
    á
    ltat
    á
    s t
    é
    tel
    Product / service item

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, mergedItemIndicator=None, line=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mergedItemIndicator = mergedItemIndicator
        self.mergedItemIndicator_nsprefix_ = "xs"
        if line is None:
            self.line = []
        else:
            self.line = line
        self.line_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinesType.subclass:
            return LinesType.subclass(*args_, **kwargs_)
        else:
            return LinesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mergedItemIndicator(self):
        return self.mergedItemIndicator
    def set_mergedItemIndicator(self, mergedItemIndicator):
        self.mergedItemIndicator = mergedItemIndicator
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def add_line(self, value):
        self.line.append(value)
    def insert_line_at(self, index, value):
        self.line.insert(index, value)
    def replace_line_at(self, index, value):
        self.line[index] = value
    def _hasContent(self):
        if (
            self.mergedItemIndicator is not None or
            self.line
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='LinesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LinesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LinesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LinesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LinesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='LinesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mergedItemIndicator is not None:
            namespaceprefix_ = self.mergedItemIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.mergedItemIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smergedItemIndicator>%s</%smergedItemIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.mergedItemIndicator, input_name='mergedItemIndicator'), namespaceprefix_ , eol_))
        for line_ in self.line:
            namespaceprefix_ = self.line_nsprefix_ + ':' if (UseCapturedNS_ and self.line_nsprefix_) else ''
            line_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='line', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='LinesType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.mergedItemIndicator is not None:
            mergedItemIndicator_ = self.mergedItemIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}mergedItemIndicator').text = self.gds_format_boolean(mergedItemIndicator_)
        for line_ in self.line:
            line_.to_etree(element, name_='line', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='LinesType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.mergedItemIndicator is not None:
            showIndent(outfile, level)
            outfile.write('mergedItemIndicator=%s,\n' % self.mergedItemIndicator)
        showIndent(outfile, level)
        outfile.write('line=[\n')
        level += 1
        for line_ in self.line:
            showIndent(outfile, level)
            outfile.write('model_.LineType(\n')
            line_.exportLiteral(outfile, level, name_='LineType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mergedItemIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'mergedItemIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'mergedItemIndicator')
            self.mergedItemIndicator = ival_
            self.mergedItemIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'line':
            obj_ = LineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.line.append(obj_)
            obj_.original_tagname_ = 'line'
# end class LinesType


class LineType(GeneratedsSuper):
    """LineType -- A sz
    á
    mla t
    é
    telek (term
    é
    k vagy szolg
    á
    ltat
    á
    s) adatait tartalmaz
    ó
    t
    í
    pus
    Field type including data of invoice items (product or service)
    lineNumber -- A t
    é
    tel sorsz
    á
    ma
    Sequential number of the item
    lineModificationReference -- M
    ó
    dos
    í
    t
    á
    sr
    ó
    l t
    ö
    rt
    é
    n
    ő
    adatszolg
    á
    ltat
    á
    s eset
    é
    n a t
    é
    telsor m
    ó
    dos
    í
    t
    á
    s jelleg
    é
    nek jel
    ö
    l
    é
    se
    Marking the goal of modification of the line (in the case of data supply about changes/updates only)
    referencesToOtherLines -- Hivatkoz
    á
    sok kapcsol
    ó
    d
    ó
    t
    é
    telekre, ha ez az
    Á
    FA t
    ö
    rv
    é
    ny alapj
    á
    n sz
    ü
    ks
    é
    ges
    References to connected items if it is necessary according to VAT law
    advanceData -- El
    ő
    leghez kapcsol
    ó
    d
    ó
    adatok
    Advance related data
    productCodes -- Term
    é
    kk
    ó
    dok
    Product codes
    lineExpressionIndicator -- É
    rt
    é
    ke true, ha a t
    é
    tel mennyis
    é
    gi egys
    é
    ge term
    é
    szetes m
    é
    rt
    é
    kegys
    é
    gben kifejezhet
    ő
    The value is true if the unit of measure of the invoice item is expressible in natural unit
    lineNatureIndicator -- Adott t
    é
    telsor term
    é
    k
    é
    rt
    é
    kes
    í
    t
    é
    s vagy szolg
    á
    ltat
    á
    s ny
    ú
    jt
    á
    s jelleg
    é
    nek jelz
    é
    se
    Indication of the nature of the supply of goods or services on a given line
    lineDescription -- A term
    é
    k vagy szolg
    á
    ltat
    á
    s megnevez
    é
    se
    Name / description of the product or service
    quantity -- Mennyis
    é
    g
    Quantity
    unitOfMeasure -- A sz
    á
    ml
    á
    n szerepl
    ő
    mennyis
    é
    gi egys
    é
    g kanonikus kifejez
    é
    se az interf
    é
    sz specifik
    á
    ci
    ó
    szerint
    Canonical representation of the unit of measure of the invoice, according to the interface specification
    unitOfMeasureOwn -- A sz
    á
    ml
    á
    n szerepl
    ő
    mennyis
    é
    gi egys
    é
    g liter
    á
    lis kifejez
    é
    se
    Literal unit of measure of the invoice
    unitPrice -- Egys
    é
    g
    á
    r a sz
    á
    mla p
    é
    nznem
    é
    ben. Egyszer
    ű
    s
    í
    tett sz
    á
    mla eset
    é
    n brutt
    ó
    , egy
    é
    b esetben nett
    ó
    egys
    é
    g
    á
    r
    Unit price expressed in the currency of the invoice In the event of simplified invoices gross unit price, in other cases net unit price
    unitPriceHUF -- Egys
    é
    g
    á
    r forintban
    Unit price expressed in HUF
    lineDiscountData -- A t
    é
    telhez tartoz
    ó
    á
    rengedm
    é
    ny adatok
    Discount data in relation to the item
    lineAmountsNormal -- Norm
    á
    l (nem egyszer
    ű
    s
    í
    tett) sz
    á
    mla eset
    é
    n (bele
    é
    rtve a gy
    ű
    jt
    ő
    sz
    á
    ml
    á
    t) kit
    ö
    ltend
    ő
    t
    é
    tel
    é
    rt
    é
    k adatok.
    Item value data to be completed in case of normal (not simplified, but including aggregated) invoice
    lineAmountsSimplified -- Egyszer
    ű
    s
    í
    tett sz
    á
    mla eset
    é
    n kit
    ö
    ltend
    ő
    t
    é
    tel
    é
    rt
    é
    k adatok
    Item value data to be completed in case of simplified invoice
    intermediatedService -- É
    rt
    é
    ke true ha a t
    é
    tel k
    ö
    zvet
    í
    tett szolg
    á
    ltat
    á
    s - Sz
    á
    mviteli tv. 3.
    §
    (4) 1
    The value is true if the item is an intermediated service - paragraph (4) 1 of the Article 3 of Accounting Act
    aggregateInvoiceLineData -- Gy
    ű
    jt
    ő
    sz
    á
    mla adatok
    Aggregate invoice data
    newTransportMean -- Ú
    j k
    ö
    zleked
    é
    si eszk
    ö
    z
    é
    rt
    é
    kes
    í
    t
    é
    s
    Á
    FA tv. 89
    §
    ill. 169
    §
    o)
    Supply of new means of transport - section 89
    §
    and 169 (o) of the VAT law
    depositIndicator -- É
    rt
    é
    ke true, ha a t
    é
    tel bet
    é
    td
    í
    j jelleg
    ű
    The value is true if the item is bottle/container deposit
    obligatedForProductFee -- É
    rt
    é
    ke true ha a t
    é
    telt term
    é
    kd
    í
    j fizet
    é
    si k
    ö
    telezetts
    é
    g terheli
    The value is true if the item is liable to product fee
    GPCExcise -- F
    ö
    ldg
    á
    z, villamos energia, sz
    é
    n j
    ö
    ved
    é
    ki ad
    ó
    ja forintban - J
    ö
    t. 118.
    §
    (2)
    Excise duty on natural gas, electricity and coal in Hungarian forints
    –
    paragraph (2), Section 118 of the Act on Excise Duties
    dieselOilPurchase -- G
    á
    zolaj ad
    ó
    zottan t
    ö
    rt
    é
    n
    ő
    beszerz
    é
    s
    é
    nek adatai
    –
    45/2016 (XI. 29.) NGM rendelet 75.
    §
    (1) a)
    Data of gas oil acquisition after taxation
    –
    point a), paragraph (1) of Section 75 of the NGM Decree No. 45/2016. (XI. 29.)
    netaDeclaration -- É
    rt
    é
    ke true, ha a Neta tv-ben meghat
    á
    rozott ad
    ó
    k
    ö
    telezetts
    é
    g az ad
    ó
    alany
    á
    t terheli. 2011.
    é
    vi CIII. tv. 3.
    §
    (2)
    Value is true, if the taxable person is liable for tax obligation determined in the Act on Public Health Product Tax (Neta tv.). Paragraph (2), Section 3 of the Act CIII of 2011
    productFeeClause -- A k
    ö
    rnyezetv
    é
    delmi term
    é
    kd
    í
    jr
    ó
    l sz
    ó
    l
    ó
    2011.
    é
    vi LXXXV. tv. szerinti, t
    é
    telre vonatkoz
    ó
    z
    á
    rad
    é
    kok
    Clauses according to the Act LXXXV of 2011 on Environmental Protection Product Fee (related to the item)
    lineProductFeeContent -- A t
    é
    tel term
    é
    kd
    í
    j tartalm
    á
    ra vonatkoz
    ó
    adatok
    Data on the content of the line's product charge
    conventionalLineInfo -- A sz
    á
    mlafeldolgoz
    á
    st seg
    í
    t
    ő
    , egyezm
    é
    nyesen neves
    í
    tett egy
    é
    b adatok
    Other conventionally named data to assist in invoice processing
    additionalLineData -- A term
    é
    k/szolg
    á
    ltat
    á
    s t
    é
    telhez kapcsol
    ó
    d
    ó
    , tov
    á
    bbi adat
    Other data in relation to the product / service item

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lineNumber=None, lineModificationReference=None, referencesToOtherLines=None, advanceData=None, productCodes=None, lineExpressionIndicator=None, lineNatureIndicator=None, lineDescription=None, quantity=None, unitOfMeasure=None, unitOfMeasureOwn=None, unitPrice=None, unitPriceHUF=None, lineDiscountData=None, lineAmountsNormal=None, lineAmountsSimplified=None, intermediatedService=None, aggregateInvoiceLineData=None, newTransportMean=None, depositIndicator=None, obligatedForProductFee=None, GPCExcise=None, dieselOilPurchase=None, netaDeclaration=None, productFeeClause=None, lineProductFeeContent=None, conventionalLineInfo=None, additionalLineData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lineNumber = lineNumber
        self.validate_LineNumberType(self.lineNumber)
        self.lineNumber_nsprefix_ = "base"
        self.lineModificationReference = lineModificationReference
        self.lineModificationReference_nsprefix_ = None
        self.referencesToOtherLines = referencesToOtherLines
        self.referencesToOtherLines_nsprefix_ = None
        self.advanceData = advanceData
        self.advanceData_nsprefix_ = None
        self.productCodes = productCodes
        self.productCodes_nsprefix_ = None
        self.lineExpressionIndicator = lineExpressionIndicator
        self.lineExpressionIndicator_nsprefix_ = "xs"
        self.lineNatureIndicator = lineNatureIndicator
        self.validate_LineNatureIndicatorType(self.lineNatureIndicator)
        self.lineNatureIndicator_nsprefix_ = None
        self.lineDescription = lineDescription
        self.validate_SimpleText512NotBlankType(self.lineDescription)
        self.lineDescription_nsprefix_ = "common"
        self.quantity = quantity
        self.validate_QuantityType(self.quantity)
        self.quantity_nsprefix_ = None
        self.unitOfMeasure = unitOfMeasure
        self.validate_UnitOfMeasureType(self.unitOfMeasure)
        self.unitOfMeasure_nsprefix_ = None
        self.unitOfMeasureOwn = unitOfMeasureOwn
        self.validate_SimpleText50NotBlankType(self.unitOfMeasureOwn)
        self.unitOfMeasureOwn_nsprefix_ = "common"
        self.unitPrice = unitPrice
        self.validate_QuantityType(self.unitPrice)
        self.unitPrice_nsprefix_ = None
        self.unitPriceHUF = unitPriceHUF
        self.validate_QuantityType(self.unitPriceHUF)
        self.unitPriceHUF_nsprefix_ = None
        self.lineDiscountData = lineDiscountData
        self.lineDiscountData_nsprefix_ = None
        self.lineAmountsNormal = lineAmountsNormal
        self.lineAmountsNormal_nsprefix_ = None
        self.lineAmountsSimplified = lineAmountsSimplified
        self.lineAmountsSimplified_nsprefix_ = None
        self.intermediatedService = intermediatedService
        self.intermediatedService_nsprefix_ = "xs"
        self.aggregateInvoiceLineData = aggregateInvoiceLineData
        self.aggregateInvoiceLineData_nsprefix_ = None
        self.newTransportMean = newTransportMean
        self.newTransportMean_nsprefix_ = None
        self.depositIndicator = depositIndicator
        self.depositIndicator_nsprefix_ = "xs"
        self.obligatedForProductFee = obligatedForProductFee
        self.obligatedForProductFee_nsprefix_ = "xs"
        self.GPCExcise = GPCExcise
        self.validate_MonetaryType(self.GPCExcise)
        self.GPCExcise_nsprefix_ = "base"
        self.dieselOilPurchase = dieselOilPurchase
        self.dieselOilPurchase_nsprefix_ = None
        self.netaDeclaration = netaDeclaration
        self.netaDeclaration_nsprefix_ = "xs"
        self.productFeeClause = productFeeClause
        self.productFeeClause_nsprefix_ = None
        if lineProductFeeContent is None:
            self.lineProductFeeContent = []
        else:
            self.lineProductFeeContent = lineProductFeeContent
        self.lineProductFeeContent_nsprefix_ = None
        self.conventionalLineInfo = conventionalLineInfo
        self.conventionalLineInfo_nsprefix_ = None
        if additionalLineData is None:
            self.additionalLineData = []
        else:
            self.additionalLineData = additionalLineData
        self.additionalLineData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineType.subclass:
            return LineType.subclass(*args_, **kwargs_)
        else:
            return LineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lineNumber(self):
        return self.lineNumber
    def set_lineNumber(self, lineNumber):
        self.lineNumber = lineNumber
    def get_lineModificationReference(self):
        return self.lineModificationReference
    def set_lineModificationReference(self, lineModificationReference):
        self.lineModificationReference = lineModificationReference
    def get_referencesToOtherLines(self):
        return self.referencesToOtherLines
    def set_referencesToOtherLines(self, referencesToOtherLines):
        self.referencesToOtherLines = referencesToOtherLines
    def get_advanceData(self):
        return self.advanceData
    def set_advanceData(self, advanceData):
        self.advanceData = advanceData
    def get_productCodes(self):
        return self.productCodes
    def set_productCodes(self, productCodes):
        self.productCodes = productCodes
    def get_lineExpressionIndicator(self):
        return self.lineExpressionIndicator
    def set_lineExpressionIndicator(self, lineExpressionIndicator):
        self.lineExpressionIndicator = lineExpressionIndicator
    def get_lineNatureIndicator(self):
        return self.lineNatureIndicator
    def set_lineNatureIndicator(self, lineNatureIndicator):
        self.lineNatureIndicator = lineNatureIndicator
    def get_lineDescription(self):
        return self.lineDescription
    def set_lineDescription(self, lineDescription):
        self.lineDescription = lineDescription
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def get_unitOfMeasure(self):
        return self.unitOfMeasure
    def set_unitOfMeasure(self, unitOfMeasure):
        self.unitOfMeasure = unitOfMeasure
    def get_unitOfMeasureOwn(self):
        return self.unitOfMeasureOwn
    def set_unitOfMeasureOwn(self, unitOfMeasureOwn):
        self.unitOfMeasureOwn = unitOfMeasureOwn
    def get_unitPrice(self):
        return self.unitPrice
    def set_unitPrice(self, unitPrice):
        self.unitPrice = unitPrice
    def get_unitPriceHUF(self):
        return self.unitPriceHUF
    def set_unitPriceHUF(self, unitPriceHUF):
        self.unitPriceHUF = unitPriceHUF
    def get_lineDiscountData(self):
        return self.lineDiscountData
    def set_lineDiscountData(self, lineDiscountData):
        self.lineDiscountData = lineDiscountData
    def get_lineAmountsNormal(self):
        return self.lineAmountsNormal
    def set_lineAmountsNormal(self, lineAmountsNormal):
        self.lineAmountsNormal = lineAmountsNormal
    def get_lineAmountsSimplified(self):
        return self.lineAmountsSimplified
    def set_lineAmountsSimplified(self, lineAmountsSimplified):
        self.lineAmountsSimplified = lineAmountsSimplified
    def get_intermediatedService(self):
        return self.intermediatedService
    def set_intermediatedService(self, intermediatedService):
        self.intermediatedService = intermediatedService
    def get_aggregateInvoiceLineData(self):
        return self.aggregateInvoiceLineData
    def set_aggregateInvoiceLineData(self, aggregateInvoiceLineData):
        self.aggregateInvoiceLineData = aggregateInvoiceLineData
    def get_newTransportMean(self):
        return self.newTransportMean
    def set_newTransportMean(self, newTransportMean):
        self.newTransportMean = newTransportMean
    def get_depositIndicator(self):
        return self.depositIndicator
    def set_depositIndicator(self, depositIndicator):
        self.depositIndicator = depositIndicator
    def get_obligatedForProductFee(self):
        return self.obligatedForProductFee
    def set_obligatedForProductFee(self, obligatedForProductFee):
        self.obligatedForProductFee = obligatedForProductFee
    def get_GPCExcise(self):
        return self.GPCExcise
    def set_GPCExcise(self, GPCExcise):
        self.GPCExcise = GPCExcise
    def get_dieselOilPurchase(self):
        return self.dieselOilPurchase
    def set_dieselOilPurchase(self, dieselOilPurchase):
        self.dieselOilPurchase = dieselOilPurchase
    def get_netaDeclaration(self):
        return self.netaDeclaration
    def set_netaDeclaration(self, netaDeclaration):
        self.netaDeclaration = netaDeclaration
    def get_productFeeClause(self):
        return self.productFeeClause
    def set_productFeeClause(self, productFeeClause):
        self.productFeeClause = productFeeClause
    def get_lineProductFeeContent(self):
        return self.lineProductFeeContent
    def set_lineProductFeeContent(self, lineProductFeeContent):
        self.lineProductFeeContent = lineProductFeeContent
    def add_lineProductFeeContent(self, value):
        self.lineProductFeeContent.append(value)
    def insert_lineProductFeeContent_at(self, index, value):
        self.lineProductFeeContent.insert(index, value)
    def replace_lineProductFeeContent_at(self, index, value):
        self.lineProductFeeContent[index] = value
    def get_conventionalLineInfo(self):
        return self.conventionalLineInfo
    def set_conventionalLineInfo(self, conventionalLineInfo):
        self.conventionalLineInfo = conventionalLineInfo
    def get_additionalLineData(self):
        return self.additionalLineData
    def set_additionalLineData(self, additionalLineData):
        self.additionalLineData = additionalLineData
    def add_additionalLineData(self, value):
        self.additionalLineData.append(value)
    def insert_additionalLineData_at(self, index, value):
        self.additionalLineData.insert(index, value)
    def replace_additionalLineData_at(self, index, value):
        self.additionalLineData[index] = value
    def validate_LineNumberType(self, value):
        result = True
        # Validate type LineNumberType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_LineNatureIndicatorType(self, value):
        result = True
        # Validate type LineNatureIndicatorType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['PRODUCT', 'SERVICE', 'OTHER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on LineNatureIndicatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LineNatureIndicatorType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LineNatureIndicatorType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_QuantityType(self, value):
        result = True
        # Validate type QuantityType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 22:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_UnitOfMeasureType(self, value):
        result = True
        # Validate type UnitOfMeasureType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['PIECE', 'KILOGRAM', 'TON', 'KWH', 'DAY', 'HOUR', 'MINUTE', 'MONTH', 'LITER', 'KILOMETER', 'CUBIC_METER', 'METER', 'LINEAR_METER', 'CARTON', 'PACK', 'OWN']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on UnitOfMeasureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on UnitOfMeasureType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on UnitOfMeasureType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.lineNumber is not None or
            self.lineModificationReference is not None or
            self.referencesToOtherLines is not None or
            self.advanceData is not None or
            self.productCodes is not None or
            self.lineExpressionIndicator is not None or
            self.lineNatureIndicator is not None or
            self.lineDescription is not None or
            self.quantity is not None or
            self.unitOfMeasure is not None or
            self.unitOfMeasureOwn is not None or
            self.unitPrice is not None or
            self.unitPriceHUF is not None or
            self.lineDiscountData is not None or
            self.lineAmountsNormal is not None or
            self.lineAmountsSimplified is not None or
            self.intermediatedService is not None or
            self.aggregateInvoiceLineData is not None or
            self.newTransportMean is not None or
            self.depositIndicator is not None or
            self.obligatedForProductFee is not None or
            self.GPCExcise is not None or
            self.dieselOilPurchase is not None or
            self.netaDeclaration is not None or
            self.productFeeClause is not None or
            self.lineProductFeeContent or
            self.conventionalLineInfo is not None or
            self.additionalLineData
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='LineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='LineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lineNumber is not None:
            namespaceprefix_ = self.lineNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.lineNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineNumber>%s</%slineNumber>%s' % (namespaceprefix_ , self.gds_format_integer(self.lineNumber, input_name='lineNumber'), namespaceprefix_ , eol_))
        if self.lineModificationReference is not None:
            namespaceprefix_ = self.lineModificationReference_nsprefix_ + ':' if (UseCapturedNS_ and self.lineModificationReference_nsprefix_) else ''
            self.lineModificationReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lineModificationReference', pretty_print=pretty_print)
        if self.referencesToOtherLines is not None:
            namespaceprefix_ = self.referencesToOtherLines_nsprefix_ + ':' if (UseCapturedNS_ and self.referencesToOtherLines_nsprefix_) else ''
            self.referencesToOtherLines.export(outfile, level, namespaceprefix_, namespacedef_='', name_='referencesToOtherLines', pretty_print=pretty_print)
        if self.advanceData is not None:
            namespaceprefix_ = self.advanceData_nsprefix_ + ':' if (UseCapturedNS_ and self.advanceData_nsprefix_) else ''
            self.advanceData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='advanceData', pretty_print=pretty_print)
        if self.productCodes is not None:
            namespaceprefix_ = self.productCodes_nsprefix_ + ':' if (UseCapturedNS_ and self.productCodes_nsprefix_) else ''
            self.productCodes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='productCodes', pretty_print=pretty_print)
        if self.lineExpressionIndicator is not None:
            namespaceprefix_ = self.lineExpressionIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.lineExpressionIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineExpressionIndicator>%s</%slineExpressionIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.lineExpressionIndicator, input_name='lineExpressionIndicator'), namespaceprefix_ , eol_))
        if self.lineNatureIndicator is not None:
            namespaceprefix_ = self.lineNatureIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.lineNatureIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineNatureIndicator>%s</%slineNatureIndicator>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.lineNatureIndicator), input_name='lineNatureIndicator')), namespaceprefix_ , eol_))
        if self.lineDescription is not None:
            namespaceprefix_ = self.lineDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.lineDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineDescription>%s</%slineDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.lineDescription), input_name='lineDescription')), namespaceprefix_ , eol_))
        if self.quantity is not None:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantity>%s</%squantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.quantity, input_name='quantity'), namespaceprefix_ , eol_))
        if self.unitOfMeasure is not None:
            namespaceprefix_ = self.unitOfMeasure_nsprefix_ + ':' if (UseCapturedNS_ and self.unitOfMeasure_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunitOfMeasure>%s</%sunitOfMeasure>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.unitOfMeasure), input_name='unitOfMeasure')), namespaceprefix_ , eol_))
        if self.unitOfMeasureOwn is not None:
            namespaceprefix_ = self.unitOfMeasureOwn_nsprefix_ + ':' if (UseCapturedNS_ and self.unitOfMeasureOwn_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunitOfMeasureOwn>%s</%sunitOfMeasureOwn>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.unitOfMeasureOwn), input_name='unitOfMeasureOwn')), namespaceprefix_ , eol_))
        if self.unitPrice is not None:
            namespaceprefix_ = self.unitPrice_nsprefix_ + ':' if (UseCapturedNS_ and self.unitPrice_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunitPrice>%s</%sunitPrice>%s' % (namespaceprefix_ , self.gds_format_decimal(self.unitPrice, input_name='unitPrice'), namespaceprefix_ , eol_))
        if self.unitPriceHUF is not None:
            namespaceprefix_ = self.unitPriceHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.unitPriceHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunitPriceHUF>%s</%sunitPriceHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.unitPriceHUF, input_name='unitPriceHUF'), namespaceprefix_ , eol_))
        if self.lineDiscountData is not None:
            namespaceprefix_ = self.lineDiscountData_nsprefix_ + ':' if (UseCapturedNS_ and self.lineDiscountData_nsprefix_) else ''
            self.lineDiscountData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lineDiscountData', pretty_print=pretty_print)
        if self.lineAmountsNormal is not None:
            namespaceprefix_ = self.lineAmountsNormal_nsprefix_ + ':' if (UseCapturedNS_ and self.lineAmountsNormal_nsprefix_) else ''
            self.lineAmountsNormal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lineAmountsNormal', pretty_print=pretty_print)
        if self.lineAmountsSimplified is not None:
            namespaceprefix_ = self.lineAmountsSimplified_nsprefix_ + ':' if (UseCapturedNS_ and self.lineAmountsSimplified_nsprefix_) else ''
            self.lineAmountsSimplified.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lineAmountsSimplified', pretty_print=pretty_print)
        if self.intermediatedService is not None:
            namespaceprefix_ = self.intermediatedService_nsprefix_ + ':' if (UseCapturedNS_ and self.intermediatedService_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintermediatedService>%s</%sintermediatedService>%s' % (namespaceprefix_ , self.gds_format_boolean(self.intermediatedService, input_name='intermediatedService'), namespaceprefix_ , eol_))
        if self.aggregateInvoiceLineData is not None:
            namespaceprefix_ = self.aggregateInvoiceLineData_nsprefix_ + ':' if (UseCapturedNS_ and self.aggregateInvoiceLineData_nsprefix_) else ''
            self.aggregateInvoiceLineData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='aggregateInvoiceLineData', pretty_print=pretty_print)
        if self.newTransportMean is not None:
            namespaceprefix_ = self.newTransportMean_nsprefix_ + ':' if (UseCapturedNS_ and self.newTransportMean_nsprefix_) else ''
            self.newTransportMean.export(outfile, level, namespaceprefix_, namespacedef_='', name_='newTransportMean', pretty_print=pretty_print)
        if self.depositIndicator is not None:
            namespaceprefix_ = self.depositIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.depositIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepositIndicator>%s</%sdepositIndicator>%s' % (namespaceprefix_ , self.gds_format_boolean(self.depositIndicator, input_name='depositIndicator'), namespaceprefix_ , eol_))
        if self.obligatedForProductFee is not None:
            namespaceprefix_ = self.obligatedForProductFee_nsprefix_ + ':' if (UseCapturedNS_ and self.obligatedForProductFee_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobligatedForProductFee>%s</%sobligatedForProductFee>%s' % (namespaceprefix_ , self.gds_format_boolean(self.obligatedForProductFee, input_name='obligatedForProductFee'), namespaceprefix_ , eol_))
        if self.GPCExcise is not None:
            namespaceprefix_ = self.GPCExcise_nsprefix_ + ':' if (UseCapturedNS_ and self.GPCExcise_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGPCExcise>%s</%sGPCExcise>%s' % (namespaceprefix_ , self.gds_format_decimal(self.GPCExcise, input_name='GPCExcise'), namespaceprefix_ , eol_))
        if self.dieselOilPurchase is not None:
            namespaceprefix_ = self.dieselOilPurchase_nsprefix_ + ':' if (UseCapturedNS_ and self.dieselOilPurchase_nsprefix_) else ''
            self.dieselOilPurchase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dieselOilPurchase', pretty_print=pretty_print)
        if self.netaDeclaration is not None:
            namespaceprefix_ = self.netaDeclaration_nsprefix_ + ':' if (UseCapturedNS_ and self.netaDeclaration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetaDeclaration>%s</%snetaDeclaration>%s' % (namespaceprefix_ , self.gds_format_boolean(self.netaDeclaration, input_name='netaDeclaration'), namespaceprefix_ , eol_))
        if self.productFeeClause is not None:
            namespaceprefix_ = self.productFeeClause_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeClause_nsprefix_) else ''
            self.productFeeClause.export(outfile, level, namespaceprefix_, namespacedef_='', name_='productFeeClause', pretty_print=pretty_print)
        for lineProductFeeContent_ in self.lineProductFeeContent:
            namespaceprefix_ = self.lineProductFeeContent_nsprefix_ + ':' if (UseCapturedNS_ and self.lineProductFeeContent_nsprefix_) else ''
            lineProductFeeContent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lineProductFeeContent', pretty_print=pretty_print)
        if self.conventionalLineInfo is not None:
            namespaceprefix_ = self.conventionalLineInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.conventionalLineInfo_nsprefix_) else ''
            self.conventionalLineInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='conventionalLineInfo', pretty_print=pretty_print)
        for additionalLineData_ in self.additionalLineData:
            namespaceprefix_ = self.additionalLineData_nsprefix_ + ':' if (UseCapturedNS_ and self.additionalLineData_nsprefix_) else ''
            additionalLineData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='additionalLineData', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='LineType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.lineNumber is not None:
            lineNumber_ = self.lineNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineNumber').text = self.gds_format_integer(lineNumber_)
        if self.lineModificationReference is not None:
            lineModificationReference_ = self.lineModificationReference
            lineModificationReference_.to_etree(element, name_='lineModificationReference', mapping_=mapping_, nsmap_=nsmap_)
        if self.referencesToOtherLines is not None:
            referencesToOtherLines_ = self.referencesToOtherLines
            referencesToOtherLines_.to_etree(element, name_='referencesToOtherLines', mapping_=mapping_, nsmap_=nsmap_)
        if self.advanceData is not None:
            advanceData_ = self.advanceData
            advanceData_.to_etree(element, name_='advanceData', mapping_=mapping_, nsmap_=nsmap_)
        if self.productCodes is not None:
            productCodes_ = self.productCodes
            productCodes_.to_etree(element, name_='productCodes', mapping_=mapping_, nsmap_=nsmap_)
        if self.lineExpressionIndicator is not None:
            lineExpressionIndicator_ = self.lineExpressionIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineExpressionIndicator').text = self.gds_format_boolean(lineExpressionIndicator_)
        if self.lineNatureIndicator is not None:
            lineNatureIndicator_ = self.lineNatureIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineNatureIndicator').text = self.gds_format_string(lineNatureIndicator_)
        if self.lineDescription is not None:
            lineDescription_ = self.lineDescription
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineDescription').text = self.gds_format_string(lineDescription_)
        if self.quantity is not None:
            quantity_ = self.quantity
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}quantity').text = self.gds_format_decimal(quantity_)
        if self.unitOfMeasure is not None:
            unitOfMeasure_ = self.unitOfMeasure
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}unitOfMeasure').text = self.gds_format_string(unitOfMeasure_)
        if self.unitOfMeasureOwn is not None:
            unitOfMeasureOwn_ = self.unitOfMeasureOwn
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}unitOfMeasureOwn').text = self.gds_format_string(unitOfMeasureOwn_)
        if self.unitPrice is not None:
            unitPrice_ = self.unitPrice
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}unitPrice').text = self.gds_format_decimal(unitPrice_)
        if self.unitPriceHUF is not None:
            unitPriceHUF_ = self.unitPriceHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}unitPriceHUF').text = self.gds_format_decimal(unitPriceHUF_)
        if self.lineDiscountData is not None:
            lineDiscountData_ = self.lineDiscountData
            lineDiscountData_.to_etree(element, name_='lineDiscountData', mapping_=mapping_, nsmap_=nsmap_)
        if self.lineAmountsNormal is not None:
            lineAmountsNormal_ = self.lineAmountsNormal
            lineAmountsNormal_.to_etree(element, name_='lineAmountsNormal', mapping_=mapping_, nsmap_=nsmap_)
        if self.lineAmountsSimplified is not None:
            lineAmountsSimplified_ = self.lineAmountsSimplified
            lineAmountsSimplified_.to_etree(element, name_='lineAmountsSimplified', mapping_=mapping_, nsmap_=nsmap_)
        if self.intermediatedService is not None:
            intermediatedService_ = self.intermediatedService
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}intermediatedService').text = self.gds_format_boolean(intermediatedService_)
        if self.aggregateInvoiceLineData is not None:
            aggregateInvoiceLineData_ = self.aggregateInvoiceLineData
            aggregateInvoiceLineData_.to_etree(element, name_='aggregateInvoiceLineData', mapping_=mapping_, nsmap_=nsmap_)
        if self.newTransportMean is not None:
            newTransportMean_ = self.newTransportMean
            newTransportMean_.to_etree(element, name_='newTransportMean', mapping_=mapping_, nsmap_=nsmap_)
        if self.depositIndicator is not None:
            depositIndicator_ = self.depositIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}depositIndicator').text = self.gds_format_boolean(depositIndicator_)
        if self.obligatedForProductFee is not None:
            obligatedForProductFee_ = self.obligatedForProductFee
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}obligatedForProductFee').text = self.gds_format_boolean(obligatedForProductFee_)
        if self.GPCExcise is not None:
            GPCExcise_ = self.GPCExcise
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}GPCExcise').text = self.gds_format_decimal(GPCExcise_)
        if self.dieselOilPurchase is not None:
            dieselOilPurchase_ = self.dieselOilPurchase
            dieselOilPurchase_.to_etree(element, name_='dieselOilPurchase', mapping_=mapping_, nsmap_=nsmap_)
        if self.netaDeclaration is not None:
            netaDeclaration_ = self.netaDeclaration
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}netaDeclaration').text = self.gds_format_boolean(netaDeclaration_)
        if self.productFeeClause is not None:
            productFeeClause_ = self.productFeeClause
            productFeeClause_.to_etree(element, name_='productFeeClause', mapping_=mapping_, nsmap_=nsmap_)
        for lineProductFeeContent_ in self.lineProductFeeContent:
            lineProductFeeContent_.to_etree(element, name_='lineProductFeeContent', mapping_=mapping_, nsmap_=nsmap_)
        if self.conventionalLineInfo is not None:
            conventionalLineInfo_ = self.conventionalLineInfo
            conventionalLineInfo_.to_etree(element, name_='conventionalLineInfo', mapping_=mapping_, nsmap_=nsmap_)
        for additionalLineData_ in self.additionalLineData:
            additionalLineData_.to_etree(element, name_='additionalLineData', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='LineType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.lineNumber is not None:
            showIndent(outfile, level)
            outfile.write('lineNumber=%d,\n' % self.lineNumber)
        if self.lineModificationReference is not None:
            showIndent(outfile, level)
            outfile.write('lineModificationReference=model_.LineModificationReferenceType(\n')
            self.lineModificationReference.exportLiteral(outfile, level, name_='lineModificationReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.referencesToOtherLines is not None:
            showIndent(outfile, level)
            outfile.write('referencesToOtherLines=model_.ReferencesToOtherLinesType(\n')
            self.referencesToOtherLines.exportLiteral(outfile, level, name_='referencesToOtherLines')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.advanceData is not None:
            showIndent(outfile, level)
            outfile.write('advanceData=model_.AdvanceDataType(\n')
            self.advanceData.exportLiteral(outfile, level, name_='advanceData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.productCodes is not None:
            showIndent(outfile, level)
            outfile.write('productCodes=model_.ProductCodesType(\n')
            self.productCodes.exportLiteral(outfile, level, name_='productCodes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lineExpressionIndicator is not None:
            showIndent(outfile, level)
            outfile.write('lineExpressionIndicator=%s,\n' % self.lineExpressionIndicator)
        if self.lineNatureIndicator is not None:
            showIndent(outfile, level)
            outfile.write('lineNatureIndicator=%s,\n' % self.gds_encode(quote_python(self.lineNatureIndicator)))
        if self.lineDescription is not None:
            showIndent(outfile, level)
            outfile.write('lineDescription=%s,\n' % self.gds_encode(quote_python(self.lineDescription)))
        if self.quantity is not None:
            showIndent(outfile, level)
            outfile.write('quantity=%f,\n' % self.quantity)
        if self.unitOfMeasure is not None:
            showIndent(outfile, level)
            outfile.write('unitOfMeasure=%s,\n' % self.gds_encode(quote_python(self.unitOfMeasure)))
        if self.unitOfMeasureOwn is not None:
            showIndent(outfile, level)
            outfile.write('unitOfMeasureOwn=%s,\n' % self.gds_encode(quote_python(self.unitOfMeasureOwn)))
        if self.unitPrice is not None:
            showIndent(outfile, level)
            outfile.write('unitPrice=%f,\n' % self.unitPrice)
        if self.unitPriceHUF is not None:
            showIndent(outfile, level)
            outfile.write('unitPriceHUF=%f,\n' % self.unitPriceHUF)
        if self.lineDiscountData is not None:
            showIndent(outfile, level)
            outfile.write('lineDiscountData=model_.DiscountDataType(\n')
            self.lineDiscountData.exportLiteral(outfile, level, name_='lineDiscountData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lineAmountsNormal is not None:
            showIndent(outfile, level)
            outfile.write('lineAmountsNormal=model_.LineAmountsNormalType(\n')
            self.lineAmountsNormal.exportLiteral(outfile, level, name_='lineAmountsNormal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lineAmountsSimplified is not None:
            showIndent(outfile, level)
            outfile.write('lineAmountsSimplified=model_.LineAmountsSimplifiedType(\n')
            self.lineAmountsSimplified.exportLiteral(outfile, level, name_='lineAmountsSimplified')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.intermediatedService is not None:
            showIndent(outfile, level)
            outfile.write('intermediatedService=%s,\n' % self.intermediatedService)
        if self.aggregateInvoiceLineData is not None:
            showIndent(outfile, level)
            outfile.write('aggregateInvoiceLineData=model_.AggregateInvoiceLineDataType(\n')
            self.aggregateInvoiceLineData.exportLiteral(outfile, level, name_='aggregateInvoiceLineData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.newTransportMean is not None:
            showIndent(outfile, level)
            outfile.write('newTransportMean=model_.NewTransportMeanType(\n')
            self.newTransportMean.exportLiteral(outfile, level, name_='newTransportMean')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.depositIndicator is not None:
            showIndent(outfile, level)
            outfile.write('depositIndicator=%s,\n' % self.depositIndicator)
        if self.obligatedForProductFee is not None:
            showIndent(outfile, level)
            outfile.write('obligatedForProductFee=%s,\n' % self.obligatedForProductFee)
        if self.GPCExcise is not None:
            showIndent(outfile, level)
            outfile.write('GPCExcise=%f,\n' % self.GPCExcise)
        if self.dieselOilPurchase is not None:
            showIndent(outfile, level)
            outfile.write('dieselOilPurchase=model_.DieselOilPurchaseType(\n')
            self.dieselOilPurchase.exportLiteral(outfile, level, name_='dieselOilPurchase')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.netaDeclaration is not None:
            showIndent(outfile, level)
            outfile.write('netaDeclaration=%s,\n' % self.netaDeclaration)
        if self.productFeeClause is not None:
            showIndent(outfile, level)
            outfile.write('productFeeClause=model_.ProductFeeClauseType(\n')
            self.productFeeClause.exportLiteral(outfile, level, name_='productFeeClause')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('lineProductFeeContent=[\n')
        level += 1
        for lineProductFeeContent_ in self.lineProductFeeContent:
            showIndent(outfile, level)
            outfile.write('model_.ProductFeeDataType(\n')
            lineProductFeeContent_.exportLiteral(outfile, level, name_='ProductFeeDataType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.conventionalLineInfo is not None:
            showIndent(outfile, level)
            outfile.write('conventionalLineInfo=model_.ConventionalInvoiceInfoType(\n')
            self.conventionalLineInfo.exportLiteral(outfile, level, name_='conventionalLineInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('additionalLineData=[\n')
        level += 1
        for additionalLineData_ in self.additionalLineData:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalDataType(\n')
            additionalLineData_.exportLiteral(outfile, level, name_='AdditionalDataType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lineNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lineNumber')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'lineNumber')
            self.lineNumber = ival_
            self.lineNumber_nsprefix_ = child_.prefix
            # validate type LineNumberType
            self.validate_LineNumberType(self.lineNumber)
        elif nodeName_ == 'lineModificationReference':
            obj_ = LineModificationReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lineModificationReference = obj_
            obj_.original_tagname_ = 'lineModificationReference'
        elif nodeName_ == 'referencesToOtherLines':
            obj_ = ReferencesToOtherLinesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.referencesToOtherLines = obj_
            obj_.original_tagname_ = 'referencesToOtherLines'
        elif nodeName_ == 'advanceData':
            obj_ = AdvanceDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.advanceData = obj_
            obj_.original_tagname_ = 'advanceData'
        elif nodeName_ == 'productCodes':
            obj_ = ProductCodesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productCodes = obj_
            obj_.original_tagname_ = 'productCodes'
        elif nodeName_ == 'lineExpressionIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'lineExpressionIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'lineExpressionIndicator')
            self.lineExpressionIndicator = ival_
            self.lineExpressionIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'lineNatureIndicator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lineNatureIndicator')
            value_ = self.gds_validate_string(value_, node, 'lineNatureIndicator')
            self.lineNatureIndicator = value_
            self.lineNatureIndicator_nsprefix_ = child_.prefix
            # validate type LineNatureIndicatorType
            self.validate_LineNatureIndicatorType(self.lineNatureIndicator)
        elif nodeName_ == 'lineDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lineDescription')
            value_ = self.gds_validate_string(value_, node, 'lineDescription')
            self.lineDescription = value_
            self.lineDescription_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.lineDescription)
        elif nodeName_ == 'quantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'quantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'quantity')
            self.quantity = fval_
            self.quantity_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.quantity)
        elif nodeName_ == 'unitOfMeasure':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'unitOfMeasure')
            value_ = self.gds_validate_string(value_, node, 'unitOfMeasure')
            self.unitOfMeasure = value_
            self.unitOfMeasure_nsprefix_ = child_.prefix
            # validate type UnitOfMeasureType
            self.validate_UnitOfMeasureType(self.unitOfMeasure)
        elif nodeName_ == 'unitOfMeasureOwn':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'unitOfMeasureOwn')
            value_ = self.gds_validate_string(value_, node, 'unitOfMeasureOwn')
            self.unitOfMeasureOwn = value_
            self.unitOfMeasureOwn_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.unitOfMeasureOwn)
        elif nodeName_ == 'unitPrice' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'unitPrice')
            fval_ = self.gds_validate_decimal(fval_, node, 'unitPrice')
            self.unitPrice = fval_
            self.unitPrice_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.unitPrice)
        elif nodeName_ == 'unitPriceHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'unitPriceHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'unitPriceHUF')
            self.unitPriceHUF = fval_
            self.unitPriceHUF_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.unitPriceHUF)
        elif nodeName_ == 'lineDiscountData':
            obj_ = DiscountDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lineDiscountData = obj_
            obj_.original_tagname_ = 'lineDiscountData'
        elif nodeName_ == 'lineAmountsNormal':
            obj_ = LineAmountsNormalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lineAmountsNormal = obj_
            obj_.original_tagname_ = 'lineAmountsNormal'
        elif nodeName_ == 'lineAmountsSimplified':
            obj_ = LineAmountsSimplifiedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lineAmountsSimplified = obj_
            obj_.original_tagname_ = 'lineAmountsSimplified'
        elif nodeName_ == 'intermediatedService':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'intermediatedService')
            ival_ = self.gds_validate_boolean(ival_, node, 'intermediatedService')
            self.intermediatedService = ival_
            self.intermediatedService_nsprefix_ = child_.prefix
        elif nodeName_ == 'aggregateInvoiceLineData':
            obj_ = AggregateInvoiceLineDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.aggregateInvoiceLineData = obj_
            obj_.original_tagname_ = 'aggregateInvoiceLineData'
        elif nodeName_ == 'newTransportMean':
            obj_ = NewTransportMeanType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.newTransportMean = obj_
            obj_.original_tagname_ = 'newTransportMean'
        elif nodeName_ == 'depositIndicator':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'depositIndicator')
            ival_ = self.gds_validate_boolean(ival_, node, 'depositIndicator')
            self.depositIndicator = ival_
            self.depositIndicator_nsprefix_ = child_.prefix
        elif nodeName_ == 'obligatedForProductFee':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'obligatedForProductFee')
            ival_ = self.gds_validate_boolean(ival_, node, 'obligatedForProductFee')
            self.obligatedForProductFee = ival_
            self.obligatedForProductFee_nsprefix_ = child_.prefix
        elif nodeName_ == 'GPCExcise' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'GPCExcise')
            fval_ = self.gds_validate_decimal(fval_, node, 'GPCExcise')
            self.GPCExcise = fval_
            self.GPCExcise_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.GPCExcise)
        elif nodeName_ == 'dieselOilPurchase':
            obj_ = DieselOilPurchaseType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dieselOilPurchase = obj_
            obj_.original_tagname_ = 'dieselOilPurchase'
        elif nodeName_ == 'netaDeclaration':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'netaDeclaration')
            ival_ = self.gds_validate_boolean(ival_, node, 'netaDeclaration')
            self.netaDeclaration = ival_
            self.netaDeclaration_nsprefix_ = child_.prefix
        elif nodeName_ == 'productFeeClause':
            obj_ = ProductFeeClauseType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productFeeClause = obj_
            obj_.original_tagname_ = 'productFeeClause'
        elif nodeName_ == 'lineProductFeeContent':
            obj_ = ProductFeeDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lineProductFeeContent.append(obj_)
            obj_.original_tagname_ = 'lineProductFeeContent'
        elif nodeName_ == 'conventionalLineInfo':
            obj_ = ConventionalInvoiceInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.conventionalLineInfo = obj_
            obj_.original_tagname_ = 'conventionalLineInfo'
        elif nodeName_ == 'additionalLineData':
            obj_ = AdditionalDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.additionalLineData.append(obj_)
            obj_.original_tagname_ = 'additionalLineData'
# end class LineType


class LineVatDataType(GeneratedsSuper):
    """LineVatDataType -- T
    é
    tel
    Á
    FA adatok
    Line VAT data
    lineVatAmount -- T
    é
    tel
    Á
    FA
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben
    VAT amount of the item expressed in the currency of the invoice
    lineVatAmountHUF -- T
    é
    tel
    Á
    FA
    ö
    sszege forintban
    VAT amount of the item expressed in HUF

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lineVatAmount=None, lineVatAmountHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lineVatAmount = lineVatAmount
        self.validate_MonetaryType(self.lineVatAmount)
        self.lineVatAmount_nsprefix_ = "base"
        self.lineVatAmountHUF = lineVatAmountHUF
        self.validate_MonetaryType(self.lineVatAmountHUF)
        self.lineVatAmountHUF_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineVatDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineVatDataType.subclass:
            return LineVatDataType.subclass(*args_, **kwargs_)
        else:
            return LineVatDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lineVatAmount(self):
        return self.lineVatAmount
    def set_lineVatAmount(self, lineVatAmount):
        self.lineVatAmount = lineVatAmount
    def get_lineVatAmountHUF(self):
        return self.lineVatAmountHUF
    def set_lineVatAmountHUF(self, lineVatAmountHUF):
        self.lineVatAmountHUF = lineVatAmountHUF
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.lineVatAmount is not None or
            self.lineVatAmountHUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='LineVatDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineVatDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineVatDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineVatDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineVatDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineVatDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='LineVatDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lineVatAmount is not None:
            namespaceprefix_ = self.lineVatAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.lineVatAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineVatAmount>%s</%slineVatAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.lineVatAmount, input_name='lineVatAmount'), namespaceprefix_ , eol_))
        if self.lineVatAmountHUF is not None:
            namespaceprefix_ = self.lineVatAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.lineVatAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slineVatAmountHUF>%s</%slineVatAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.lineVatAmountHUF, input_name='lineVatAmountHUF'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='LineVatDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.lineVatAmount is not None:
            lineVatAmount_ = self.lineVatAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineVatAmount').text = self.gds_format_decimal(lineVatAmount_)
        if self.lineVatAmountHUF is not None:
            lineVatAmountHUF_ = self.lineVatAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}lineVatAmountHUF').text = self.gds_format_decimal(lineVatAmountHUF_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='LineVatDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.lineVatAmount is not None:
            showIndent(outfile, level)
            outfile.write('lineVatAmount=%f,\n' % self.lineVatAmount)
        if self.lineVatAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('lineVatAmountHUF=%f,\n' % self.lineVatAmountHUF)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lineVatAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'lineVatAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'lineVatAmount')
            self.lineVatAmount = fval_
            self.lineVatAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.lineVatAmount)
        elif nodeName_ == 'lineVatAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'lineVatAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'lineVatAmountHUF')
            self.lineVatAmountHUF = fval_
            self.lineVatAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.lineVatAmountHUF)
# end class LineVatDataType


class MaterialNumbersType(GeneratedsSuper):
    """MaterialNumbersType -- Anyagsz
    á
    mok
    Material numbers
    materialNumber -- Anyagsz
    á
    m
    Material number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, materialNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if materialNumber is None:
            self.materialNumber = []
        else:
            self.materialNumber = materialNumber
        self.materialNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaterialNumbersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaterialNumbersType.subclass:
            return MaterialNumbersType.subclass(*args_, **kwargs_)
        else:
            return MaterialNumbersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_materialNumber(self):
        return self.materialNumber
    def set_materialNumber(self, materialNumber):
        self.materialNumber = materialNumber
    def add_materialNumber(self, value):
        self.materialNumber.append(value)
    def insert_materialNumber_at(self, index, value):
        self.materialNumber.insert(index, value)
    def replace_materialNumber_at(self, index, value):
        self.materialNumber[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.materialNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='MaterialNumbersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MaterialNumbersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MaterialNumbersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MaterialNumbersType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MaterialNumbersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MaterialNumbersType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='MaterialNumbersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for materialNumber_ in self.materialNumber:
            namespaceprefix_ = self.materialNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.materialNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaterialNumber>%s</%smaterialNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(materialNumber_), input_name='materialNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='MaterialNumbersType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for materialNumber_ in self.materialNumber:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}materialNumber').text = self.gds_format_string(materialNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MaterialNumbersType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('materialNumber=[\n')
        level += 1
        for materialNumber_ in self.materialNumber:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(materialNumber_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'materialNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'materialNumber')
            value_ = self.gds_validate_string(value_, node, 'materialNumber')
            self.materialNumber.append(value_)
            self.materialNumber_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.materialNumber[-1])
# end class MaterialNumbersType


class NewTransportMeanType(GeneratedsSuper):
    """NewTransportMeanType -- Ú
    j k
    ö
    zleked
    é
    si eszk
    ö
    z
    é
    rt
    é
    kes
    í
    t
    é
    s
    Á
    FA tv. 89
    §
    ill. 169
    §
    o)
    Supply of new means of transport - section 89
    §
    and 169 (o) of the VAT law
    brand -- Gy
    á
    rtm
    á
    ny/t
    í
    pus
    Product / type
    serialNum -- Alv
    á
    zsz
    á
    m/gy
    á
    ri sz
    á
    m/Gy
    á
    rt
    á
    si sz
    á
    m
    Chassis number / serial number / product number
    engineNum -- Motorsz
    á
    m
    Engine number
    firstEntryIntoService -- Els
    ő
    forgalomba helyez
    é
    s id
    ő
    pontja
    First entry into service
    vehicle -- Sz
    á
    razf
    ö
    ldi k
    ö
    zleked
    é
    si eszk
    ö
    z tov
    á
    bbi adatai
    Other data in relation to motorised land vehicle
    vessel -- V
    í
    zi j
    á
    rm
    ű
    adatai
    Data of vessel
    aircraft -- L
    é
    gi k
    ö
    zleked
    é
    si eszk
    ö
    z
    Aircraft

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, brand=None, serialNum=None, engineNum=None, firstEntryIntoService=None, vehicle=None, vessel=None, aircraft=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.brand = brand
        self.validate_SimpleText50NotBlankType(self.brand)
        self.brand_nsprefix_ = "common"
        self.serialNum = serialNum
        self.validate_SimpleText255NotBlankType(self.serialNum)
        self.serialNum_nsprefix_ = "common"
        self.engineNum = engineNum
        self.validate_SimpleText255NotBlankType(self.engineNum)
        self.engineNum_nsprefix_ = "common"
        if isinstance(firstEntryIntoService, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(firstEntryIntoService, '%Y-%m-%d').date()
        else:
            initvalue_ = firstEntryIntoService
        self.firstEntryIntoService = initvalue_
        self.firstEntryIntoService_nsprefix_ = "base"
        self.vehicle = vehicle
        self.vehicle_nsprefix_ = None
        self.vessel = vessel
        self.vessel_nsprefix_ = None
        self.aircraft = aircraft
        self.aircraft_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NewTransportMeanType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NewTransportMeanType.subclass:
            return NewTransportMeanType.subclass(*args_, **kwargs_)
        else:
            return NewTransportMeanType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_brand(self):
        return self.brand
    def set_brand(self, brand):
        self.brand = brand
    def get_serialNum(self):
        return self.serialNum
    def set_serialNum(self, serialNum):
        self.serialNum = serialNum
    def get_engineNum(self):
        return self.engineNum
    def set_engineNum(self, engineNum):
        self.engineNum = engineNum
    def get_firstEntryIntoService(self):
        return self.firstEntryIntoService
    def set_firstEntryIntoService(self, firstEntryIntoService):
        self.firstEntryIntoService = firstEntryIntoService
    def get_vehicle(self):
        return self.vehicle
    def set_vehicle(self, vehicle):
        self.vehicle = vehicle
    def get_vessel(self):
        return self.vessel
    def set_vessel(self, vessel):
        self.vessel = vessel
    def get_aircraft(self):
        return self.aircraft
    def set_aircraft(self, aircraft):
        self.aircraft = aircraft
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_SimpleText255NotBlankType(self, value):
        result = True
        # Validate type SimpleText255NotBlankType, a restriction on AtomicStringType255.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText255NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText255NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText255NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText255NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText255NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceDateType(self, value):
        result = True
        # Validate type InvoiceDateType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.strptime('2010-01-01', '%Y-%m-%d').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceDateType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceDateType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceDateType_patterns_, ))
                result = False
        return result
    validate_InvoiceDateType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2})$']]
    def _hasContent(self):
        if (
            self.brand is not None or
            self.serialNum is not None or
            self.engineNum is not None or
            self.firstEntryIntoService is not None or
            self.vehicle is not None or
            self.vessel is not None or
            self.aircraft is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='NewTransportMeanType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NewTransportMeanType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NewTransportMeanType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NewTransportMeanType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NewTransportMeanType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NewTransportMeanType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='NewTransportMeanType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.brand is not None:
            namespaceprefix_ = self.brand_nsprefix_ + ':' if (UseCapturedNS_ and self.brand_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbrand>%s</%sbrand>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.brand), input_name='brand')), namespaceprefix_ , eol_))
        if self.serialNum is not None:
            namespaceprefix_ = self.serialNum_nsprefix_ + ':' if (UseCapturedNS_ and self.serialNum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserialNum>%s</%sserialNum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serialNum), input_name='serialNum')), namespaceprefix_ , eol_))
        if self.engineNum is not None:
            namespaceprefix_ = self.engineNum_nsprefix_ + ':' if (UseCapturedNS_ and self.engineNum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sengineNum>%s</%sengineNum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.engineNum), input_name='engineNum')), namespaceprefix_ , eol_))
        if self.firstEntryIntoService is not None:
            namespaceprefix_ = self.firstEntryIntoService_nsprefix_ + ':' if (UseCapturedNS_ and self.firstEntryIntoService_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfirstEntryIntoService>%s</%sfirstEntryIntoService>%s' % (namespaceprefix_ , self.gds_format_date(self.firstEntryIntoService, input_name='firstEntryIntoService'), namespaceprefix_ , eol_))
        if self.vehicle is not None:
            namespaceprefix_ = self.vehicle_nsprefix_ + ':' if (UseCapturedNS_ and self.vehicle_nsprefix_) else ''
            self.vehicle.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vehicle', pretty_print=pretty_print)
        if self.vessel is not None:
            namespaceprefix_ = self.vessel_nsprefix_ + ':' if (UseCapturedNS_ and self.vessel_nsprefix_) else ''
            self.vessel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vessel', pretty_print=pretty_print)
        if self.aircraft is not None:
            namespaceprefix_ = self.aircraft_nsprefix_ + ':' if (UseCapturedNS_ and self.aircraft_nsprefix_) else ''
            self.aircraft.export(outfile, level, namespaceprefix_, namespacedef_='', name_='aircraft', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NewTransportMeanType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.brand is not None:
            brand_ = self.brand
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}brand').text = self.gds_format_string(brand_)
        if self.serialNum is not None:
            serialNum_ = self.serialNum
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}serialNum').text = self.gds_format_string(serialNum_)
        if self.engineNum is not None:
            engineNum_ = self.engineNum
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}engineNum').text = self.gds_format_string(engineNum_)
        if self.firstEntryIntoService is not None:
            firstEntryIntoService_ = self.firstEntryIntoService
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}firstEntryIntoService').text = self.gds_format_date(firstEntryIntoService_)
        if self.vehicle is not None:
            vehicle_ = self.vehicle
            vehicle_.to_etree(element, name_='vehicle', mapping_=mapping_, nsmap_=nsmap_)
        if self.vessel is not None:
            vessel_ = self.vessel
            vessel_.to_etree(element, name_='vessel', mapping_=mapping_, nsmap_=nsmap_)
        if self.aircraft is not None:
            aircraft_ = self.aircraft
            aircraft_.to_etree(element, name_='aircraft', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='NewTransportMeanType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.brand is not None:
            showIndent(outfile, level)
            outfile.write('brand=%s,\n' % self.gds_encode(quote_python(self.brand)))
        if self.serialNum is not None:
            showIndent(outfile, level)
            outfile.write('serialNum=%s,\n' % self.gds_encode(quote_python(self.serialNum)))
        if self.engineNum is not None:
            showIndent(outfile, level)
            outfile.write('engineNum=%s,\n' % self.gds_encode(quote_python(self.engineNum)))
        if self.firstEntryIntoService is not None:
            showIndent(outfile, level)
            outfile.write('firstEntryIntoService=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.firstEntryIntoService, input_name='firstEntryIntoService'))
        if self.vehicle is not None:
            showIndent(outfile, level)
            outfile.write('vehicle=model_.VehicleType(\n')
            self.vehicle.exportLiteral(outfile, level, name_='vehicle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vessel is not None:
            showIndent(outfile, level)
            outfile.write('vessel=model_.VesselType(\n')
            self.vessel.exportLiteral(outfile, level, name_='vessel')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.aircraft is not None:
            showIndent(outfile, level)
            outfile.write('aircraft=model_.AircraftType(\n')
            self.aircraft.exportLiteral(outfile, level, name_='aircraft')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'brand':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'brand')
            value_ = self.gds_validate_string(value_, node, 'brand')
            self.brand = value_
            self.brand_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.brand)
        elif nodeName_ == 'serialNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serialNum')
            value_ = self.gds_validate_string(value_, node, 'serialNum')
            self.serialNum = value_
            self.serialNum_nsprefix_ = child_.prefix
            # validate type SimpleText255NotBlankType
            self.validate_SimpleText255NotBlankType(self.serialNum)
        elif nodeName_ == 'engineNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'engineNum')
            value_ = self.gds_validate_string(value_, node, 'engineNum')
            self.engineNum = value_
            self.engineNum_nsprefix_ = child_.prefix
            # validate type SimpleText255NotBlankType
            self.validate_SimpleText255NotBlankType(self.engineNum)
        elif nodeName_ == 'firstEntryIntoService':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.firstEntryIntoService = dval_
            self.firstEntryIntoService_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.firstEntryIntoService)
        elif nodeName_ == 'vehicle':
            obj_ = VehicleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vehicle = obj_
            obj_.original_tagname_ = 'vehicle'
        elif nodeName_ == 'vessel':
            obj_ = VesselType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vessel = obj_
            obj_.original_tagname_ = 'vessel'
        elif nodeName_ == 'aircraft':
            obj_ = AircraftType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.aircraft = obj_
            obj_.original_tagname_ = 'aircraft'
# end class NewTransportMeanType


class OrderNumbersType(GeneratedsSuper):
    """OrderNumbersType -- Megrendel
    é
    ssz
    á
    mok
    Order numbers
    orderNumber -- Megrendel
    é
    ssz
    á
    m
    Order number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, orderNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if orderNumber is None:
            self.orderNumber = []
        else:
            self.orderNumber = orderNumber
        self.orderNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrderNumbersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrderNumbersType.subclass:
            return OrderNumbersType.subclass(*args_, **kwargs_)
        else:
            return OrderNumbersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_orderNumber(self):
        return self.orderNumber
    def set_orderNumber(self, orderNumber):
        self.orderNumber = orderNumber
    def add_orderNumber(self, value):
        self.orderNumber.append(value)
    def insert_orderNumber_at(self, index, value):
        self.orderNumber.insert(index, value)
    def replace_orderNumber_at(self, index, value):
        self.orderNumber[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.orderNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='OrderNumbersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrderNumbersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrderNumbersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrderNumbersType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrderNumbersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrderNumbersType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='OrderNumbersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for orderNumber_ in self.orderNumber:
            namespaceprefix_ = self.orderNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.orderNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorderNumber>%s</%sorderNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(orderNumber_), input_name='orderNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='OrderNumbersType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for orderNumber_ in self.orderNumber:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}orderNumber').text = self.gds_format_string(orderNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='OrderNumbersType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('orderNumber=[\n')
        level += 1
        for orderNumber_ in self.orderNumber:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(orderNumber_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'orderNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'orderNumber')
            value_ = self.gds_validate_string(value_, node, 'orderNumber')
            self.orderNumber.append(value_)
            self.orderNumber_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.orderNumber[-1])
# end class OrderNumbersType


class PaymentEvidenceDocumentDataType(GeneratedsSuper):
    """PaymentEvidenceDocumentDataType -- A term
    é
    kd
    í
    j bevall
    á
    s
    á
    t igazol
    ó
    dokumentum adatai a 2011.
    é
    vi LXXXV. tv. 13.
    §
    (3) szerint
    é
    s a 25.
    §
    (3) szerint
    Data of the document verifying the declaration submitted on the product fee according to the Paragraph (3), Section 13 and the Paragraph (3) Section 25 of the Act LXXXV of 2011
    evidenceDocumentNo -- Sz
    á
    mla sorsz
    á
    ma vagy egy
    é
    b okirat azonos
    í
    t
    ó
    sz
    á
    ma
    Sequential number of the invoice, or other document considered as such
    evidenceDocumentDate -- Sz
    á
    mla kelte
    Date of issue of the invoice
    obligatedName -- K
    ö
    telezett neve
    Name of obligator
    obligatedAddress -- K
    ö
    telezett c
    í
    me
    Address of obligator
    obligatedTaxNumber -- A k
    ö
    telezett ad
    ó
    sz
    á
    ma
    Tax number of obligated

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, evidenceDocumentNo=None, evidenceDocumentDate=None, obligatedName=None, obligatedAddress=None, obligatedTaxNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.evidenceDocumentNo = evidenceDocumentNo
        self.validate_SimpleText50NotBlankType(self.evidenceDocumentNo)
        self.evidenceDocumentNo_nsprefix_ = "common"
        if isinstance(evidenceDocumentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(evidenceDocumentDate, '%Y-%m-%d').date()
        else:
            initvalue_ = evidenceDocumentDate
        self.evidenceDocumentDate = initvalue_
        self.evidenceDocumentDate_nsprefix_ = "base"
        self.obligatedName = obligatedName
        self.validate_SimpleText255NotBlankType(self.obligatedName)
        self.obligatedName_nsprefix_ = "common"
        self.obligatedAddress = obligatedAddress
        self.obligatedAddress_nsprefix_ = "base"
        self.obligatedTaxNumber = obligatedTaxNumber
        self.obligatedTaxNumber_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentEvidenceDocumentDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentEvidenceDocumentDataType.subclass:
            return PaymentEvidenceDocumentDataType.subclass(*args_, **kwargs_)
        else:
            return PaymentEvidenceDocumentDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_evidenceDocumentNo(self):
        return self.evidenceDocumentNo
    def set_evidenceDocumentNo(self, evidenceDocumentNo):
        self.evidenceDocumentNo = evidenceDocumentNo
    def get_evidenceDocumentDate(self):
        return self.evidenceDocumentDate
    def set_evidenceDocumentDate(self, evidenceDocumentDate):
        self.evidenceDocumentDate = evidenceDocumentDate
    def get_obligatedName(self):
        return self.obligatedName
    def set_obligatedName(self, obligatedName):
        self.obligatedName = obligatedName
    def get_obligatedAddress(self):
        return self.obligatedAddress
    def set_obligatedAddress(self, obligatedAddress):
        self.obligatedAddress = obligatedAddress
    def get_obligatedTaxNumber(self):
        return self.obligatedTaxNumber
    def set_obligatedTaxNumber(self, obligatedTaxNumber):
        self.obligatedTaxNumber = obligatedTaxNumber
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_InvoiceDateType(self, value):
        result = True
        # Validate type InvoiceDateType, a restriction on xs:date.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.strptime('2010-01-01', '%Y-%m-%d').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceDateType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceDateType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceDateType_patterns_, ))
                result = False
        return result
    validate_InvoiceDateType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2})$']]
    def validate_SimpleText255NotBlankType(self, value):
        result = True
        # Validate type SimpleText255NotBlankType, a restriction on AtomicStringType255.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText255NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText255NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText255NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText255NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText255NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.evidenceDocumentNo is not None or
            self.evidenceDocumentDate is not None or
            self.obligatedName is not None or
            self.obligatedAddress is not None or
            self.obligatedTaxNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='PaymentEvidenceDocumentDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaymentEvidenceDocumentDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PaymentEvidenceDocumentDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaymentEvidenceDocumentDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PaymentEvidenceDocumentDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PaymentEvidenceDocumentDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='PaymentEvidenceDocumentDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.evidenceDocumentNo is not None:
            namespaceprefix_ = self.evidenceDocumentNo_nsprefix_ + ':' if (UseCapturedNS_ and self.evidenceDocumentNo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sevidenceDocumentNo>%s</%sevidenceDocumentNo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.evidenceDocumentNo), input_name='evidenceDocumentNo')), namespaceprefix_ , eol_))
        if self.evidenceDocumentDate is not None:
            namespaceprefix_ = self.evidenceDocumentDate_nsprefix_ + ':' if (UseCapturedNS_ and self.evidenceDocumentDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sevidenceDocumentDate>%s</%sevidenceDocumentDate>%s' % (namespaceprefix_ , self.gds_format_date(self.evidenceDocumentDate, input_name='evidenceDocumentDate'), namespaceprefix_ , eol_))
        if self.obligatedName is not None:
            namespaceprefix_ = self.obligatedName_nsprefix_ + ':' if (UseCapturedNS_ and self.obligatedName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobligatedName>%s</%sobligatedName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.obligatedName), input_name='obligatedName')), namespaceprefix_ , eol_))
        if self.obligatedAddress is not None:
            namespaceprefix_ = self.obligatedAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.obligatedAddress_nsprefix_) else ''
            self.obligatedAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='obligatedAddress', pretty_print=pretty_print)
        if self.obligatedTaxNumber is not None:
            namespaceprefix_ = self.obligatedTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.obligatedTaxNumber_nsprefix_) else ''
            self.obligatedTaxNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='obligatedTaxNumber', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PaymentEvidenceDocumentDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.evidenceDocumentNo is not None:
            evidenceDocumentNo_ = self.evidenceDocumentNo
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}evidenceDocumentNo').text = self.gds_format_string(evidenceDocumentNo_)
        if self.evidenceDocumentDate is not None:
            evidenceDocumentDate_ = self.evidenceDocumentDate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}evidenceDocumentDate').text = self.gds_format_date(evidenceDocumentDate_)
        if self.obligatedName is not None:
            obligatedName_ = self.obligatedName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}obligatedName').text = self.gds_format_string(obligatedName_)
        if self.obligatedAddress is not None:
            obligatedAddress_ = self.obligatedAddress
            obligatedAddress_.to_etree(element, name_='obligatedAddress', mapping_=mapping_, nsmap_=nsmap_)
        if self.obligatedTaxNumber is not None:
            obligatedTaxNumber_ = self.obligatedTaxNumber
            obligatedTaxNumber_.to_etree(element, name_='obligatedTaxNumber', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='PaymentEvidenceDocumentDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.evidenceDocumentNo is not None:
            showIndent(outfile, level)
            outfile.write('evidenceDocumentNo=%s,\n' % self.gds_encode(quote_python(self.evidenceDocumentNo)))
        if self.evidenceDocumentDate is not None:
            showIndent(outfile, level)
            outfile.write('evidenceDocumentDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.evidenceDocumentDate, input_name='evidenceDocumentDate'))
        if self.obligatedName is not None:
            showIndent(outfile, level)
            outfile.write('obligatedName=%s,\n' % self.gds_encode(quote_python(self.obligatedName)))
        if self.obligatedAddress is not None:
            showIndent(outfile, level)
            outfile.write('obligatedAddress=model_.AddressType(\n')
            self.obligatedAddress.exportLiteral(outfile, level, name_='obligatedAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.obligatedTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('obligatedTaxNumber=model_.TaxNumberType(\n')
            self.obligatedTaxNumber.exportLiteral(outfile, level, name_='obligatedTaxNumber')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'evidenceDocumentNo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'evidenceDocumentNo')
            value_ = self.gds_validate_string(value_, node, 'evidenceDocumentNo')
            self.evidenceDocumentNo = value_
            self.evidenceDocumentNo_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.evidenceDocumentNo)
        elif nodeName_ == 'evidenceDocumentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.evidenceDocumentDate = dval_
            self.evidenceDocumentDate_nsprefix_ = child_.prefix
            # validate type InvoiceDateType
            self.validate_InvoiceDateType(self.evidenceDocumentDate)
        elif nodeName_ == 'obligatedName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'obligatedName')
            value_ = self.gds_validate_string(value_, node, 'obligatedName')
            self.obligatedName = value_
            self.obligatedName_nsprefix_ = child_.prefix
            # validate type SimpleText255NotBlankType
            self.validate_SimpleText255NotBlankType(self.obligatedName)
        elif nodeName_ == 'obligatedAddress':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.obligatedAddress = obj_
            obj_.original_tagname_ = 'obligatedAddress'
        elif nodeName_ == 'obligatedTaxNumber':
            class_obj_ = self.get_class_obj_(child_, TaxNumberType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.obligatedTaxNumber = obj_
            obj_.original_tagname_ = 'obligatedTaxNumber'
# end class PaymentEvidenceDocumentDataType


class ProductCodesType(GeneratedsSuper):
    """ProductCodesType -- Term
    é
    kk
    ó
    dok
    Product codes
    productCode -- Term
    é
    kk
    ó
    d
    Product code

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, productCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if productCode is None:
            self.productCode = []
        else:
            self.productCode = productCode
        self.productCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductCodesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductCodesType.subclass:
            return ProductCodesType.subclass(*args_, **kwargs_)
        else:
            return ProductCodesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_productCode(self):
        return self.productCode
    def set_productCode(self, productCode):
        self.productCode = productCode
    def add_productCode(self, value):
        self.productCode.append(value)
    def insert_productCode_at(self, index, value):
        self.productCode.insert(index, value)
    def replace_productCode_at(self, index, value):
        self.productCode[index] = value
    def _hasContent(self):
        if (
            self.productCode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ProductCodesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProductCodesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProductCodesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProductCodesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProductCodesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProductCodesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ProductCodesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for productCode_ in self.productCode:
            namespaceprefix_ = self.productCode_nsprefix_ + ':' if (UseCapturedNS_ and self.productCode_nsprefix_) else ''
            productCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='productCode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ProductCodesType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for productCode_ in self.productCode:
            productCode_.to_etree(element, name_='productCode', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ProductCodesType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('productCode=[\n')
        level += 1
        for productCode_ in self.productCode:
            showIndent(outfile, level)
            outfile.write('model_.ProductCodeType(\n')
            productCode_.exportLiteral(outfile, level, name_='ProductCodeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'productCode':
            obj_ = ProductCodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productCode.append(obj_)
            obj_.original_tagname_ = 'productCode'
# end class ProductCodesType


class ProductCodeType(GeneratedsSuper):
    """ProductCodeType -- K
    ü
    l
    ö
    nb
    ö
    z
    ő
    term
    é
    k- vagy szolg
    á
    ltat
    á
    sk
    ó
    dokat tartalmaz
    ó
    t
    í
    pus
    Field type including the different product and service codes
    productCodeCategory -- A term
    é
    kk
    ó
    d fajt
    á
    j
    á
    nak (pl. VTSZ, CsK, stb.) jel
    ö
    l
    é
    se
    The kind of product code (f. ex. VTSZ, CsK, etc.)
    productCodeValue -- A term
    é
    kk
    ó
    d
    é
    rt
    é
    ke nem saj
    á
    t term
    é
    kk
    ó
    d eset
    é
    n
    The value of (not own) product code
    productCodeOwnValue -- Saj
    á
    t term
    é
    kk
    ó
    d
    é
    rt
    é
    ke
    Own product code value

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, productCodeCategory=None, productCodeValue=None, productCodeOwnValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.productCodeCategory = productCodeCategory
        self.validate_ProductCodeCategoryType(self.productCodeCategory)
        self.productCodeCategory_nsprefix_ = None
        self.productCodeValue = productCodeValue
        self.validate_ProductCodeValueType(self.productCodeValue)
        self.productCodeValue_nsprefix_ = None
        self.productCodeOwnValue = productCodeOwnValue
        self.validate_SimpleText255NotBlankType(self.productCodeOwnValue)
        self.productCodeOwnValue_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductCodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductCodeType.subclass:
            return ProductCodeType.subclass(*args_, **kwargs_)
        else:
            return ProductCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_productCodeCategory(self):
        return self.productCodeCategory
    def set_productCodeCategory(self, productCodeCategory):
        self.productCodeCategory = productCodeCategory
    def get_productCodeValue(self):
        return self.productCodeValue
    def set_productCodeValue(self, productCodeValue):
        self.productCodeValue = productCodeValue
    def get_productCodeOwnValue(self):
        return self.productCodeOwnValue
    def set_productCodeOwnValue(self, productCodeOwnValue):
        self.productCodeOwnValue = productCodeOwnValue
    def validate_ProductCodeCategoryType(self, value):
        result = True
        # Validate type ProductCodeCategoryType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['VTSZ', 'SZJ', 'KN', 'AHK', 'CSK', 'KT', 'EJ', 'TESZOR', 'OWN', 'OTHER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ProductCodeCategoryType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 6:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ProductCodeCategoryType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ProductCodeCategoryType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ProductCodeCategoryType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ProductCodeCategoryType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_ProductCodeValueType(self, value):
        result = True
        # Validate type ProductCodeValueType, a restriction on common:AtomicStringType32.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ProductCodeValueType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ProductCodeValueType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ProductCodeValueType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ProductCodeValueType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_ProductCodeValueType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ProductCodeValueType_patterns_, ))
                result = False
        return result
    validate_ProductCodeValueType_patterns_ = [['^([A-Z0-9]{2,30})$']]
    def validate_SimpleText255NotBlankType(self, value):
        result = True
        # Validate type SimpleText255NotBlankType, a restriction on AtomicStringType255.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText255NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText255NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText255NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText255NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText255NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.productCodeCategory is not None or
            self.productCodeValue is not None or
            self.productCodeOwnValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='ProductCodeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProductCodeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProductCodeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProductCodeType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProductCodeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProductCodeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='ProductCodeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.productCodeCategory is not None:
            namespaceprefix_ = self.productCodeCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.productCodeCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductCodeCategory>%s</%sproductCodeCategory>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.productCodeCategory), input_name='productCodeCategory')), namespaceprefix_ , eol_))
        if self.productCodeValue is not None:
            namespaceprefix_ = self.productCodeValue_nsprefix_ + ':' if (UseCapturedNS_ and self.productCodeValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductCodeValue>%s</%sproductCodeValue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.productCodeValue), input_name='productCodeValue')), namespaceprefix_ , eol_))
        if self.productCodeOwnValue is not None:
            namespaceprefix_ = self.productCodeOwnValue_nsprefix_ + ':' if (UseCapturedNS_ and self.productCodeOwnValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductCodeOwnValue>%s</%sproductCodeOwnValue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.productCodeOwnValue), input_name='productCodeOwnValue')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='ProductCodeType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.productCodeCategory is not None:
            productCodeCategory_ = self.productCodeCategory
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productCodeCategory').text = self.gds_format_string(productCodeCategory_)
        if self.productCodeValue is not None:
            productCodeValue_ = self.productCodeValue
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productCodeValue').text = self.gds_format_string(productCodeValue_)
        if self.productCodeOwnValue is not None:
            productCodeOwnValue_ = self.productCodeOwnValue
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productCodeOwnValue').text = self.gds_format_string(productCodeOwnValue_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ProductCodeType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.productCodeCategory is not None:
            showIndent(outfile, level)
            outfile.write('productCodeCategory=%s,\n' % self.gds_encode(quote_python(self.productCodeCategory)))
        if self.productCodeValue is not None:
            showIndent(outfile, level)
            outfile.write('productCodeValue=%s,\n' % self.gds_encode(quote_python(self.productCodeValue)))
        if self.productCodeOwnValue is not None:
            showIndent(outfile, level)
            outfile.write('productCodeOwnValue=%s,\n' % self.gds_encode(quote_python(self.productCodeOwnValue)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'productCodeCategory':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'productCodeCategory')
            value_ = self.gds_validate_string(value_, node, 'productCodeCategory')
            self.productCodeCategory = value_
            self.productCodeCategory_nsprefix_ = child_.prefix
            # validate type ProductCodeCategoryType
            self.validate_ProductCodeCategoryType(self.productCodeCategory)
        elif nodeName_ == 'productCodeValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'productCodeValue')
            value_ = self.gds_validate_string(value_, node, 'productCodeValue')
            self.productCodeValue = value_
            self.productCodeValue_nsprefix_ = child_.prefix
            # validate type ProductCodeValueType
            self.validate_ProductCodeValueType(self.productCodeValue)
        elif nodeName_ == 'productCodeOwnValue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'productCodeOwnValue')
            value_ = self.gds_validate_string(value_, node, 'productCodeOwnValue')
            self.productCodeOwnValue = value_
            self.productCodeOwnValue_nsprefix_ = child_.prefix
            # validate type SimpleText255NotBlankType
            self.validate_SimpleText255NotBlankType(self.productCodeOwnValue)
# end class ProductCodeType


class ProductFeeClauseType(GeneratedsSuper):
    """ProductFeeClauseType -- A k
    ö
    rnyezetv
    é
    delmi term
    é
    kd
    í
    jr
    ó
    l sz
    ó
    l
    ó
    2011.
    é
    vi LXXXV. tv. szerinti, t
    é
    telre vonatkoz
    ó
    z
    á
    rad
    é
    kok
    Clauses according to the Act LXXXV of 2011 on Environmental Protection Product Fee (related to the item)
    productFeeTakeoverData -- A k
    ö
    rnyezetv
    é
    delmi term
    é
    kd
    í
    j k
    ö
    telezetts
    é
    g
    á
    tv
    á
    llal
    á
    s
    á
    val kapcsolatos adatok
    Data in connection with takeover of environmental protection product fee
    customerDeclaration -- Ha az elad
    ó
    a vev
    ő
    nyilatkozata alapj
    á
    n mentes
    ü
    l a term
    é
    kd
    í
    j megfizet
    é
    se al
    ó
    l, akkor az
    é
    rintett term
    é
    k
    á
    ram
    Should the supplier, based on statement given by the purchaser, be exempted from paying product fee, then the product stream affected

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, productFeeTakeoverData=None, customerDeclaration=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.productFeeTakeoverData = productFeeTakeoverData
        self.productFeeTakeoverData_nsprefix_ = None
        self.customerDeclaration = customerDeclaration
        self.customerDeclaration_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFeeClauseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFeeClauseType.subclass:
            return ProductFeeClauseType.subclass(*args_, **kwargs_)
        else:
            return ProductFeeClauseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_productFeeTakeoverData(self):
        return self.productFeeTakeoverData
    def set_productFeeTakeoverData(self, productFeeTakeoverData):
        self.productFeeTakeoverData = productFeeTakeoverData
    def get_customerDeclaration(self):
        return self.customerDeclaration
    def set_customerDeclaration(self, customerDeclaration):
        self.customerDeclaration = customerDeclaration
    def _hasContent(self):
        if (
            self.productFeeTakeoverData is not None or
            self.customerDeclaration is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ProductFeeClauseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProductFeeClauseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProductFeeClauseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProductFeeClauseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProductFeeClauseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProductFeeClauseType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='ProductFeeClauseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.productFeeTakeoverData is not None:
            namespaceprefix_ = self.productFeeTakeoverData_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeTakeoverData_nsprefix_) else ''
            self.productFeeTakeoverData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='productFeeTakeoverData', pretty_print=pretty_print)
        if self.customerDeclaration is not None:
            namespaceprefix_ = self.customerDeclaration_nsprefix_ + ':' if (UseCapturedNS_ and self.customerDeclaration_nsprefix_) else ''
            self.customerDeclaration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='customerDeclaration', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ProductFeeClauseType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.productFeeTakeoverData is not None:
            productFeeTakeoverData_ = self.productFeeTakeoverData
            productFeeTakeoverData_.to_etree(element, name_='productFeeTakeoverData', mapping_=mapping_, nsmap_=nsmap_)
        if self.customerDeclaration is not None:
            customerDeclaration_ = self.customerDeclaration
            customerDeclaration_.to_etree(element, name_='customerDeclaration', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ProductFeeClauseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.productFeeTakeoverData is not None:
            showIndent(outfile, level)
            outfile.write('productFeeTakeoverData=model_.ProductFeeTakeoverDataType(\n')
            self.productFeeTakeoverData.exportLiteral(outfile, level, name_='productFeeTakeoverData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.customerDeclaration is not None:
            showIndent(outfile, level)
            outfile.write('customerDeclaration=model_.CustomerDeclarationType(\n')
            self.customerDeclaration.exportLiteral(outfile, level, name_='customerDeclaration')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'productFeeTakeoverData':
            obj_ = ProductFeeTakeoverDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productFeeTakeoverData = obj_
            obj_.original_tagname_ = 'productFeeTakeoverData'
        elif nodeName_ == 'customerDeclaration':
            obj_ = CustomerDeclarationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.customerDeclaration = obj_
            obj_.original_tagname_ = 'customerDeclaration'
# end class ProductFeeClauseType


class ProductFeeDataType(GeneratedsSuper):
    """ProductFeeDataType -- Term
    é
    kd
    í
    j adatok
    Product charges data
    productFeeCode -- Term
    é
    kd
    í
    j k
    ó
    d (Kt vagy Csk)
    Product charges code (Kt or Csk code)
    productFeeQuantity -- A term
    é
    kd
    í
    jjal
    é
    rintett term
    é
    k mennyis
    é
    ge
    Quantity of product, according to product charge
    productFeeMeasuringUnit -- A d
    í
    jt
    é
    tel egys
    é
    ge (kg vagy darab)
    Unit of the rate (kg or piece)
    productFeeRate -- A term
    é
    kd
    í
    j d
    í
    jt
    é
    tele (HUF/egys
    é
    g)
    Product fee rate (HUF/unit)
    productFeeAmount -- Term
    é
    kd
    í
    j
    ö
    sszege forintban
    Amount in Hungarian forints of the product fee

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, productFeeCode=None, productFeeQuantity=None, productFeeMeasuringUnit=None, productFeeRate=None, productFeeAmount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.productFeeCode = productFeeCode
        self.productFeeCode_nsprefix_ = None
        self.productFeeQuantity = productFeeQuantity
        self.validate_QuantityType(self.productFeeQuantity)
        self.productFeeQuantity_nsprefix_ = None
        self.productFeeMeasuringUnit = productFeeMeasuringUnit
        self.validate_ProductFeeMeasuringUnitType(self.productFeeMeasuringUnit)
        self.productFeeMeasuringUnit_nsprefix_ = None
        self.productFeeRate = productFeeRate
        self.validate_MonetaryType(self.productFeeRate)
        self.productFeeRate_nsprefix_ = "base"
        self.productFeeAmount = productFeeAmount
        self.validate_MonetaryType(self.productFeeAmount)
        self.productFeeAmount_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFeeDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFeeDataType.subclass:
            return ProductFeeDataType.subclass(*args_, **kwargs_)
        else:
            return ProductFeeDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_productFeeCode(self):
        return self.productFeeCode
    def set_productFeeCode(self, productFeeCode):
        self.productFeeCode = productFeeCode
    def get_productFeeQuantity(self):
        return self.productFeeQuantity
    def set_productFeeQuantity(self, productFeeQuantity):
        self.productFeeQuantity = productFeeQuantity
    def get_productFeeMeasuringUnit(self):
        return self.productFeeMeasuringUnit
    def set_productFeeMeasuringUnit(self, productFeeMeasuringUnit):
        self.productFeeMeasuringUnit = productFeeMeasuringUnit
    def get_productFeeRate(self):
        return self.productFeeRate
    def set_productFeeRate(self, productFeeRate):
        self.productFeeRate = productFeeRate
    def get_productFeeAmount(self):
        return self.productFeeAmount
    def set_productFeeAmount(self, productFeeAmount):
        self.productFeeAmount = productFeeAmount
    def validate_QuantityType(self, value):
        result = True
        # Validate type QuantityType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 22:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_ProductFeeMeasuringUnitType(self, value):
        result = True
        # Validate type ProductFeeMeasuringUnitType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['DARAB', 'KG']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ProductFeeMeasuringUnitType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ProductFeeMeasuringUnitType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ProductFeeMeasuringUnitType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.productFeeCode is not None or
            self.productFeeQuantity is not None or
            self.productFeeMeasuringUnit is not None or
            self.productFeeRate is not None or
            self.productFeeAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='ProductFeeDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProductFeeDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProductFeeDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProductFeeDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProductFeeDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProductFeeDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='ProductFeeDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.productFeeCode is not None:
            namespaceprefix_ = self.productFeeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeCode_nsprefix_) else ''
            self.productFeeCode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='productFeeCode', pretty_print=pretty_print)
        if self.productFeeQuantity is not None:
            namespaceprefix_ = self.productFeeQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductFeeQuantity>%s</%sproductFeeQuantity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.productFeeQuantity, input_name='productFeeQuantity'), namespaceprefix_ , eol_))
        if self.productFeeMeasuringUnit is not None:
            namespaceprefix_ = self.productFeeMeasuringUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeMeasuringUnit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductFeeMeasuringUnit>%s</%sproductFeeMeasuringUnit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.productFeeMeasuringUnit), input_name='productFeeMeasuringUnit')), namespaceprefix_ , eol_))
        if self.productFeeRate is not None:
            namespaceprefix_ = self.productFeeRate_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductFeeRate>%s</%sproductFeeRate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.productFeeRate, input_name='productFeeRate'), namespaceprefix_ , eol_))
        if self.productFeeAmount is not None:
            namespaceprefix_ = self.productFeeAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductFeeAmount>%s</%sproductFeeAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.productFeeAmount, input_name='productFeeAmount'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='ProductFeeDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.productFeeCode is not None:
            productFeeCode_ = self.productFeeCode
            productFeeCode_.to_etree(element, name_='productFeeCode', mapping_=mapping_, nsmap_=nsmap_)
        if self.productFeeQuantity is not None:
            productFeeQuantity_ = self.productFeeQuantity
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productFeeQuantity').text = self.gds_format_decimal(productFeeQuantity_)
        if self.productFeeMeasuringUnit is not None:
            productFeeMeasuringUnit_ = self.productFeeMeasuringUnit
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productFeeMeasuringUnit').text = self.gds_format_string(productFeeMeasuringUnit_)
        if self.productFeeRate is not None:
            productFeeRate_ = self.productFeeRate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productFeeRate').text = self.gds_format_decimal(productFeeRate_)
        if self.productFeeAmount is not None:
            productFeeAmount_ = self.productFeeAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productFeeAmount').text = self.gds_format_decimal(productFeeAmount_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ProductFeeDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.productFeeCode is not None:
            showIndent(outfile, level)
            outfile.write('productFeeCode=model_.ProductCodeType(\n')
            self.productFeeCode.exportLiteral(outfile, level, name_='productFeeCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.productFeeQuantity is not None:
            showIndent(outfile, level)
            outfile.write('productFeeQuantity=%f,\n' % self.productFeeQuantity)
        if self.productFeeMeasuringUnit is not None:
            showIndent(outfile, level)
            outfile.write('productFeeMeasuringUnit=%s,\n' % self.gds_encode(quote_python(self.productFeeMeasuringUnit)))
        if self.productFeeRate is not None:
            showIndent(outfile, level)
            outfile.write('productFeeRate=%f,\n' % self.productFeeRate)
        if self.productFeeAmount is not None:
            showIndent(outfile, level)
            outfile.write('productFeeAmount=%f,\n' % self.productFeeAmount)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'productFeeCode':
            obj_ = ProductCodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productFeeCode = obj_
            obj_.original_tagname_ = 'productFeeCode'
        elif nodeName_ == 'productFeeQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'productFeeQuantity')
            fval_ = self.gds_validate_decimal(fval_, node, 'productFeeQuantity')
            self.productFeeQuantity = fval_
            self.productFeeQuantity_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.productFeeQuantity)
        elif nodeName_ == 'productFeeMeasuringUnit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'productFeeMeasuringUnit')
            value_ = self.gds_validate_string(value_, node, 'productFeeMeasuringUnit')
            self.productFeeMeasuringUnit = value_
            self.productFeeMeasuringUnit_nsprefix_ = child_.prefix
            # validate type ProductFeeMeasuringUnitType
            self.validate_ProductFeeMeasuringUnitType(self.productFeeMeasuringUnit)
        elif nodeName_ == 'productFeeRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'productFeeRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'productFeeRate')
            self.productFeeRate = fval_
            self.productFeeRate_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.productFeeRate)
        elif nodeName_ == 'productFeeAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'productFeeAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'productFeeAmount')
            self.productFeeAmount = fval_
            self.productFeeAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.productFeeAmount)
# end class ProductFeeDataType


class ProductFeeSummaryType(GeneratedsSuper):
    """ProductFeeSummaryType -- Term
    é
    kd
    í
    j
    ö
    sszegz
    é
    s adatok
    Summary of product charges
    productFeeOperation -- Annak jelz
    é
    se, hogy a term
    é
    kd
    í
    j
    ö
    sszes
    í
    t
    é
    s visszaig
    é
    nyl
    é
    sre (REFUND) vagy rakt
    á
    rba t
    ö
    rt
    é
    n
    ő
    besz
    á
    ll
    í
    t
    á
    sra (DEPOSIT) vonatkozik
    Indicating whether the the product fee summary concerns refund or deposit
    productFeeData -- Term
    é
    kd
    í
    j adatok
    Product charges data
    productChargeSum -- Term
    é
    kd
    í
    j
    ö
    sszesen
    Aggregate product charges
    paymentEvidenceDocumentData -- A term
    é
    kd
    í
    j bevall
    á
    s
    á
    t igazol
    ó
    dokumentum adatai a 2011.
    é
    vi LXXXV. tv. 13.
    §
    (3) szerint
    é
    s a 25.
    §
    (3) szerint
    Data of the document verifying the declaration submitted on the product fee according to the Paragraph (3), Section 13 and the Paragraph (3) Section 25 of the Act LXXXV of 2011

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, productFeeOperation=None, productFeeData=None, productChargeSum=None, paymentEvidenceDocumentData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.productFeeOperation = productFeeOperation
        self.validate_ProductFeeOperationType(self.productFeeOperation)
        self.productFeeOperation_nsprefix_ = None
        if productFeeData is None:
            self.productFeeData = []
        else:
            self.productFeeData = productFeeData
        self.productFeeData_nsprefix_ = None
        self.productChargeSum = productChargeSum
        self.validate_MonetaryType(self.productChargeSum)
        self.productChargeSum_nsprefix_ = "base"
        self.paymentEvidenceDocumentData = paymentEvidenceDocumentData
        self.paymentEvidenceDocumentData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFeeSummaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFeeSummaryType.subclass:
            return ProductFeeSummaryType.subclass(*args_, **kwargs_)
        else:
            return ProductFeeSummaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_productFeeOperation(self):
        return self.productFeeOperation
    def set_productFeeOperation(self, productFeeOperation):
        self.productFeeOperation = productFeeOperation
    def get_productFeeData(self):
        return self.productFeeData
    def set_productFeeData(self, productFeeData):
        self.productFeeData = productFeeData
    def add_productFeeData(self, value):
        self.productFeeData.append(value)
    def insert_productFeeData_at(self, index, value):
        self.productFeeData.insert(index, value)
    def replace_productFeeData_at(self, index, value):
        self.productFeeData[index] = value
    def get_productChargeSum(self):
        return self.productChargeSum
    def set_productChargeSum(self, productChargeSum):
        self.productChargeSum = productChargeSum
    def get_paymentEvidenceDocumentData(self):
        return self.paymentEvidenceDocumentData
    def set_paymentEvidenceDocumentData(self, paymentEvidenceDocumentData):
        self.paymentEvidenceDocumentData = paymentEvidenceDocumentData
    def validate_ProductFeeOperationType(self, value):
        result = True
        # Validate type ProductFeeOperationType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['REFUND', 'DEPOSIT']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ProductFeeOperationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ProductFeeOperationType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ProductFeeOperationType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.productFeeOperation is not None or
            self.productFeeData or
            self.productChargeSum is not None or
            self.paymentEvidenceDocumentData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='ProductFeeSummaryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProductFeeSummaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProductFeeSummaryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProductFeeSummaryType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProductFeeSummaryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProductFeeSummaryType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='ProductFeeSummaryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.productFeeOperation is not None:
            namespaceprefix_ = self.productFeeOperation_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeOperation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductFeeOperation>%s</%sproductFeeOperation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.productFeeOperation), input_name='productFeeOperation')), namespaceprefix_ , eol_))
        for productFeeData_ in self.productFeeData:
            namespaceprefix_ = self.productFeeData_nsprefix_ + ':' if (UseCapturedNS_ and self.productFeeData_nsprefix_) else ''
            productFeeData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='productFeeData', pretty_print=pretty_print)
        if self.productChargeSum is not None:
            namespaceprefix_ = self.productChargeSum_nsprefix_ + ':' if (UseCapturedNS_ and self.productChargeSum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductChargeSum>%s</%sproductChargeSum>%s' % (namespaceprefix_ , self.gds_format_decimal(self.productChargeSum, input_name='productChargeSum'), namespaceprefix_ , eol_))
        if self.paymentEvidenceDocumentData is not None:
            namespaceprefix_ = self.paymentEvidenceDocumentData_nsprefix_ + ':' if (UseCapturedNS_ and self.paymentEvidenceDocumentData_nsprefix_) else ''
            self.paymentEvidenceDocumentData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paymentEvidenceDocumentData', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ProductFeeSummaryType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.productFeeOperation is not None:
            productFeeOperation_ = self.productFeeOperation
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productFeeOperation').text = self.gds_format_string(productFeeOperation_)
        for productFeeData_ in self.productFeeData:
            productFeeData_.to_etree(element, name_='productFeeData', mapping_=mapping_, nsmap_=nsmap_)
        if self.productChargeSum is not None:
            productChargeSum_ = self.productChargeSum
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}productChargeSum').text = self.gds_format_decimal(productChargeSum_)
        if self.paymentEvidenceDocumentData is not None:
            paymentEvidenceDocumentData_ = self.paymentEvidenceDocumentData
            paymentEvidenceDocumentData_.to_etree(element, name_='paymentEvidenceDocumentData', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ProductFeeSummaryType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.productFeeOperation is not None:
            showIndent(outfile, level)
            outfile.write('productFeeOperation=%s,\n' % self.gds_encode(quote_python(self.productFeeOperation)))
        showIndent(outfile, level)
        outfile.write('productFeeData=[\n')
        level += 1
        for productFeeData_ in self.productFeeData:
            showIndent(outfile, level)
            outfile.write('model_.ProductFeeDataType(\n')
            productFeeData_.exportLiteral(outfile, level, name_='ProductFeeDataType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.productChargeSum is not None:
            showIndent(outfile, level)
            outfile.write('productChargeSum=%f,\n' % self.productChargeSum)
        if self.paymentEvidenceDocumentData is not None:
            showIndent(outfile, level)
            outfile.write('paymentEvidenceDocumentData=model_.PaymentEvidenceDocumentDataType(\n')
            self.paymentEvidenceDocumentData.exportLiteral(outfile, level, name_='paymentEvidenceDocumentData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'productFeeOperation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'productFeeOperation')
            value_ = self.gds_validate_string(value_, node, 'productFeeOperation')
            self.productFeeOperation = value_
            self.productFeeOperation_nsprefix_ = child_.prefix
            # validate type ProductFeeOperationType
            self.validate_ProductFeeOperationType(self.productFeeOperation)
        elif nodeName_ == 'productFeeData':
            obj_ = ProductFeeDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.productFeeData.append(obj_)
            obj_.original_tagname_ = 'productFeeData'
        elif nodeName_ == 'productChargeSum' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'productChargeSum')
            fval_ = self.gds_validate_decimal(fval_, node, 'productChargeSum')
            self.productChargeSum = fval_
            self.productChargeSum_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.productChargeSum)
        elif nodeName_ == 'paymentEvidenceDocumentData':
            obj_ = PaymentEvidenceDocumentDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.paymentEvidenceDocumentData = obj_
            obj_.original_tagname_ = 'paymentEvidenceDocumentData'
# end class ProductFeeSummaryType


class ProductFeeTakeoverDataType(GeneratedsSuper):
    """ProductFeeTakeoverDataType -- A k
    ö
    rnyezetv
    é
    delmi term
    é
    kd
    í
    j k
    ö
    telezetts
    é
    g
    á
    tv
    á
    llal
    á
    s
    á
    val kapcsolatos adatok
    Data in connection with takeover of environmental protection product fee
    takeoverReason -- Az
    á
    tv
    á
    llal
    á
    s ir
    á
    nya
    é
    s jogszab
    á
    lyi alapja
    Direction and legal base of takeover
    takeoverAmount -- Az
    á
    tv
    á
    llalt term
    é
    kd
    í
    j
    ö
    sszege forintban, ha a vev
    ő
    v
    á
    llalja
    á
    t az elad
    ó
    term
    é
    kd
    í
    j-k
    ö
    telezetts
    é
    g
    é
    t
    Amount in Hungarian forints of the product fee taken over if the purchaser takes over the supplier
    ’
    s product fee liability

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, takeoverReason=None, takeoverAmount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.takeoverReason = takeoverReason
        self.validate_TakeoverType(self.takeoverReason)
        self.takeoverReason_nsprefix_ = None
        self.takeoverAmount = takeoverAmount
        self.validate_MonetaryType(self.takeoverAmount)
        self.takeoverAmount_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductFeeTakeoverDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductFeeTakeoverDataType.subclass:
            return ProductFeeTakeoverDataType.subclass(*args_, **kwargs_)
        else:
            return ProductFeeTakeoverDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_takeoverReason(self):
        return self.takeoverReason
    def set_takeoverReason(self, takeoverReason):
        self.takeoverReason = takeoverReason
    def get_takeoverAmount(self):
        return self.takeoverAmount
    def set_takeoverAmount(self, takeoverAmount):
        self.takeoverAmount = takeoverAmount
    def validate_TakeoverType(self, value):
        result = True
        # Validate type TakeoverType, a restriction on common:AtomicStringType8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['01', '02_aa', '02_ab', '02_b', '02_c', '02_d', '02_ea', '02_eb', '02_fa', '02_fb', '02_ga', '02_gb']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TakeoverType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TakeoverType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TakeoverType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.takeoverReason is not None or
            self.takeoverAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='ProductFeeTakeoverDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProductFeeTakeoverDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProductFeeTakeoverDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProductFeeTakeoverDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProductFeeTakeoverDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProductFeeTakeoverDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='ProductFeeTakeoverDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.takeoverReason is not None:
            namespaceprefix_ = self.takeoverReason_nsprefix_ + ':' if (UseCapturedNS_ and self.takeoverReason_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stakeoverReason>%s</%stakeoverReason>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.takeoverReason), input_name='takeoverReason')), namespaceprefix_ , eol_))
        if self.takeoverAmount is not None:
            namespaceprefix_ = self.takeoverAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.takeoverAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stakeoverAmount>%s</%stakeoverAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.takeoverAmount, input_name='takeoverAmount'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='ProductFeeTakeoverDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.takeoverReason is not None:
            takeoverReason_ = self.takeoverReason
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}takeoverReason').text = self.gds_format_string(takeoverReason_)
        if self.takeoverAmount is not None:
            takeoverAmount_ = self.takeoverAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}takeoverAmount').text = self.gds_format_decimal(takeoverAmount_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ProductFeeTakeoverDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.takeoverReason is not None:
            showIndent(outfile, level)
            outfile.write('takeoverReason=%s,\n' % self.gds_encode(quote_python(self.takeoverReason)))
        if self.takeoverAmount is not None:
            showIndent(outfile, level)
            outfile.write('takeoverAmount=%f,\n' % self.takeoverAmount)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'takeoverReason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'takeoverReason')
            value_ = self.gds_validate_string(value_, node, 'takeoverReason')
            self.takeoverReason = value_
            self.takeoverReason_nsprefix_ = child_.prefix
            # validate type TakeoverType
            self.validate_TakeoverType(self.takeoverReason)
        elif nodeName_ == 'takeoverAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'takeoverAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'takeoverAmount')
            self.takeoverAmount = fval_
            self.takeoverAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.takeoverAmount)
# end class ProductFeeTakeoverDataType


class ProjectNumbersType(GeneratedsSuper):
    """ProjectNumbersType -- Projektsz
    á
    mok
    Project numbers
    projectNumber -- Projektsz
    á
    m
    Project number

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, projectNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if projectNumber is None:
            self.projectNumber = []
        else:
            self.projectNumber = projectNumber
        self.projectNumber_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectNumbersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectNumbersType.subclass:
            return ProjectNumbersType.subclass(*args_, **kwargs_)
        else:
            return ProjectNumbersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_projectNumber(self):
        return self.projectNumber
    def set_projectNumber(self, projectNumber):
        self.projectNumber = projectNumber
    def add_projectNumber(self, value):
        self.projectNumber.append(value)
    def insert_projectNumber_at(self, index, value):
        self.projectNumber.insert(index, value)
    def replace_projectNumber_at(self, index, value):
        self.projectNumber[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.projectNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='ProjectNumbersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProjectNumbersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProjectNumbersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectNumbersType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProjectNumbersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProjectNumbersType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='ProjectNumbersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for projectNumber_ in self.projectNumber:
            namespaceprefix_ = self.projectNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.projectNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprojectNumber>%s</%sprojectNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(projectNumber_), input_name='projectNumber')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='ProjectNumbersType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for projectNumber_ in self.projectNumber:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}projectNumber').text = self.gds_format_string(projectNumber_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ProjectNumbersType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('projectNumber=[\n')
        level += 1
        for projectNumber_ in self.projectNumber:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(projectNumber_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'projectNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'projectNumber')
            value_ = self.gds_validate_string(value_, node, 'projectNumber')
            self.projectNumber.append(value_)
            self.projectNumber_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.projectNumber[-1])
# end class ProjectNumbersType


class ReferencesToOtherLinesType(GeneratedsSuper):
    """ReferencesToOtherLinesType -- Hivatkoz
    á
    sok kapcsol
    ó
    d
    ó
    t
    é
    telekre, ha ez az
    Á
    FA t
    ö
    rv
    é
    ny alapj
    á
    n sz
    ü
    ks
    é
    ges
    References to connected items if it is necessary according to VAT law
    referenceToOtherLine -- Hivatkoz
    á
    sok kapcsol
    ó
    d
    ó
    t
    é
    telekre, ha ez az
    Á
    FA t
    ö
    rv
    é
    ny alapj
    á
    n sz
    ü
    ks
    é
    ges
    References to connected items if it is necessary according to VAT law

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, referenceToOtherLine=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if referenceToOtherLine is None:
            self.referenceToOtherLine = []
        else:
            self.referenceToOtherLine = referenceToOtherLine
        self.referenceToOtherLine_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferencesToOtherLinesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferencesToOtherLinesType.subclass:
            return ReferencesToOtherLinesType.subclass(*args_, **kwargs_)
        else:
            return ReferencesToOtherLinesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_referenceToOtherLine(self):
        return self.referenceToOtherLine
    def set_referenceToOtherLine(self, referenceToOtherLine):
        self.referenceToOtherLine = referenceToOtherLine
    def add_referenceToOtherLine(self, value):
        self.referenceToOtherLine.append(value)
    def insert_referenceToOtherLine_at(self, index, value):
        self.referenceToOtherLine.insert(index, value)
    def replace_referenceToOtherLine_at(self, index, value):
        self.referenceToOtherLine[index] = value
    def validate_LineNumberType(self, value):
        result = True
        # Validate type LineNumberType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on LineNumberType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.referenceToOtherLine
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='ReferencesToOtherLinesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferencesToOtherLinesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferencesToOtherLinesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferencesToOtherLinesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferencesToOtherLinesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferencesToOtherLinesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='ReferencesToOtherLinesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for referenceToOtherLine_ in self.referenceToOtherLine:
            namespaceprefix_ = self.referenceToOtherLine_nsprefix_ + ':' if (UseCapturedNS_ and self.referenceToOtherLine_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreferenceToOtherLine>%s</%sreferenceToOtherLine>%s' % (namespaceprefix_ , self.gds_format_integer(referenceToOtherLine_, input_name='referenceToOtherLine'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='ReferencesToOtherLinesType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for referenceToOtherLine_ in self.referenceToOtherLine:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}referenceToOtherLine').text = self.gds_format_integer(referenceToOtherLine_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ReferencesToOtherLinesType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('referenceToOtherLine=[\n')
        level += 1
        for referenceToOtherLine_ in self.referenceToOtherLine:
            showIndent(outfile, level)
            outfile.write('%d,\n' % referenceToOtherLine_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'referenceToOtherLine' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'referenceToOtherLine')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'referenceToOtherLine')
            self.referenceToOtherLine.append(ival_)
            self.referenceToOtherLine_nsprefix_ = child_.prefix
            # validate type LineNumberType
            self.validate_LineNumberType(self.referenceToOtherLine[-1])
# end class ReferencesToOtherLinesType


class ShippingDatesType(GeneratedsSuper):
    """ShippingDatesType -- Sz
    á
    ll
    í
    t
    á
    si d
    á
    tumok
    Shipping dates
    shippingDate -- Sz
    á
    ll
    í
    t
    á
    si d
    á
    tum
    Shipping date

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, shippingDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if shippingDate is None:
            self.shippingDate = []
        else:
            self.shippingDate = shippingDate
        self.shippingDate_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingDatesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingDatesType.subclass:
            return ShippingDatesType.subclass(*args_, **kwargs_)
        else:
            return ShippingDatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_shippingDate(self):
        return self.shippingDate
    def set_shippingDate(self, shippingDate):
        self.shippingDate = shippingDate
    def add_shippingDate(self, value):
        self.shippingDate.append(value)
    def insert_shippingDate_at(self, index, value):
        self.shippingDate.insert(index, value)
    def replace_shippingDate_at(self, index, value):
        self.shippingDate[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.shippingDate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='ShippingDatesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingDatesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShippingDatesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShippingDatesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShippingDatesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShippingDatesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='ShippingDatesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for shippingDate_ in self.shippingDate:
            namespaceprefix_ = self.shippingDate_nsprefix_ + ':' if (UseCapturedNS_ and self.shippingDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshippingDate>%s</%sshippingDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(shippingDate_), input_name='shippingDate')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='ShippingDatesType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for shippingDate_ in self.shippingDate:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}shippingDate').text = self.gds_format_string(shippingDate_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ShippingDatesType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('shippingDate=[\n')
        level += 1
        for shippingDate_ in self.shippingDate:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(shippingDate_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'shippingDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'shippingDate')
            value_ = self.gds_validate_string(value_, node, 'shippingDate')
            self.shippingDate.append(value_)
            self.shippingDate_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.shippingDate[-1])
# end class ShippingDatesType


class SummaryByVatRateType(GeneratedsSuper):
    """SummaryByVatRateType -- Á
    FA m
    é
    rt
    é
    kek szerinti
    ö
    sszes
    í
    t
    é
    s
    Summary according to VAT rates
    vatRate -- Ad
    ó
    m
    é
    rt
    é
    k vagy ad
    ó
    mentess
    é
    g jel
    ö
    l
    é
    se
    Marking the tax rate or the fact of tax exemption
    vatRateNetData -- Adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    nett
    ó
    adatok
    Net data of given tax rate
    vatRateVatData -- Adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    Á
    FA adatok
    VAT data of given tax rate
    vatRateGrossData -- Adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    brutt
    ó
    adatok
    Gross data of given tax rate

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vatRate=None, vatRateNetData=None, vatRateVatData=None, vatRateGrossData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vatRate = vatRate
        self.vatRate_nsprefix_ = None
        self.vatRateNetData = vatRateNetData
        self.vatRateNetData_nsprefix_ = None
        self.vatRateVatData = vatRateVatData
        self.vatRateVatData_nsprefix_ = None
        self.vatRateGrossData = vatRateGrossData
        self.vatRateGrossData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SummaryByVatRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SummaryByVatRateType.subclass:
            return SummaryByVatRateType.subclass(*args_, **kwargs_)
        else:
            return SummaryByVatRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vatRate(self):
        return self.vatRate
    def set_vatRate(self, vatRate):
        self.vatRate = vatRate
    def get_vatRateNetData(self):
        return self.vatRateNetData
    def set_vatRateNetData(self, vatRateNetData):
        self.vatRateNetData = vatRateNetData
    def get_vatRateVatData(self):
        return self.vatRateVatData
    def set_vatRateVatData(self, vatRateVatData):
        self.vatRateVatData = vatRateVatData
    def get_vatRateGrossData(self):
        return self.vatRateGrossData
    def set_vatRateGrossData(self, vatRateGrossData):
        self.vatRateGrossData = vatRateGrossData
    def _hasContent(self):
        if (
            self.vatRate is not None or
            self.vatRateNetData is not None or
            self.vatRateVatData is not None or
            self.vatRateGrossData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='SummaryByVatRateType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SummaryByVatRateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SummaryByVatRateType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SummaryByVatRateType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SummaryByVatRateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SummaryByVatRateType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='SummaryByVatRateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vatRate is not None:
            namespaceprefix_ = self.vatRate_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRate_nsprefix_) else ''
            self.vatRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vatRate', pretty_print=pretty_print)
        if self.vatRateNetData is not None:
            namespaceprefix_ = self.vatRateNetData_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRateNetData_nsprefix_) else ''
            self.vatRateNetData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vatRateNetData', pretty_print=pretty_print)
        if self.vatRateVatData is not None:
            namespaceprefix_ = self.vatRateVatData_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRateVatData_nsprefix_) else ''
            self.vatRateVatData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vatRateVatData', pretty_print=pretty_print)
        if self.vatRateGrossData is not None:
            namespaceprefix_ = self.vatRateGrossData_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRateGrossData_nsprefix_) else ''
            self.vatRateGrossData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vatRateGrossData', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SummaryByVatRateType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.vatRate is not None:
            vatRate_ = self.vatRate
            vatRate_.to_etree(element, name_='vatRate', mapping_=mapping_, nsmap_=nsmap_)
        if self.vatRateNetData is not None:
            vatRateNetData_ = self.vatRateNetData
            vatRateNetData_.to_etree(element, name_='vatRateNetData', mapping_=mapping_, nsmap_=nsmap_)
        if self.vatRateVatData is not None:
            vatRateVatData_ = self.vatRateVatData
            vatRateVatData_.to_etree(element, name_='vatRateVatData', mapping_=mapping_, nsmap_=nsmap_)
        if self.vatRateGrossData is not None:
            vatRateGrossData_ = self.vatRateGrossData
            vatRateGrossData_.to_etree(element, name_='vatRateGrossData', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SummaryByVatRateType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.vatRate is not None:
            showIndent(outfile, level)
            outfile.write('vatRate=model_.VatRateType(\n')
            self.vatRate.exportLiteral(outfile, level, name_='vatRate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vatRateNetData is not None:
            showIndent(outfile, level)
            outfile.write('vatRateNetData=model_.VatRateNetDataType(\n')
            self.vatRateNetData.exportLiteral(outfile, level, name_='vatRateNetData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vatRateVatData is not None:
            showIndent(outfile, level)
            outfile.write('vatRateVatData=model_.VatRateVatDataType(\n')
            self.vatRateVatData.exportLiteral(outfile, level, name_='vatRateVatData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vatRateGrossData is not None:
            showIndent(outfile, level)
            outfile.write('vatRateGrossData=model_.VatRateGrossDataType(\n')
            self.vatRateGrossData.exportLiteral(outfile, level, name_='vatRateGrossData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vatRate':
            obj_ = VatRateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vatRate = obj_
            obj_.original_tagname_ = 'vatRate'
        elif nodeName_ == 'vatRateNetData':
            obj_ = VatRateNetDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vatRateNetData = obj_
            obj_.original_tagname_ = 'vatRateNetData'
        elif nodeName_ == 'vatRateVatData':
            obj_ = VatRateVatDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vatRateVatData = obj_
            obj_.original_tagname_ = 'vatRateVatData'
        elif nodeName_ == 'vatRateGrossData':
            obj_ = VatRateGrossDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vatRateGrossData = obj_
            obj_.original_tagname_ = 'vatRateGrossData'
# end class SummaryByVatRateType


class SummaryGrossDataType(GeneratedsSuper):
    """SummaryGrossDataType -- A sz
    á
    mla
    ö
    sszes
    í
    t
    ő
    brutt
    ó
    adatai
    Gross data of the invoice summary
    invoiceGrossAmount -- A sz
    á
    mla brutt
    ó
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben
    Gross amount of the invoice expressed in the currency of the invoice
    invoiceGrossAmountHUF -- A sz
    á
    mla brutt
    ó
    ö
    sszege forintban
    Gross amount of the invoice expressed in HUF

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, invoiceGrossAmount=None, invoiceGrossAmountHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invoiceGrossAmount = invoiceGrossAmount
        self.validate_MonetaryType(self.invoiceGrossAmount)
        self.invoiceGrossAmount_nsprefix_ = "base"
        self.invoiceGrossAmountHUF = invoiceGrossAmountHUF
        self.validate_MonetaryType(self.invoiceGrossAmountHUF)
        self.invoiceGrossAmountHUF_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SummaryGrossDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SummaryGrossDataType.subclass:
            return SummaryGrossDataType.subclass(*args_, **kwargs_)
        else:
            return SummaryGrossDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_invoiceGrossAmount(self):
        return self.invoiceGrossAmount
    def set_invoiceGrossAmount(self, invoiceGrossAmount):
        self.invoiceGrossAmount = invoiceGrossAmount
    def get_invoiceGrossAmountHUF(self):
        return self.invoiceGrossAmountHUF
    def set_invoiceGrossAmountHUF(self, invoiceGrossAmountHUF):
        self.invoiceGrossAmountHUF = invoiceGrossAmountHUF
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.invoiceGrossAmount is not None or
            self.invoiceGrossAmountHUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='SummaryGrossDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SummaryGrossDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SummaryGrossDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SummaryGrossDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SummaryGrossDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SummaryGrossDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='SummaryGrossDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.invoiceGrossAmount is not None:
            namespaceprefix_ = self.invoiceGrossAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceGrossAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceGrossAmount>%s</%sinvoiceGrossAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.invoiceGrossAmount, input_name='invoiceGrossAmount'), namespaceprefix_ , eol_))
        if self.invoiceGrossAmountHUF is not None:
            namespaceprefix_ = self.invoiceGrossAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceGrossAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceGrossAmountHUF>%s</%sinvoiceGrossAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.invoiceGrossAmountHUF, input_name='invoiceGrossAmountHUF'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='SummaryGrossDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.invoiceGrossAmount is not None:
            invoiceGrossAmount_ = self.invoiceGrossAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceGrossAmount').text = self.gds_format_decimal(invoiceGrossAmount_)
        if self.invoiceGrossAmountHUF is not None:
            invoiceGrossAmountHUF_ = self.invoiceGrossAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceGrossAmountHUF').text = self.gds_format_decimal(invoiceGrossAmountHUF_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SummaryGrossDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.invoiceGrossAmount is not None:
            showIndent(outfile, level)
            outfile.write('invoiceGrossAmount=%f,\n' % self.invoiceGrossAmount)
        if self.invoiceGrossAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('invoiceGrossAmountHUF=%f,\n' % self.invoiceGrossAmountHUF)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'invoiceGrossAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'invoiceGrossAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'invoiceGrossAmount')
            self.invoiceGrossAmount = fval_
            self.invoiceGrossAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.invoiceGrossAmount)
        elif nodeName_ == 'invoiceGrossAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'invoiceGrossAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'invoiceGrossAmountHUF')
            self.invoiceGrossAmountHUF = fval_
            self.invoiceGrossAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.invoiceGrossAmountHUF)
# end class SummaryGrossDataType


class SummaryNormalType(GeneratedsSuper):
    """SummaryNormalType -- Sz
    á
    mla
    ö
    sszes
    í
    t
    é
    s (nem egyszer
    ű
    s
    í
    tett sz
    á
    mla eset
    é
    n)
    Calculation of invoice totals (not simplified invoice)
    summaryByVatRate -- Ö
    sszes
    í
    t
    é
    s
    Á
    FA-m
    é
    rt
    é
    k szerint
    Calculation of invoice totals per VAT rates
    invoiceNetAmount -- A sz
    á
    mla nett
    ó
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben
    Net amount of the invoice expressed in the currency of the invoice
    invoiceNetAmountHUF -- A sz
    á
    mla nett
    ó
    ö
    sszege forintban
    Net amount of the invoice expressed in HUF
    invoiceVatAmount -- A sz
    á
    mla
    Á
    FA
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben
    VAT amount of the invoice expressed in the currency of the invoice
    invoiceVatAmountHUF -- A sz
    á
    mla
    Á
    FA
    ö
    sszege forintban
    VAT amount of the invoice expressed in HUF

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, summaryByVatRate=None, invoiceNetAmount=None, invoiceNetAmountHUF=None, invoiceVatAmount=None, invoiceVatAmountHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if summaryByVatRate is None:
            self.summaryByVatRate = []
        else:
            self.summaryByVatRate = summaryByVatRate
        self.summaryByVatRate_nsprefix_ = None
        self.invoiceNetAmount = invoiceNetAmount
        self.validate_MonetaryType(self.invoiceNetAmount)
        self.invoiceNetAmount_nsprefix_ = "base"
        self.invoiceNetAmountHUF = invoiceNetAmountHUF
        self.validate_MonetaryType(self.invoiceNetAmountHUF)
        self.invoiceNetAmountHUF_nsprefix_ = "base"
        self.invoiceVatAmount = invoiceVatAmount
        self.validate_MonetaryType(self.invoiceVatAmount)
        self.invoiceVatAmount_nsprefix_ = "base"
        self.invoiceVatAmountHUF = invoiceVatAmountHUF
        self.validate_MonetaryType(self.invoiceVatAmountHUF)
        self.invoiceVatAmountHUF_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SummaryNormalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SummaryNormalType.subclass:
            return SummaryNormalType.subclass(*args_, **kwargs_)
        else:
            return SummaryNormalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_summaryByVatRate(self):
        return self.summaryByVatRate
    def set_summaryByVatRate(self, summaryByVatRate):
        self.summaryByVatRate = summaryByVatRate
    def add_summaryByVatRate(self, value):
        self.summaryByVatRate.append(value)
    def insert_summaryByVatRate_at(self, index, value):
        self.summaryByVatRate.insert(index, value)
    def replace_summaryByVatRate_at(self, index, value):
        self.summaryByVatRate[index] = value
    def get_invoiceNetAmount(self):
        return self.invoiceNetAmount
    def set_invoiceNetAmount(self, invoiceNetAmount):
        self.invoiceNetAmount = invoiceNetAmount
    def get_invoiceNetAmountHUF(self):
        return self.invoiceNetAmountHUF
    def set_invoiceNetAmountHUF(self, invoiceNetAmountHUF):
        self.invoiceNetAmountHUF = invoiceNetAmountHUF
    def get_invoiceVatAmount(self):
        return self.invoiceVatAmount
    def set_invoiceVatAmount(self, invoiceVatAmount):
        self.invoiceVatAmount = invoiceVatAmount
    def get_invoiceVatAmountHUF(self):
        return self.invoiceVatAmountHUF
    def set_invoiceVatAmountHUF(self, invoiceVatAmountHUF):
        self.invoiceVatAmountHUF = invoiceVatAmountHUF
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.summaryByVatRate or
            self.invoiceNetAmount is not None or
            self.invoiceNetAmountHUF is not None or
            self.invoiceVatAmount is not None or
            self.invoiceVatAmountHUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='SummaryNormalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SummaryNormalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SummaryNormalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SummaryNormalType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SummaryNormalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SummaryNormalType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='SummaryNormalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for summaryByVatRate_ in self.summaryByVatRate:
            namespaceprefix_ = self.summaryByVatRate_nsprefix_ + ':' if (UseCapturedNS_ and self.summaryByVatRate_nsprefix_) else ''
            summaryByVatRate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='summaryByVatRate', pretty_print=pretty_print)
        if self.invoiceNetAmount is not None:
            namespaceprefix_ = self.invoiceNetAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNetAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceNetAmount>%s</%sinvoiceNetAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.invoiceNetAmount, input_name='invoiceNetAmount'), namespaceprefix_ , eol_))
        if self.invoiceNetAmountHUF is not None:
            namespaceprefix_ = self.invoiceNetAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceNetAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceNetAmountHUF>%s</%sinvoiceNetAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.invoiceNetAmountHUF, input_name='invoiceNetAmountHUF'), namespaceprefix_ , eol_))
        if self.invoiceVatAmount is not None:
            namespaceprefix_ = self.invoiceVatAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceVatAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceVatAmount>%s</%sinvoiceVatAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.invoiceVatAmount, input_name='invoiceVatAmount'), namespaceprefix_ , eol_))
        if self.invoiceVatAmountHUF is not None:
            namespaceprefix_ = self.invoiceVatAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.invoiceVatAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvoiceVatAmountHUF>%s</%sinvoiceVatAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.invoiceVatAmountHUF, input_name='invoiceVatAmountHUF'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='SummaryNormalType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for summaryByVatRate_ in self.summaryByVatRate:
            summaryByVatRate_.to_etree(element, name_='summaryByVatRate', mapping_=mapping_, nsmap_=nsmap_)
        if self.invoiceNetAmount is not None:
            invoiceNetAmount_ = self.invoiceNetAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceNetAmount').text = self.gds_format_decimal(invoiceNetAmount_)
        if self.invoiceNetAmountHUF is not None:
            invoiceNetAmountHUF_ = self.invoiceNetAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceNetAmountHUF').text = self.gds_format_decimal(invoiceNetAmountHUF_)
        if self.invoiceVatAmount is not None:
            invoiceVatAmount_ = self.invoiceVatAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceVatAmount').text = self.gds_format_decimal(invoiceVatAmount_)
        if self.invoiceVatAmountHUF is not None:
            invoiceVatAmountHUF_ = self.invoiceVatAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}invoiceVatAmountHUF').text = self.gds_format_decimal(invoiceVatAmountHUF_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SummaryNormalType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('summaryByVatRate=[\n')
        level += 1
        for summaryByVatRate_ in self.summaryByVatRate:
            showIndent(outfile, level)
            outfile.write('model_.SummaryByVatRateType(\n')
            summaryByVatRate_.exportLiteral(outfile, level, name_='SummaryByVatRateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.invoiceNetAmount is not None:
            showIndent(outfile, level)
            outfile.write('invoiceNetAmount=%f,\n' % self.invoiceNetAmount)
        if self.invoiceNetAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('invoiceNetAmountHUF=%f,\n' % self.invoiceNetAmountHUF)
        if self.invoiceVatAmount is not None:
            showIndent(outfile, level)
            outfile.write('invoiceVatAmount=%f,\n' % self.invoiceVatAmount)
        if self.invoiceVatAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('invoiceVatAmountHUF=%f,\n' % self.invoiceVatAmountHUF)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'summaryByVatRate':
            obj_ = SummaryByVatRateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.summaryByVatRate.append(obj_)
            obj_.original_tagname_ = 'summaryByVatRate'
        elif nodeName_ == 'invoiceNetAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'invoiceNetAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'invoiceNetAmount')
            self.invoiceNetAmount = fval_
            self.invoiceNetAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.invoiceNetAmount)
        elif nodeName_ == 'invoiceNetAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'invoiceNetAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'invoiceNetAmountHUF')
            self.invoiceNetAmountHUF = fval_
            self.invoiceNetAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.invoiceNetAmountHUF)
        elif nodeName_ == 'invoiceVatAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'invoiceVatAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'invoiceVatAmount')
            self.invoiceVatAmount = fval_
            self.invoiceVatAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.invoiceVatAmount)
        elif nodeName_ == 'invoiceVatAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'invoiceVatAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'invoiceVatAmountHUF')
            self.invoiceVatAmountHUF = fval_
            self.invoiceVatAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.invoiceVatAmountHUF)
# end class SummaryNormalType


class SummarySimplifiedType(GeneratedsSuper):
    """SummarySimplifiedType -- Egyszer
    ű
    s
    í
    tett sz
    á
    mla
    ö
    sszes
    í
    t
    é
    s
    Calculation of simplified invoice totals
    vatRate -- Ad
    ó
    m
    é
    rt
    é
    k vagy ad
    ó
    mentess
    é
    g jel
    ö
    l
    é
    se
    Marking the tax rate or the fact of tax exemption
    vatContentGrossAmount -- Az adott ad
    ó
    tartalomhoz tartoz
    ó
    é
    rt
    é
    kes
    í
    t
    é
    s vagy szolg
    á
    ltat
    á
    sny
    ú
    jt
    á
    s brutt
    ó
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben
    The gross amount of the sale or service for the given tax amount in the currency of the invoice
    vatContentGrossAmountHUF -- Az adott ad
    ó
    tartalomhoz tartoz
    ó
    é
    rt
    é
    kes
    í
    t
    é
    s vagy szolg
    á
    ltat
    á
    sny
    ú
    jt
    á
    s brutt
    ó
    ö
    sszege forintban
    The gross amount of the sale or service for the given tax amount in HUF

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vatRate=None, vatContentGrossAmount=None, vatContentGrossAmountHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vatRate = vatRate
        self.vatRate_nsprefix_ = None
        self.vatContentGrossAmount = vatContentGrossAmount
        self.validate_MonetaryType(self.vatContentGrossAmount)
        self.vatContentGrossAmount_nsprefix_ = "base"
        self.vatContentGrossAmountHUF = vatContentGrossAmountHUF
        self.validate_MonetaryType(self.vatContentGrossAmountHUF)
        self.vatContentGrossAmountHUF_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SummarySimplifiedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SummarySimplifiedType.subclass:
            return SummarySimplifiedType.subclass(*args_, **kwargs_)
        else:
            return SummarySimplifiedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vatRate(self):
        return self.vatRate
    def set_vatRate(self, vatRate):
        self.vatRate = vatRate
    def get_vatContentGrossAmount(self):
        return self.vatContentGrossAmount
    def set_vatContentGrossAmount(self, vatContentGrossAmount):
        self.vatContentGrossAmount = vatContentGrossAmount
    def get_vatContentGrossAmountHUF(self):
        return self.vatContentGrossAmountHUF
    def set_vatContentGrossAmountHUF(self, vatContentGrossAmountHUF):
        self.vatContentGrossAmountHUF = vatContentGrossAmountHUF
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.vatRate is not None or
            self.vatContentGrossAmount is not None or
            self.vatContentGrossAmountHUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='SummarySimplifiedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SummarySimplifiedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SummarySimplifiedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SummarySimplifiedType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SummarySimplifiedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SummarySimplifiedType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='SummarySimplifiedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vatRate is not None:
            namespaceprefix_ = self.vatRate_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRate_nsprefix_) else ''
            self.vatRate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vatRate', pretty_print=pretty_print)
        if self.vatContentGrossAmount is not None:
            namespaceprefix_ = self.vatContentGrossAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.vatContentGrossAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatContentGrossAmount>%s</%svatContentGrossAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatContentGrossAmount, input_name='vatContentGrossAmount'), namespaceprefix_ , eol_))
        if self.vatContentGrossAmountHUF is not None:
            namespaceprefix_ = self.vatContentGrossAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.vatContentGrossAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatContentGrossAmountHUF>%s</%svatContentGrossAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatContentGrossAmountHUF, input_name='vatContentGrossAmountHUF'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='SummarySimplifiedType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.vatRate is not None:
            vatRate_ = self.vatRate
            vatRate_.to_etree(element, name_='vatRate', mapping_=mapping_, nsmap_=nsmap_)
        if self.vatContentGrossAmount is not None:
            vatContentGrossAmount_ = self.vatContentGrossAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatContentGrossAmount').text = self.gds_format_decimal(vatContentGrossAmount_)
        if self.vatContentGrossAmountHUF is not None:
            vatContentGrossAmountHUF_ = self.vatContentGrossAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatContentGrossAmountHUF').text = self.gds_format_decimal(vatContentGrossAmountHUF_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SummarySimplifiedType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.vatRate is not None:
            showIndent(outfile, level)
            outfile.write('vatRate=model_.VatRateType(\n')
            self.vatRate.exportLiteral(outfile, level, name_='vatRate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vatContentGrossAmount is not None:
            showIndent(outfile, level)
            outfile.write('vatContentGrossAmount=%f,\n' % self.vatContentGrossAmount)
        if self.vatContentGrossAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('vatContentGrossAmountHUF=%f,\n' % self.vatContentGrossAmountHUF)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vatRate':
            obj_ = VatRateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vatRate = obj_
            obj_.original_tagname_ = 'vatRate'
        elif nodeName_ == 'vatContentGrossAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatContentGrossAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatContentGrossAmount')
            self.vatContentGrossAmount = fval_
            self.vatContentGrossAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.vatContentGrossAmount)
        elif nodeName_ == 'vatContentGrossAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatContentGrossAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatContentGrossAmountHUF')
            self.vatContentGrossAmountHUF = fval_
            self.vatContentGrossAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.vatContentGrossAmountHUF)
# end class SummarySimplifiedType


class SummaryType(GeneratedsSuper):
    """SummaryType -- Sz
    á
    mla
    ö
    sszes
    í
    t
    é
    s adatai
    Data of calculation of invoice totals
    summaryNormal -- Sz
    á
    mla
    ö
    sszes
    í
    t
    é
    s (nem egyszer
    ű
    s
    í
    tett sz
    á
    mla eset
    é
    n)
    Calculation of invoice totals (not simplified invoice)
    summarySimplified -- Egyszer
    ű
    s
    í
    tett sz
    á
    mla
    ö
    sszes
    í
    t
    é
    s
    Calculation of simplified invoice totals
    summaryGrossData -- A sz
    á
    mla
    ö
    sszes
    í
    t
    ő
    brutt
    ó
    adatai
    Gross data of the invoice summary

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, summaryNormal=None, summarySimplified=None, summaryGrossData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.summaryNormal = summaryNormal
        self.summaryNormal_nsprefix_ = None
        if summarySimplified is None:
            self.summarySimplified = []
        else:
            self.summarySimplified = summarySimplified
        self.summarySimplified_nsprefix_ = None
        self.summaryGrossData = summaryGrossData
        self.summaryGrossData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SummaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SummaryType.subclass:
            return SummaryType.subclass(*args_, **kwargs_)
        else:
            return SummaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_summaryNormal(self):
        return self.summaryNormal
    def set_summaryNormal(self, summaryNormal):
        self.summaryNormal = summaryNormal
    def get_summarySimplified(self):
        return self.summarySimplified
    def set_summarySimplified(self, summarySimplified):
        self.summarySimplified = summarySimplified
    def add_summarySimplified(self, value):
        self.summarySimplified.append(value)
    def insert_summarySimplified_at(self, index, value):
        self.summarySimplified.insert(index, value)
    def replace_summarySimplified_at(self, index, value):
        self.summarySimplified[index] = value
    def get_summaryGrossData(self):
        return self.summaryGrossData
    def set_summaryGrossData(self, summaryGrossData):
        self.summaryGrossData = summaryGrossData
    def _hasContent(self):
        if (
            self.summaryNormal is not None or
            self.summarySimplified or
            self.summaryGrossData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='SummaryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SummaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SummaryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SummaryType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SummaryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SummaryType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='SummaryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.summaryNormal is not None:
            namespaceprefix_ = self.summaryNormal_nsprefix_ + ':' if (UseCapturedNS_ and self.summaryNormal_nsprefix_) else ''
            self.summaryNormal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='summaryNormal', pretty_print=pretty_print)
        for summarySimplified_ in self.summarySimplified:
            namespaceprefix_ = self.summarySimplified_nsprefix_ + ':' if (UseCapturedNS_ and self.summarySimplified_nsprefix_) else ''
            summarySimplified_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='summarySimplified', pretty_print=pretty_print)
        if self.summaryGrossData is not None:
            namespaceprefix_ = self.summaryGrossData_nsprefix_ + ':' if (UseCapturedNS_ and self.summaryGrossData_nsprefix_) else ''
            self.summaryGrossData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='summaryGrossData', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SummaryType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.summaryNormal is not None:
            summaryNormal_ = self.summaryNormal
            summaryNormal_.to_etree(element, name_='summaryNormal', mapping_=mapping_, nsmap_=nsmap_)
        for summarySimplified_ in self.summarySimplified:
            summarySimplified_.to_etree(element, name_='summarySimplified', mapping_=mapping_, nsmap_=nsmap_)
        if self.summaryGrossData is not None:
            summaryGrossData_ = self.summaryGrossData
            summaryGrossData_.to_etree(element, name_='summaryGrossData', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SummaryType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.summaryNormal is not None:
            showIndent(outfile, level)
            outfile.write('summaryNormal=model_.SummaryNormalType(\n')
            self.summaryNormal.exportLiteral(outfile, level, name_='summaryNormal')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('summarySimplified=[\n')
        level += 1
        for summarySimplified_ in self.summarySimplified:
            showIndent(outfile, level)
            outfile.write('model_.SummarySimplifiedType(\n')
            summarySimplified_.exportLiteral(outfile, level, name_='SummarySimplifiedType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.summaryGrossData is not None:
            showIndent(outfile, level)
            outfile.write('summaryGrossData=model_.SummaryGrossDataType(\n')
            self.summaryGrossData.exportLiteral(outfile, level, name_='summaryGrossData')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'summaryNormal':
            obj_ = SummaryNormalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.summaryNormal = obj_
            obj_.original_tagname_ = 'summaryNormal'
        elif nodeName_ == 'summarySimplified':
            obj_ = SummarySimplifiedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.summarySimplified.append(obj_)
            obj_.original_tagname_ = 'summarySimplified'
        elif nodeName_ == 'summaryGrossData':
            obj_ = SummaryGrossDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.summaryGrossData = obj_
            obj_.original_tagname_ = 'summaryGrossData'
# end class SummaryType


class SupplierCompanyCodesType(GeneratedsSuper):
    """SupplierCompanyCodesType -- Az elad
    ó
    v
    á
    llalati k
    ó
    djai
    Company codes of the supplier
    supplierCompanyCode -- Az elad
    ó
    v
    á
    llalati k
    ó
    dja
    Company code of the supplier

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, supplierCompanyCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if supplierCompanyCode is None:
            self.supplierCompanyCode = []
        else:
            self.supplierCompanyCode = supplierCompanyCode
        self.supplierCompanyCode_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplierCompanyCodesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplierCompanyCodesType.subclass:
            return SupplierCompanyCodesType.subclass(*args_, **kwargs_)
        else:
            return SupplierCompanyCodesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_supplierCompanyCode(self):
        return self.supplierCompanyCode
    def set_supplierCompanyCode(self, supplierCompanyCode):
        self.supplierCompanyCode = supplierCompanyCode
    def add_supplierCompanyCode(self, value):
        self.supplierCompanyCode.append(value)
    def insert_supplierCompanyCode_at(self, index, value):
        self.supplierCompanyCode.insert(index, value)
    def replace_supplierCompanyCode_at(self, index, value):
        self.supplierCompanyCode[index] = value
    def validate_SimpleText100NotBlankType(self, value):
        result = True
        # Validate type SimpleText100NotBlankType, a restriction on AtomicStringType100.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText100NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText100NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText100NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText100NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText100NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.supplierCompanyCode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='SupplierCompanyCodesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupplierCompanyCodesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupplierCompanyCodesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplierCompanyCodesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupplierCompanyCodesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupplierCompanyCodesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='SupplierCompanyCodesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for supplierCompanyCode_ in self.supplierCompanyCode:
            namespaceprefix_ = self.supplierCompanyCode_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierCompanyCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssupplierCompanyCode>%s</%ssupplierCompanyCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(supplierCompanyCode_), input_name='supplierCompanyCode')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='SupplierCompanyCodesType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        for supplierCompanyCode_ in self.supplierCompanyCode:
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}supplierCompanyCode').text = self.gds_format_string(supplierCompanyCode_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SupplierCompanyCodesType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('supplierCompanyCode=[\n')
        level += 1
        for supplierCompanyCode_ in self.supplierCompanyCode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(supplierCompanyCode_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'supplierCompanyCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'supplierCompanyCode')
            value_ = self.gds_validate_string(value_, node, 'supplierCompanyCode')
            self.supplierCompanyCode.append(value_)
            self.supplierCompanyCode_nsprefix_ = child_.prefix
            # validate type SimpleText100NotBlankType
            self.validate_SimpleText100NotBlankType(self.supplierCompanyCode[-1])
# end class SupplierCompanyCodesType


class SupplierInfoType(GeneratedsSuper):
    """SupplierInfoType -- A sz
    á
    ll
    í
    t
    ó
    (elad
    ó
    ) adatai
    Invoice supplier (seller) data
    supplierTaxNumber -- Belf
    ö
    ldi ad
    ó
    sz
    á
    m vagy csoportazonos
    í
    t
    ó
    sz
    á
    m
    Tax number or group identification number
    groupMemberTaxNumber -- Csoport tag ad
    ó
    sz
    á
    ma, ha a term
    é
    kbeszerz
    é
    s vagy szolg
    á
    ltat
    á
    s ny
    ú
    jt
    á
    sa csoportazonos
    í
    t
    ó
    sz
    á
    m alatt t
    ö
    rt
    é
    nt
    Tax number of group member, when the supply of goods or services is done under group identification number
    communityVatNumber -- K
    ö
    z
    ö
    ss
    é
    gi ad
    ó
    sz
    á
    m
    Community tax number
    supplierName -- Az elad
    ó
    (sz
    á
    ll
    í
    t
    ó
    ) neve
    Name of the seller (supplier)
    supplierAddress -- Az elad
    ó
    (sz
    á
    ll
    í
    t
    ó
    ) c
    í
    me
    Address of the seller (supplier)
    supplierBankAccountNumber -- Az elad
    ó
    (sz
    á
    ll
    í
    t
    ó
    ) banksz
    á
    mlasz
    á
    ma
    Bank account number of the seller (supplier)
    individualExemption -- É
    rt
    é
    ke true, amennyiben az elad
    ó
    (sz
    á
    ll
    í
    t
    ó
    ) alanyi
    Á
    FA mentes
    Value is true if the seller (supplier) is individually exempted from VAT
    exciseLicenceNum -- Az elad
    ó
    ad
    ó
    rakt
    á
    ri enged
    é
    ly
    é
    nek vagy j
    ö
    ved
    é
    ki enged
    é
    ly
    é
    nek sz
    á
    ma (2016.
    é
    vi LXVIII. tv.)
    Number of supplier
    ’
    s tax warehouse license or excise license (Act LXVIII of 2016)

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, supplierTaxNumber=None, groupMemberTaxNumber=None, communityVatNumber=None, supplierName=None, supplierAddress=None, supplierBankAccountNumber=None, individualExemption=None, exciseLicenceNum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.supplierTaxNumber = supplierTaxNumber
        self.supplierTaxNumber_nsprefix_ = "base"
        self.groupMemberTaxNumber = groupMemberTaxNumber
        self.groupMemberTaxNumber_nsprefix_ = "base"
        self.communityVatNumber = communityVatNumber
        self.validate_CommunityVatNumberType(self.communityVatNumber)
        self.communityVatNumber_nsprefix_ = "common"
        self.supplierName = supplierName
        self.validate_SimpleText512NotBlankType(self.supplierName)
        self.supplierName_nsprefix_ = "common"
        self.supplierAddress = supplierAddress
        self.supplierAddress_nsprefix_ = "base"
        self.supplierBankAccountNumber = supplierBankAccountNumber
        self.validate_BankAccountNumberType(self.supplierBankAccountNumber)
        self.supplierBankAccountNumber_nsprefix_ = "common"
        self.individualExemption = individualExemption
        self.individualExemption_nsprefix_ = "xs"
        self.exciseLicenceNum = exciseLicenceNum
        self.validate_SimpleText50NotBlankType(self.exciseLicenceNum)
        self.exciseLicenceNum_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplierInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplierInfoType.subclass:
            return SupplierInfoType.subclass(*args_, **kwargs_)
        else:
            return SupplierInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_supplierTaxNumber(self):
        return self.supplierTaxNumber
    def set_supplierTaxNumber(self, supplierTaxNumber):
        self.supplierTaxNumber = supplierTaxNumber
    def get_groupMemberTaxNumber(self):
        return self.groupMemberTaxNumber
    def set_groupMemberTaxNumber(self, groupMemberTaxNumber):
        self.groupMemberTaxNumber = groupMemberTaxNumber
    def get_communityVatNumber(self):
        return self.communityVatNumber
    def set_communityVatNumber(self, communityVatNumber):
        self.communityVatNumber = communityVatNumber
    def get_supplierName(self):
        return self.supplierName
    def set_supplierName(self, supplierName):
        self.supplierName = supplierName
    def get_supplierAddress(self):
        return self.supplierAddress
    def set_supplierAddress(self, supplierAddress):
        self.supplierAddress = supplierAddress
    def get_supplierBankAccountNumber(self):
        return self.supplierBankAccountNumber
    def set_supplierBankAccountNumber(self, supplierBankAccountNumber):
        self.supplierBankAccountNumber = supplierBankAccountNumber
    def get_individualExemption(self):
        return self.individualExemption
    def set_individualExemption(self, individualExemption):
        self.individualExemption = individualExemption
    def get_exciseLicenceNum(self):
        return self.exciseLicenceNum
    def set_exciseLicenceNum(self, exciseLicenceNum):
        self.exciseLicenceNum = exciseLicenceNum
    def validate_CommunityVatNumberType(self, value):
        result = True
        # Validate type CommunityVatNumberType, a restriction on AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CommunityVatNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CommunityVatNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on CommunityVatNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on CommunityVatNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_CommunityVatNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CommunityVatNumberType_patterns_, ))
                result = False
        return result
    validate_CommunityVatNumberType_patterns_ = [['^([A-Z]{2}[0-9A-Z]{2,13})$']]
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_BankAccountNumberType(self, value):
        result = True
        # Validate type BankAccountNumberType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 34:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on BankAccountNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on BankAccountNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on BankAccountNumberType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on BankAccountNumberType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_BankAccountNumberType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_BankAccountNumberType_patterns_, ))
                result = False
        return result
    validate_BankAccountNumberType_patterns_ = [['^([0-9]{8}[-][0-9]{8}[-][0-9]{8}|[0-9]{8}[-][0-9]{8}|[A-Z]{2}[0-9]{2}[0-9A-Za-z]{11,30})$']]
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.supplierTaxNumber is not None or
            self.groupMemberTaxNumber is not None or
            self.communityVatNumber is not None or
            self.supplierName is not None or
            self.supplierAddress is not None or
            self.supplierBankAccountNumber is not None or
            self.individualExemption is not None or
            self.exciseLicenceNum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='SupplierInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupplierInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupplierInfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplierInfoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupplierInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupplierInfoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='SupplierInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.supplierTaxNumber is not None:
            namespaceprefix_ = self.supplierTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierTaxNumber_nsprefix_) else ''
            self.supplierTaxNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supplierTaxNumber', pretty_print=pretty_print)
        if self.groupMemberTaxNumber is not None:
            namespaceprefix_ = self.groupMemberTaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.groupMemberTaxNumber_nsprefix_) else ''
            self.groupMemberTaxNumber.export(outfile, level, namespaceprefix_, namespacedef_='', name_='groupMemberTaxNumber', pretty_print=pretty_print)
        if self.communityVatNumber is not None:
            namespaceprefix_ = self.communityVatNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.communityVatNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunityVatNumber>%s</%scommunityVatNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.communityVatNumber), input_name='communityVatNumber')), namespaceprefix_ , eol_))
        if self.supplierName is not None:
            namespaceprefix_ = self.supplierName_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssupplierName>%s</%ssupplierName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.supplierName), input_name='supplierName')), namespaceprefix_ , eol_))
        if self.supplierAddress is not None:
            namespaceprefix_ = self.supplierAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierAddress_nsprefix_) else ''
            self.supplierAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='supplierAddress', pretty_print=pretty_print)
        if self.supplierBankAccountNumber is not None:
            namespaceprefix_ = self.supplierBankAccountNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.supplierBankAccountNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssupplierBankAccountNumber>%s</%ssupplierBankAccountNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.supplierBankAccountNumber), input_name='supplierBankAccountNumber')), namespaceprefix_ , eol_))
        if self.individualExemption is not None:
            namespaceprefix_ = self.individualExemption_nsprefix_ + ':' if (UseCapturedNS_ and self.individualExemption_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindividualExemption>%s</%sindividualExemption>%s' % (namespaceprefix_ , self.gds_format_boolean(self.individualExemption, input_name='individualExemption'), namespaceprefix_ , eol_))
        if self.exciseLicenceNum is not None:
            namespaceprefix_ = self.exciseLicenceNum_nsprefix_ + ':' if (UseCapturedNS_ and self.exciseLicenceNum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexciseLicenceNum>%s</%sexciseLicenceNum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.exciseLicenceNum), input_name='exciseLicenceNum')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='SupplierInfoType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.supplierTaxNumber is not None:
            supplierTaxNumber_ = self.supplierTaxNumber
            supplierTaxNumber_.to_etree(element, name_='supplierTaxNumber', mapping_=mapping_, nsmap_=nsmap_)
        if self.groupMemberTaxNumber is not None:
            groupMemberTaxNumber_ = self.groupMemberTaxNumber
            groupMemberTaxNumber_.to_etree(element, name_='groupMemberTaxNumber', mapping_=mapping_, nsmap_=nsmap_)
        if self.communityVatNumber is not None:
            communityVatNumber_ = self.communityVatNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}communityVatNumber').text = self.gds_format_string(communityVatNumber_)
        if self.supplierName is not None:
            supplierName_ = self.supplierName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}supplierName').text = self.gds_format_string(supplierName_)
        if self.supplierAddress is not None:
            supplierAddress_ = self.supplierAddress
            supplierAddress_.to_etree(element, name_='supplierAddress', mapping_=mapping_, nsmap_=nsmap_)
        if self.supplierBankAccountNumber is not None:
            supplierBankAccountNumber_ = self.supplierBankAccountNumber
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}supplierBankAccountNumber').text = self.gds_format_string(supplierBankAccountNumber_)
        if self.individualExemption is not None:
            individualExemption_ = self.individualExemption
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}individualExemption').text = self.gds_format_boolean(individualExemption_)
        if self.exciseLicenceNum is not None:
            exciseLicenceNum_ = self.exciseLicenceNum
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}exciseLicenceNum').text = self.gds_format_string(exciseLicenceNum_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SupplierInfoType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.supplierTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('supplierTaxNumber=model_.TaxNumberType(\n')
            self.supplierTaxNumber.exportLiteral(outfile, level, name_='supplierTaxNumber')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.groupMemberTaxNumber is not None:
            showIndent(outfile, level)
            outfile.write('groupMemberTaxNumber=model_.TaxNumberType(\n')
            self.groupMemberTaxNumber.exportLiteral(outfile, level, name_='groupMemberTaxNumber')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.communityVatNumber is not None:
            showIndent(outfile, level)
            outfile.write('communityVatNumber=%s,\n' % self.gds_encode(quote_python(self.communityVatNumber)))
        if self.supplierName is not None:
            showIndent(outfile, level)
            outfile.write('supplierName=%s,\n' % self.gds_encode(quote_python(self.supplierName)))
        if self.supplierAddress is not None:
            showIndent(outfile, level)
            outfile.write('supplierAddress=model_.AddressType(\n')
            self.supplierAddress.exportLiteral(outfile, level, name_='supplierAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.supplierBankAccountNumber is not None:
            showIndent(outfile, level)
            outfile.write('supplierBankAccountNumber=%s,\n' % self.gds_encode(quote_python(self.supplierBankAccountNumber)))
        if self.individualExemption is not None:
            showIndent(outfile, level)
            outfile.write('individualExemption=%s,\n' % self.individualExemption)
        if self.exciseLicenceNum is not None:
            showIndent(outfile, level)
            outfile.write('exciseLicenceNum=%s,\n' % self.gds_encode(quote_python(self.exciseLicenceNum)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'supplierTaxNumber':
            class_obj_ = self.get_class_obj_(child_, TaxNumberType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supplierTaxNumber = obj_
            obj_.original_tagname_ = 'supplierTaxNumber'
        elif nodeName_ == 'groupMemberTaxNumber':
            class_obj_ = self.get_class_obj_(child_, TaxNumberType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groupMemberTaxNumber = obj_
            obj_.original_tagname_ = 'groupMemberTaxNumber'
        elif nodeName_ == 'communityVatNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'communityVatNumber')
            value_ = self.gds_validate_string(value_, node, 'communityVatNumber')
            self.communityVatNumber = value_
            self.communityVatNumber_nsprefix_ = child_.prefix
            # validate type CommunityVatNumberType
            self.validate_CommunityVatNumberType(self.communityVatNumber)
        elif nodeName_ == 'supplierName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'supplierName')
            value_ = self.gds_validate_string(value_, node, 'supplierName')
            self.supplierName = value_
            self.supplierName_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.supplierName)
        elif nodeName_ == 'supplierAddress':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.supplierAddress = obj_
            obj_.original_tagname_ = 'supplierAddress'
        elif nodeName_ == 'supplierBankAccountNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'supplierBankAccountNumber')
            value_ = self.gds_validate_string(value_, node, 'supplierBankAccountNumber')
            self.supplierBankAccountNumber = value_
            self.supplierBankAccountNumber_nsprefix_ = child_.prefix
            # validate type BankAccountNumberType
            self.validate_BankAccountNumberType(self.supplierBankAccountNumber)
        elif nodeName_ == 'individualExemption':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'individualExemption')
            ival_ = self.gds_validate_boolean(ival_, node, 'individualExemption')
            self.individualExemption = ival_
            self.individualExemption_nsprefix_ = child_.prefix
        elif nodeName_ == 'exciseLicenceNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'exciseLicenceNum')
            value_ = self.gds_validate_string(value_, node, 'exciseLicenceNum')
            self.exciseLicenceNum = value_
            self.exciseLicenceNum_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.exciseLicenceNum)
# end class SupplierInfoType


class VatAmountMismatchType(GeneratedsSuper):
    """VatAmountMismatchType -- Ad
    ó
    alap
    é
    s felsz
    á
    m
    í
    tott ad
    ó
    elt
    é
    r
    é
    s
    é
    nek adatai
    Data of mismatching tax base and levied tax
    vatRate -- Ad
    ó
    m
    é
    rt
    é
    k, ad
    ó
    tartalom
    VAT rate, VAT content
    case -- Az eset le
    í
    r
    á
    sa k
    ó
    ddal
    Case notation with code

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vatRate=None, case=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vatRate = vatRate
        self.validate_RateType(self.vatRate)
        self.vatRate_nsprefix_ = None
        self.case = case
        self.validate_SimpleText50NotBlankType(self.case)
        self.case_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VatAmountMismatchType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VatAmountMismatchType.subclass:
            return VatAmountMismatchType.subclass(*args_, **kwargs_)
        else:
            return VatAmountMismatchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vatRate(self):
        return self.vatRate
    def set_vatRate(self, vatRate):
        self.vatRate = vatRate
    def get_case(self):
        return self.case
    def set_case(self, case):
        self.case = case
    def validate_RateType(self, value):
        result = True
        # Validate type RateType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on RateType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on RateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on RateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText50NotBlankType(self, value):
        result = True
        # Validate type SimpleText50NotBlankType, a restriction on AtomicStringType50.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText50NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText50NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText50NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText50NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText50NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.vatRate is not None or
            self.case is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='VatAmountMismatchType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VatAmountMismatchType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VatAmountMismatchType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VatAmountMismatchType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VatAmountMismatchType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VatAmountMismatchType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='VatAmountMismatchType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vatRate is not None:
            namespaceprefix_ = self.vatRate_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatRate>%s</%svatRate>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatRate, input_name='vatRate'), namespaceprefix_ , eol_))
        if self.case is not None:
            namespaceprefix_ = self.case_nsprefix_ + ':' if (UseCapturedNS_ and self.case_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scase>%s</%scase>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.case), input_name='case')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='VatAmountMismatchType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.vatRate is not None:
            vatRate_ = self.vatRate
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatRate').text = self.gds_format_decimal(vatRate_)
        if self.case is not None:
            case_ = self.case
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}case').text = self.gds_format_string(case_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='VatAmountMismatchType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.vatRate is not None:
            showIndent(outfile, level)
            outfile.write('vatRate=%f,\n' % self.vatRate)
        if self.case is not None:
            showIndent(outfile, level)
            outfile.write('case=%s,\n' % self.gds_encode(quote_python(self.case)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vatRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatRate')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatRate')
            self.vatRate = fval_
            self.vatRate_nsprefix_ = child_.prefix
            # validate type RateType
            self.validate_RateType(self.vatRate)
        elif nodeName_ == 'case':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'case')
            value_ = self.gds_validate_string(value_, node, 'case')
            self.case = value_
            self.case_nsprefix_ = child_.prefix
            # validate type SimpleText50NotBlankType
            self.validate_SimpleText50NotBlankType(self.case)
# end class VatAmountMismatchType


class VatRateGrossDataType(GeneratedsSuper):
    """VatRateGrossDataType -- Adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    brutt
    ó
    adatok
    Gross data of given tax rate
    vatRateGrossAmount -- Az adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    é
    rt
    é
    kes
    í
    t
    é
    s vagy szolg
    á
    ltat
    á
    sny
    ú
    jt
    á
    s brutt
    ó
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben
    Gross amount of sales or service delivery under a given tax rate expressed in the currency of the invoice
    vatRateGrossAmountHUF -- Az adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    é
    rt
    é
    kes
    í
    t
    é
    s vagy szolg
    á
    ltat
    á
    sny
    ú
    jt
    á
    s brutt
    ó
    ö
    sszege forintban
    Gross amount of sales or service delivery under a given tax rate expressed in HUF

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vatRateGrossAmount=None, vatRateGrossAmountHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vatRateGrossAmount = vatRateGrossAmount
        self.validate_MonetaryType(self.vatRateGrossAmount)
        self.vatRateGrossAmount_nsprefix_ = "base"
        self.vatRateGrossAmountHUF = vatRateGrossAmountHUF
        self.validate_MonetaryType(self.vatRateGrossAmountHUF)
        self.vatRateGrossAmountHUF_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VatRateGrossDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VatRateGrossDataType.subclass:
            return VatRateGrossDataType.subclass(*args_, **kwargs_)
        else:
            return VatRateGrossDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vatRateGrossAmount(self):
        return self.vatRateGrossAmount
    def set_vatRateGrossAmount(self, vatRateGrossAmount):
        self.vatRateGrossAmount = vatRateGrossAmount
    def get_vatRateGrossAmountHUF(self):
        return self.vatRateGrossAmountHUF
    def set_vatRateGrossAmountHUF(self, vatRateGrossAmountHUF):
        self.vatRateGrossAmountHUF = vatRateGrossAmountHUF
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.vatRateGrossAmount is not None or
            self.vatRateGrossAmountHUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='VatRateGrossDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VatRateGrossDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VatRateGrossDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VatRateGrossDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VatRateGrossDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VatRateGrossDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='VatRateGrossDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vatRateGrossAmount is not None:
            namespaceprefix_ = self.vatRateGrossAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRateGrossAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatRateGrossAmount>%s</%svatRateGrossAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatRateGrossAmount, input_name='vatRateGrossAmount'), namespaceprefix_ , eol_))
        if self.vatRateGrossAmountHUF is not None:
            namespaceprefix_ = self.vatRateGrossAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRateGrossAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatRateGrossAmountHUF>%s</%svatRateGrossAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatRateGrossAmountHUF, input_name='vatRateGrossAmountHUF'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='VatRateGrossDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.vatRateGrossAmount is not None:
            vatRateGrossAmount_ = self.vatRateGrossAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatRateGrossAmount').text = self.gds_format_decimal(vatRateGrossAmount_)
        if self.vatRateGrossAmountHUF is not None:
            vatRateGrossAmountHUF_ = self.vatRateGrossAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatRateGrossAmountHUF').text = self.gds_format_decimal(vatRateGrossAmountHUF_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='VatRateGrossDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.vatRateGrossAmount is not None:
            showIndent(outfile, level)
            outfile.write('vatRateGrossAmount=%f,\n' % self.vatRateGrossAmount)
        if self.vatRateGrossAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('vatRateGrossAmountHUF=%f,\n' % self.vatRateGrossAmountHUF)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vatRateGrossAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatRateGrossAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatRateGrossAmount')
            self.vatRateGrossAmount = fval_
            self.vatRateGrossAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.vatRateGrossAmount)
        elif nodeName_ == 'vatRateGrossAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatRateGrossAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatRateGrossAmountHUF')
            self.vatRateGrossAmountHUF = fval_
            self.vatRateGrossAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.vatRateGrossAmountHUF)
# end class VatRateGrossDataType


class VatRateNetDataType(GeneratedsSuper):
    """VatRateNetDataType -- Adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    nett
    ó
    adatok
    Net data of given tax rate
    vatRateNetAmount -- Az adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    é
    rt
    é
    kes
    í
    t
    é
    s vagy szolg
    á
    ltat
    á
    sny
    ú
    jt
    á
    s nett
    ó
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben
    Net amount of sales or service delivery under a given tax rate expressed in the currency of the invoice
    vatRateNetAmountHUF -- Az adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    é
    rt
    é
    kes
    í
    t
    é
    s vagy szolg
    á
    ltat
    á
    sny
    ú
    jt
    á
    s nett
    ó
    ö
    sszege forintban
    Net amount of sales or service delivery under a given tax rate expressed in HUF

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vatRateNetAmount=None, vatRateNetAmountHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vatRateNetAmount = vatRateNetAmount
        self.validate_MonetaryType(self.vatRateNetAmount)
        self.vatRateNetAmount_nsprefix_ = "base"
        self.vatRateNetAmountHUF = vatRateNetAmountHUF
        self.validate_MonetaryType(self.vatRateNetAmountHUF)
        self.vatRateNetAmountHUF_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VatRateNetDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VatRateNetDataType.subclass:
            return VatRateNetDataType.subclass(*args_, **kwargs_)
        else:
            return VatRateNetDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vatRateNetAmount(self):
        return self.vatRateNetAmount
    def set_vatRateNetAmount(self, vatRateNetAmount):
        self.vatRateNetAmount = vatRateNetAmount
    def get_vatRateNetAmountHUF(self):
        return self.vatRateNetAmountHUF
    def set_vatRateNetAmountHUF(self, vatRateNetAmountHUF):
        self.vatRateNetAmountHUF = vatRateNetAmountHUF
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.vatRateNetAmount is not None or
            self.vatRateNetAmountHUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='VatRateNetDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VatRateNetDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VatRateNetDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VatRateNetDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VatRateNetDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VatRateNetDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='VatRateNetDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vatRateNetAmount is not None:
            namespaceprefix_ = self.vatRateNetAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRateNetAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatRateNetAmount>%s</%svatRateNetAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatRateNetAmount, input_name='vatRateNetAmount'), namespaceprefix_ , eol_))
        if self.vatRateNetAmountHUF is not None:
            namespaceprefix_ = self.vatRateNetAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRateNetAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatRateNetAmountHUF>%s</%svatRateNetAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatRateNetAmountHUF, input_name='vatRateNetAmountHUF'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='VatRateNetDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.vatRateNetAmount is not None:
            vatRateNetAmount_ = self.vatRateNetAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatRateNetAmount').text = self.gds_format_decimal(vatRateNetAmount_)
        if self.vatRateNetAmountHUF is not None:
            vatRateNetAmountHUF_ = self.vatRateNetAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatRateNetAmountHUF').text = self.gds_format_decimal(vatRateNetAmountHUF_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='VatRateNetDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.vatRateNetAmount is not None:
            showIndent(outfile, level)
            outfile.write('vatRateNetAmount=%f,\n' % self.vatRateNetAmount)
        if self.vatRateNetAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('vatRateNetAmountHUF=%f,\n' % self.vatRateNetAmountHUF)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vatRateNetAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatRateNetAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatRateNetAmount')
            self.vatRateNetAmount = fval_
            self.vatRateNetAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.vatRateNetAmount)
        elif nodeName_ == 'vatRateNetAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatRateNetAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatRateNetAmountHUF')
            self.vatRateNetAmountHUF = fval_
            self.vatRateNetAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.vatRateNetAmountHUF)
# end class VatRateNetDataType


class VatRateType(GeneratedsSuper):
    """VatRateType -- Az ad
    ó
    m
    é
    rt
    é
    k vagy az ad
    ó
    mentes
    é
    rt
    é
    kes
    í
    t
    é
    s jel
    ö
    l
    é
    se
    Marking tax rate or tax exempt supply
    vatPercentage -- Az alkalmazott ad
    ó
    m
    é
    rt
    é
    ke -
    Á
    FA tv. 169.
    §
    j)
    Applied tax rate - section 169 (j) of the VAT law
    vatContent -- Á
    FA tartalom egyszer
    ű
    s
    í
    tett sz
    á
    mla eset
    é
    n
    VAT content in case of simplified invoice
    vatExemption -- Az ad
    ó
    mentess
    é
    g jel
    ö
    l
    é
    se -
    Á
    FA tv. 169.
    §
    m)
    Marking tax exemption -  section 169 (m) of the VAT law
    vatOutOfScope -- Az
    Á
    FA t
    ö
    rv
    é
    ny hat
    á
    ly
    á
    n k
    í
    v
    ü
    li
    Out of scope of the VAT law
    vatDomesticReverseCharge -- A belf
    ö
    ldi ford
    í
    tott ad
    ó
    z
    á
    s jel
    ö
    l
    é
    se -
    Á
    FA tv. 142.
    §
    Marking the national is reverse charge taxation - section 142 of the VAT law
    marginSchemeIndicator -- K
    ü
    l
    ö
    nb
    ö
    zet szerinti szab
    á
    lyoz
    á
    s jel
    ö
    l
    é
    se -
    Á
    FA tv. 169.
    §
    p) q)
    Marking the margin-scheme taxation as per section 169 (p)(q)
    vatAmountMismatch -- Ad
    ó
    alap
    é
    s felsz
    á
    m
    í
    tott ad
    ó
    elt
    é
    r
    é
    s
    é
    nek esetei
    Different cases of mismatching tax base and levied tax
    noVatCharge -- Nincs felsz
    á
    m
    í
    tott
    á
    fa a 17.
    §
    alapj
    á
    n
    No VAT charged under Section 17

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vatPercentage=None, vatContent=None, vatExemption=None, vatOutOfScope=None, vatDomesticReverseCharge=None, marginSchemeIndicator=None, vatAmountMismatch=None, noVatCharge=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vatPercentage = vatPercentage
        self.validate_RateType(self.vatPercentage)
        self.vatPercentage_nsprefix_ = None
        self.vatContent = vatContent
        self.validate_RateType(self.vatContent)
        self.vatContent_nsprefix_ = None
        self.vatExemption = vatExemption
        self.vatExemption_nsprefix_ = None
        self.vatOutOfScope = vatOutOfScope
        self.vatOutOfScope_nsprefix_ = None
        self.vatDomesticReverseCharge = vatDomesticReverseCharge
        self.vatDomesticReverseCharge_nsprefix_ = "xs"
        self.marginSchemeIndicator = marginSchemeIndicator
        self.validate_MarginSchemeType(self.marginSchemeIndicator)
        self.marginSchemeIndicator_nsprefix_ = None
        self.vatAmountMismatch = vatAmountMismatch
        self.vatAmountMismatch_nsprefix_ = None
        self.noVatCharge = noVatCharge
        self.noVatCharge_nsprefix_ = "xs"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VatRateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VatRateType.subclass:
            return VatRateType.subclass(*args_, **kwargs_)
        else:
            return VatRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vatPercentage(self):
        return self.vatPercentage
    def set_vatPercentage(self, vatPercentage):
        self.vatPercentage = vatPercentage
    def get_vatContent(self):
        return self.vatContent
    def set_vatContent(self, vatContent):
        self.vatContent = vatContent
    def get_vatExemption(self):
        return self.vatExemption
    def set_vatExemption(self, vatExemption):
        self.vatExemption = vatExemption
    def get_vatOutOfScope(self):
        return self.vatOutOfScope
    def set_vatOutOfScope(self, vatOutOfScope):
        self.vatOutOfScope = vatOutOfScope
    def get_vatDomesticReverseCharge(self):
        return self.vatDomesticReverseCharge
    def set_vatDomesticReverseCharge(self, vatDomesticReverseCharge):
        self.vatDomesticReverseCharge = vatDomesticReverseCharge
    def get_marginSchemeIndicator(self):
        return self.marginSchemeIndicator
    def set_marginSchemeIndicator(self, marginSchemeIndicator):
        self.marginSchemeIndicator = marginSchemeIndicator
    def get_vatAmountMismatch(self):
        return self.vatAmountMismatch
    def set_vatAmountMismatch(self, vatAmountMismatch):
        self.vatAmountMismatch = vatAmountMismatch
    def get_noVatCharge(self):
        return self.noVatCharge
    def set_noVatCharge(self, noVatCharge):
        self.noVatCharge = noVatCharge
    def validate_RateType(self, value):
        result = True
        # Validate type RateType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on RateType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on RateType' % {"value": value, "lineno": lineno} )
                result = False
            if len(str(value)) >= 5:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on RateType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_MarginSchemeType(self, value):
        result = True
        # Validate type MarginSchemeType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['TRAVEL_AGENCY', 'SECOND_HAND', 'ARTWORK', 'ANTIQUES']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MarginSchemeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on MarginSchemeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on MarginSchemeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.vatPercentage is not None or
            self.vatContent is not None or
            self.vatExemption is not None or
            self.vatOutOfScope is not None or
            self.vatDomesticReverseCharge is not None or
            self.marginSchemeIndicator is not None or
            self.vatAmountMismatch is not None or
            self.noVatCharge is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='VatRateType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VatRateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VatRateType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VatRateType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VatRateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VatRateType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='VatRateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vatPercentage is not None:
            namespaceprefix_ = self.vatPercentage_nsprefix_ + ':' if (UseCapturedNS_ and self.vatPercentage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatPercentage>%s</%svatPercentage>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatPercentage, input_name='vatPercentage'), namespaceprefix_ , eol_))
        if self.vatContent is not None:
            namespaceprefix_ = self.vatContent_nsprefix_ + ':' if (UseCapturedNS_ and self.vatContent_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatContent>%s</%svatContent>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatContent, input_name='vatContent'), namespaceprefix_ , eol_))
        if self.vatExemption is not None:
            namespaceprefix_ = self.vatExemption_nsprefix_ + ':' if (UseCapturedNS_ and self.vatExemption_nsprefix_) else ''
            self.vatExemption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vatExemption', pretty_print=pretty_print)
        if self.vatOutOfScope is not None:
            namespaceprefix_ = self.vatOutOfScope_nsprefix_ + ':' if (UseCapturedNS_ and self.vatOutOfScope_nsprefix_) else ''
            self.vatOutOfScope.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vatOutOfScope', pretty_print=pretty_print)
        if self.vatDomesticReverseCharge is not None:
            namespaceprefix_ = self.vatDomesticReverseCharge_nsprefix_ + ':' if (UseCapturedNS_ and self.vatDomesticReverseCharge_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatDomesticReverseCharge>%s</%svatDomesticReverseCharge>%s' % (namespaceprefix_ , self.gds_format_boolean(self.vatDomesticReverseCharge, input_name='vatDomesticReverseCharge'), namespaceprefix_ , eol_))
        if self.marginSchemeIndicator is not None:
            namespaceprefix_ = self.marginSchemeIndicator_nsprefix_ + ':' if (UseCapturedNS_ and self.marginSchemeIndicator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smarginSchemeIndicator>%s</%smarginSchemeIndicator>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.marginSchemeIndicator), input_name='marginSchemeIndicator')), namespaceprefix_ , eol_))
        if self.vatAmountMismatch is not None:
            namespaceprefix_ = self.vatAmountMismatch_nsprefix_ + ':' if (UseCapturedNS_ and self.vatAmountMismatch_nsprefix_) else ''
            self.vatAmountMismatch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vatAmountMismatch', pretty_print=pretty_print)
        if self.noVatCharge is not None:
            namespaceprefix_ = self.noVatCharge_nsprefix_ + ':' if (UseCapturedNS_ and self.noVatCharge_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snoVatCharge>%s</%snoVatCharge>%s' % (namespaceprefix_ , self.gds_format_boolean(self.noVatCharge, input_name='noVatCharge'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='VatRateType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.vatPercentage is not None:
            vatPercentage_ = self.vatPercentage
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatPercentage').text = self.gds_format_decimal(vatPercentage_)
        if self.vatContent is not None:
            vatContent_ = self.vatContent
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatContent').text = self.gds_format_decimal(vatContent_)
        if self.vatExemption is not None:
            vatExemption_ = self.vatExemption
            vatExemption_.to_etree(element, name_='vatExemption', mapping_=mapping_, nsmap_=nsmap_)
        if self.vatOutOfScope is not None:
            vatOutOfScope_ = self.vatOutOfScope
            vatOutOfScope_.to_etree(element, name_='vatOutOfScope', mapping_=mapping_, nsmap_=nsmap_)
        if self.vatDomesticReverseCharge is not None:
            vatDomesticReverseCharge_ = self.vatDomesticReverseCharge
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatDomesticReverseCharge').text = self.gds_format_boolean(vatDomesticReverseCharge_)
        if self.marginSchemeIndicator is not None:
            marginSchemeIndicator_ = self.marginSchemeIndicator
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}marginSchemeIndicator').text = self.gds_format_string(marginSchemeIndicator_)
        if self.vatAmountMismatch is not None:
            vatAmountMismatch_ = self.vatAmountMismatch
            vatAmountMismatch_.to_etree(element, name_='vatAmountMismatch', mapping_=mapping_, nsmap_=nsmap_)
        if self.noVatCharge is not None:
            noVatCharge_ = self.noVatCharge
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}noVatCharge').text = self.gds_format_boolean(noVatCharge_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='VatRateType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.vatPercentage is not None:
            showIndent(outfile, level)
            outfile.write('vatPercentage=%f,\n' % self.vatPercentage)
        if self.vatContent is not None:
            showIndent(outfile, level)
            outfile.write('vatContent=%f,\n' % self.vatContent)
        if self.vatExemption is not None:
            showIndent(outfile, level)
            outfile.write('vatExemption=model_.DetailedReasonType(\n')
            self.vatExemption.exportLiteral(outfile, level, name_='vatExemption')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vatOutOfScope is not None:
            showIndent(outfile, level)
            outfile.write('vatOutOfScope=model_.DetailedReasonType(\n')
            self.vatOutOfScope.exportLiteral(outfile, level, name_='vatOutOfScope')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vatDomesticReverseCharge is not None:
            showIndent(outfile, level)
            outfile.write('vatDomesticReverseCharge=%s,\n' % self.vatDomesticReverseCharge)
        if self.marginSchemeIndicator is not None:
            showIndent(outfile, level)
            outfile.write('marginSchemeIndicator=%s,\n' % self.gds_encode(quote_python(self.marginSchemeIndicator)))
        if self.vatAmountMismatch is not None:
            showIndent(outfile, level)
            outfile.write('vatAmountMismatch=model_.VatAmountMismatchType(\n')
            self.vatAmountMismatch.exportLiteral(outfile, level, name_='vatAmountMismatch')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.noVatCharge is not None:
            showIndent(outfile, level)
            outfile.write('noVatCharge=%s,\n' % self.noVatCharge)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vatPercentage' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatPercentage')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatPercentage')
            self.vatPercentage = fval_
            self.vatPercentage_nsprefix_ = child_.prefix
            # validate type RateType
            self.validate_RateType(self.vatPercentage)
        elif nodeName_ == 'vatContent' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatContent')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatContent')
            self.vatContent = fval_
            self.vatContent_nsprefix_ = child_.prefix
            # validate type RateType
            self.validate_RateType(self.vatContent)
        elif nodeName_ == 'vatExemption':
            obj_ = DetailedReasonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vatExemption = obj_
            obj_.original_tagname_ = 'vatExemption'
        elif nodeName_ == 'vatOutOfScope':
            obj_ = DetailedReasonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vatOutOfScope = obj_
            obj_.original_tagname_ = 'vatOutOfScope'
        elif nodeName_ == 'vatDomesticReverseCharge':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'vatDomesticReverseCharge')
            ival_ = self.gds_validate_boolean(ival_, node, 'vatDomesticReverseCharge')
            self.vatDomesticReverseCharge = ival_
            self.vatDomesticReverseCharge_nsprefix_ = child_.prefix
        elif nodeName_ == 'marginSchemeIndicator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'marginSchemeIndicator')
            value_ = self.gds_validate_string(value_, node, 'marginSchemeIndicator')
            self.marginSchemeIndicator = value_
            self.marginSchemeIndicator_nsprefix_ = child_.prefix
            # validate type MarginSchemeType
            self.validate_MarginSchemeType(self.marginSchemeIndicator)
        elif nodeName_ == 'vatAmountMismatch':
            obj_ = VatAmountMismatchType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vatAmountMismatch = obj_
            obj_.original_tagname_ = 'vatAmountMismatch'
        elif nodeName_ == 'noVatCharge':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'noVatCharge')
            ival_ = self.gds_validate_boolean(ival_, node, 'noVatCharge')
            self.noVatCharge = ival_
            self.noVatCharge_nsprefix_ = child_.prefix
# end class VatRateType


class VatRateVatDataType(GeneratedsSuper):
    """VatRateVatDataType -- Adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    Á
    FA adatok
    VAT data of given tax rate
    vatRateVatAmount -- Az adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    é
    rt
    é
    kes
    í
    t
    é
    s vagy szolg
    á
    ltat
    á
    sny
    ú
    jt
    á
    s
    Á
    FA
    ö
    sszege a sz
    á
    mla p
    é
    nznem
    é
    ben
    VAT amount of sales or service delivery under a given tax rate expressed in the currency of the invoice
    vatRateVatAmountHUF -- Az adott ad
    ó
    m
    é
    rt
    é
    khez tartoz
    ó
    é
    rt
    é
    kes
    í
    t
    é
    s vagy szolg
    á
    ltat
    á
    sny
    ú
    jt
    á
    s
    Á
    FA
    ö
    sszege forintban
    VAT amount of sales or service delivery under a given tax rate expressed in HUF

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vatRateVatAmount=None, vatRateVatAmountHUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vatRateVatAmount = vatRateVatAmount
        self.validate_MonetaryType(self.vatRateVatAmount)
        self.vatRateVatAmount_nsprefix_ = "base"
        self.vatRateVatAmountHUF = vatRateVatAmountHUF
        self.validate_MonetaryType(self.vatRateVatAmountHUF)
        self.vatRateVatAmountHUF_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VatRateVatDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VatRateVatDataType.subclass:
            return VatRateVatDataType.subclass(*args_, **kwargs_)
        else:
            return VatRateVatDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vatRateVatAmount(self):
        return self.vatRateVatAmount
    def set_vatRateVatAmount(self, vatRateVatAmount):
        self.vatRateVatAmount = vatRateVatAmount
    def get_vatRateVatAmountHUF(self):
        return self.vatRateVatAmountHUF
    def set_vatRateVatAmountHUF(self, vatRateVatAmountHUF):
        self.vatRateVatAmountHUF = vatRateVatAmountHUF
    def validate_MonetaryType(self, value):
        result = True
        # Validate type MonetaryType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 18:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on MonetaryType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.vatRateVatAmount is not None or
            self.vatRateVatAmountHUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='VatRateVatDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VatRateVatDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VatRateVatDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VatRateVatDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VatRateVatDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VatRateVatDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='VatRateVatDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vatRateVatAmount is not None:
            namespaceprefix_ = self.vatRateVatAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRateVatAmount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatRateVatAmount>%s</%svatRateVatAmount>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatRateVatAmount, input_name='vatRateVatAmount'), namespaceprefix_ , eol_))
        if self.vatRateVatAmountHUF is not None:
            namespaceprefix_ = self.vatRateVatAmountHUF_nsprefix_ + ':' if (UseCapturedNS_ and self.vatRateVatAmountHUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svatRateVatAmountHUF>%s</%svatRateVatAmountHUF>%s' % (namespaceprefix_ , self.gds_format_decimal(self.vatRateVatAmountHUF, input_name='vatRateVatAmountHUF'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='VatRateVatDataType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.vatRateVatAmount is not None:
            vatRateVatAmount_ = self.vatRateVatAmount
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatRateVatAmount').text = self.gds_format_decimal(vatRateVatAmount_)
        if self.vatRateVatAmountHUF is not None:
            vatRateVatAmountHUF_ = self.vatRateVatAmountHUF
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}vatRateVatAmountHUF').text = self.gds_format_decimal(vatRateVatAmountHUF_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='VatRateVatDataType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.vatRateVatAmount is not None:
            showIndent(outfile, level)
            outfile.write('vatRateVatAmount=%f,\n' % self.vatRateVatAmount)
        if self.vatRateVatAmountHUF is not None:
            showIndent(outfile, level)
            outfile.write('vatRateVatAmountHUF=%f,\n' % self.vatRateVatAmountHUF)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vatRateVatAmount' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatRateVatAmount')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatRateVatAmount')
            self.vatRateVatAmount = fval_
            self.vatRateVatAmount_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.vatRateVatAmount)
        elif nodeName_ == 'vatRateVatAmountHUF' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'vatRateVatAmountHUF')
            fval_ = self.gds_validate_decimal(fval_, node, 'vatRateVatAmountHUF')
            self.vatRateVatAmountHUF = fval_
            self.vatRateVatAmountHUF_nsprefix_ = child_.prefix
            # validate type MonetaryType
            self.validate_MonetaryType(self.vatRateVatAmountHUF)
# end class VatRateVatDataType


class VehicleType(GeneratedsSuper):
    """VehicleType -- Sz
    á
    razf
    ö
    ldi k
    ö
    zleked
    é
    si eszk
    ö
    z tov
    á
    bbi adatai
    Other data in relation to motorised land vehicle
    engineCapacity -- Henger
    ű
    rtartalom k
    ö
    bcentim
    é
    terben
    Engine capacity in cubic centimetre
    enginePower -- Teljes
    í
    tm
    é
    ny kW-ban
    Engine power in kW
    kms -- Futott kilom
    é
    terek sz
    á
    ma
    Travelled distance in km

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, engineCapacity=None, enginePower=None, kms=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.engineCapacity = engineCapacity
        self.validate_QuantityType(self.engineCapacity)
        self.engineCapacity_nsprefix_ = None
        self.enginePower = enginePower
        self.validate_QuantityType(self.enginePower)
        self.enginePower_nsprefix_ = None
        self.kms = kms
        self.validate_QuantityType(self.kms)
        self.kms_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VehicleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VehicleType.subclass:
            return VehicleType.subclass(*args_, **kwargs_)
        else:
            return VehicleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_engineCapacity(self):
        return self.engineCapacity
    def set_engineCapacity(self, engineCapacity):
        self.engineCapacity = engineCapacity
    def get_enginePower(self):
        return self.enginePower
    def set_enginePower(self, enginePower):
        self.enginePower = enginePower
    def get_kms(self):
        return self.kms
    def set_kms(self, kms):
        self.kms = kms
    def validate_QuantityType(self, value):
        result = True
        # Validate type QuantityType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 22:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.engineCapacity is not None or
            self.enginePower is not None or
            self.kms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='VehicleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VehicleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VehicleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VehicleType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VehicleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VehicleType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='VehicleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.engineCapacity is not None:
            namespaceprefix_ = self.engineCapacity_nsprefix_ + ':' if (UseCapturedNS_ and self.engineCapacity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sengineCapacity>%s</%sengineCapacity>%s' % (namespaceprefix_ , self.gds_format_decimal(self.engineCapacity, input_name='engineCapacity'), namespaceprefix_ , eol_))
        if self.enginePower is not None:
            namespaceprefix_ = self.enginePower_nsprefix_ + ':' if (UseCapturedNS_ and self.enginePower_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senginePower>%s</%senginePower>%s' % (namespaceprefix_ , self.gds_format_decimal(self.enginePower, input_name='enginePower'), namespaceprefix_ , eol_))
        if self.kms is not None:
            namespaceprefix_ = self.kms_nsprefix_ + ':' if (UseCapturedNS_ and self.kms_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skms>%s</%skms>%s' % (namespaceprefix_ , self.gds_format_decimal(self.kms, input_name='kms'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='VehicleType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.engineCapacity is not None:
            engineCapacity_ = self.engineCapacity
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}engineCapacity').text = self.gds_format_decimal(engineCapacity_)
        if self.enginePower is not None:
            enginePower_ = self.enginePower
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}enginePower').text = self.gds_format_decimal(enginePower_)
        if self.kms is not None:
            kms_ = self.kms
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}kms').text = self.gds_format_decimal(kms_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='VehicleType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.engineCapacity is not None:
            showIndent(outfile, level)
            outfile.write('engineCapacity=%f,\n' % self.engineCapacity)
        if self.enginePower is not None:
            showIndent(outfile, level)
            outfile.write('enginePower=%f,\n' % self.enginePower)
        if self.kms is not None:
            showIndent(outfile, level)
            outfile.write('kms=%f,\n' % self.kms)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'engineCapacity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'engineCapacity')
            fval_ = self.gds_validate_decimal(fval_, node, 'engineCapacity')
            self.engineCapacity = fval_
            self.engineCapacity_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.engineCapacity)
        elif nodeName_ == 'enginePower' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'enginePower')
            fval_ = self.gds_validate_decimal(fval_, node, 'enginePower')
            self.enginePower = fval_
            self.enginePower_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.enginePower)
        elif nodeName_ == 'kms' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'kms')
            fval_ = self.gds_validate_decimal(fval_, node, 'kms')
            self.kms = fval_
            self.kms_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.kms)
# end class VehicleType


class VesselType(GeneratedsSuper):
    """VesselType -- V
    í
    zi j
    á
    rm
    ű
    adatai
    Data of vessel
    length -- Haj
    ó
    hossza m
    é
    terben
    Length of hull in metre
    activityReferred -- É
    rt
    é
    ke true, ha a j
    á
    rm
    ű
    az
    Á
    FA tv. 259.
    §
    25. b) szerinti kiv
    é
    tel al
    á
    tartozik
    The value is true if the means of transport is exempt from VAT as per section 259 [25] (b)
    sailedHours -- Haj
    ó
    zott
    ó
    r
    á
    k sz
    á
    ma
    Number of sailed hours

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, length=None, activityReferred=None, sailedHours=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.length = length
        self.validate_QuantityType(self.length)
        self.length_nsprefix_ = None
        self.activityReferred = activityReferred
        self.activityReferred_nsprefix_ = "xs"
        self.sailedHours = sailedHours
        self.validate_QuantityType(self.sailedHours)
        self.sailedHours_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VesselType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VesselType.subclass:
            return VesselType.subclass(*args_, **kwargs_)
        else:
            return VesselType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_activityReferred(self):
        return self.activityReferred
    def set_activityReferred(self, activityReferred):
        self.activityReferred = activityReferred
    def get_sailedHours(self):
        return self.sailedHours
    def set_sailedHours(self, sailedHours):
        self.sailedHours = sailedHours
    def validate_QuantityType(self, value):
        result = True
        # Validate type QuantityType, a restriction on common:GenericDecimalType.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(str(value)) >= 22:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd totalDigits restriction on QuantityType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.length is not None or
            self.activityReferred is not None or
            self.sailedHours is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='VesselType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VesselType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VesselType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VesselType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VesselType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VesselType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:xs="http://www.w3.org/2001/XMLSchema" ', name_='VesselType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.length is not None:
            namespaceprefix_ = self.length_nsprefix_ + ':' if (UseCapturedNS_ and self.length_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespaceprefix_ , self.gds_format_decimal(self.length, input_name='length'), namespaceprefix_ , eol_))
        if self.activityReferred is not None:
            namespaceprefix_ = self.activityReferred_nsprefix_ + ':' if (UseCapturedNS_ and self.activityReferred_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactivityReferred>%s</%sactivityReferred>%s' % (namespaceprefix_ , self.gds_format_boolean(self.activityReferred, input_name='activityReferred'), namespaceprefix_ , eol_))
        if self.sailedHours is not None:
            namespaceprefix_ = self.sailedHours_nsprefix_ + ':' if (UseCapturedNS_ and self.sailedHours_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssailedHours>%s</%ssailedHours>%s' % (namespaceprefix_ , self.gds_format_decimal(self.sailedHours, input_name='sailedHours'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='VesselType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/data}' + name_, nsmap=nsmap_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}length').text = self.gds_format_decimal(length_)
        if self.activityReferred is not None:
            activityReferred_ = self.activityReferred
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}activityReferred').text = self.gds_format_boolean(activityReferred_)
        if self.sailedHours is not None:
            sailedHours_ = self.sailedHours
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/data}sailedHours').text = self.gds_format_decimal(sailedHours_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='VesselType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.length is not None:
            showIndent(outfile, level)
            outfile.write('length=%f,\n' % self.length)
        if self.activityReferred is not None:
            showIndent(outfile, level)
            outfile.write('activityReferred=%s,\n' % self.activityReferred)
        if self.sailedHours is not None:
            showIndent(outfile, level)
            outfile.write('sailedHours=%f,\n' % self.sailedHours)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'length' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'length')
            fval_ = self.gds_validate_decimal(fval_, node, 'length')
            self.length = fval_
            self.length_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.length)
        elif nodeName_ == 'activityReferred':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'activityReferred')
            ival_ = self.gds_validate_boolean(ival_, node, 'activityReferred')
            self.activityReferred = ival_
            self.activityReferred_nsprefix_ = child_.prefix
        elif nodeName_ == 'sailedHours' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'sailedHours')
            fval_ = self.gds_validate_decimal(fval_, node, 'sailedHours')
            self.sailedHours = fval_
            self.sailedHours_nsprefix_ = child_.prefix
            # validate type QuantityType
            self.validate_QuantityType(self.sailedHours)
# end class VesselType


class InvoiceData(InvoiceDataType):
    """InvoiceData -- XML root element, sz
    á
    mla vagy m
    ó
    dos
    í
    t
    á
    s adatait le
    í
    r
    ó
    t
    í
    pus, amelyet BASE64 k
    ó
    doltan tartalmaz az invoiceApi s
    é
    male
    í
    r
    ó
    invoiceData elementje
    XML root element, invoice or modification data type in BASE64 encoding, equivalent with the invoiceApi schema definition's invoiceData element

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = InvoiceDataType
    def __init__(self, invoiceNumber=None, invoiceIssueDate=None, completenessIndicator=None, invoiceMain=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("InvoiceData"), self).__init__(invoiceNumber, invoiceIssueDate, completenessIndicator, invoiceMain,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InvoiceData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InvoiceData.subclass:
            return InvoiceData.subclass(*args_, **kwargs_)
        else:
            return InvoiceData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(InvoiceData, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='InvoiceData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InvoiceData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InvoiceData':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceData')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InvoiceData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InvoiceData'):
        super(InvoiceData, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InvoiceData')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='InvoiceData', fromsubclass_=False, pretty_print=True):
        super(InvoiceData, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InvoiceData', mapping_=None, nsmap_=None):
        element = super(InvoiceData, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='InvoiceData'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InvoiceData, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(InvoiceData, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(InvoiceData, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(InvoiceData, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class InvoiceData


class MetricDefinitionType(GeneratedsSuper):
    """MetricDefinitionType -- Metrika defin
    í
    ci
    ó
    t
    í
    pus
    Metric definition type
    metricName -- Metrika neve
    Metric's name
    metricType -- Metrika t
    í
    pusa
    Metric's type
    metricDescription -- Metrika le
    í
    r
    á
    sa
    Metric's description

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, metricName=None, metricType=None, metricDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.metricName = metricName
        self.validate_SimpleText200NotBlankType(self.metricName)
        self.metricName_nsprefix_ = "common"
        self.metricType = metricType
        self.validate_MetricTypeType(self.metricType)
        self.metricType_nsprefix_ = None
        if metricDescription is None:
            self.metricDescription = []
        else:
            self.metricDescription = metricDescription
        self.metricDescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetricDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetricDefinitionType.subclass:
            return MetricDefinitionType.subclass(*args_, **kwargs_)
        else:
            return MetricDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_metricName(self):
        return self.metricName
    def set_metricName(self, metricName):
        self.metricName = metricName
    def get_metricType(self):
        return self.metricType
    def set_metricType(self, metricType):
        self.metricType = metricType
    def get_metricDescription(self):
        return self.metricDescription
    def set_metricDescription(self, metricDescription):
        self.metricDescription = metricDescription
    def add_metricDescription(self, value):
        self.metricDescription.append(value)
    def insert_metricDescription_at(self, index, value):
        self.metricDescription.insert(index, value)
    def replace_metricDescription_at(self, index, value):
        self.metricDescription[index] = value
    def validate_SimpleText200NotBlankType(self, value):
        result = True
        # Validate type SimpleText200NotBlankType, a restriction on AtomicStringType200.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 200:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText200NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText200NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText200NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText200NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText200NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def validate_MetricTypeType(self, value):
        result = True
        # Validate type MetricTypeType, a restriction on common:AtomicStringType15.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['COUNTER', 'GAUGE', 'HISTOGRAM', 'SUMMARY']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MetricTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on MetricTypeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on MetricTypeType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.metricName is not None or
            self.metricType is not None or
            self.metricDescription
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='MetricDefinitionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetricDefinitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MetricDefinitionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetricDefinitionType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetricDefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetricDefinitionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='MetricDefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.metricName is not None:
            namespaceprefix_ = self.metricName_nsprefix_ + ':' if (UseCapturedNS_ and self.metricName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smetricName>%s</%smetricName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.metricName), input_name='metricName')), namespaceprefix_ , eol_))
        if self.metricType is not None:
            namespaceprefix_ = self.metricType_nsprefix_ + ':' if (UseCapturedNS_ and self.metricType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smetricType>%s</%smetricType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.metricType), input_name='metricType')), namespaceprefix_ , eol_))
        for metricDescription_ in self.metricDescription:
            namespaceprefix_ = self.metricDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.metricDescription_nsprefix_) else ''
            metricDescription_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metricDescription', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MetricDefinitionType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        if self.metricName is not None:
            metricName_ = self.metricName
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}metricName').text = self.gds_format_string(metricName_)
        if self.metricType is not None:
            metricType_ = self.metricType
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}metricType').text = self.gds_format_string(metricType_)
        for metricDescription_ in self.metricDescription:
            metricDescription_.to_etree(element, name_='metricDescription', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MetricDefinitionType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.metricName is not None:
            showIndent(outfile, level)
            outfile.write('metricName=%s,\n' % self.gds_encode(quote_python(self.metricName)))
        if self.metricType is not None:
            showIndent(outfile, level)
            outfile.write('metricType=%s,\n' % self.gds_encode(quote_python(self.metricType)))
        showIndent(outfile, level)
        outfile.write('metricDescription=[\n')
        level += 1
        for metricDescription_ in self.metricDescription:
            showIndent(outfile, level)
            outfile.write('model_.MetricDescriptionType(\n')
            metricDescription_.exportLiteral(outfile, level, name_='MetricDescriptionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'metricName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'metricName')
            value_ = self.gds_validate_string(value_, node, 'metricName')
            self.metricName = value_
            self.metricName_nsprefix_ = child_.prefix
            # validate type SimpleText200NotBlankType
            self.validate_SimpleText200NotBlankType(self.metricName)
        elif nodeName_ == 'metricType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'metricType')
            value_ = self.gds_validate_string(value_, node, 'metricType')
            self.metricType = value_
            self.metricType_nsprefix_ = child_.prefix
            # validate type MetricTypeType
            self.validate_MetricTypeType(self.metricType)
        elif nodeName_ == 'metricDescription':
            obj_ = MetricDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metricDescription.append(obj_)
            obj_.original_tagname_ = 'metricDescription'
# end class MetricDefinitionType


class MetricDescriptionType(GeneratedsSuper):
    """MetricDescriptionType -- Metrika le
    í
    r
    á
    s t
    í
    pus
    Metric description type
    language -- Nyelv megnevez
    é
    s
    Language naming
    localizedDescription -- Lokaliz
    á
    lt le
    í
    r
    á
    s
    Localized description

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, language=None, localizedDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = language
        self.validate_LanguageType(self.language)
        self.language_nsprefix_ = None
        self.localizedDescription = localizedDescription
        self.validate_SimpleText512NotBlankType(self.localizedDescription)
        self.localizedDescription_nsprefix_ = "common"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetricDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetricDescriptionType.subclass:
            return MetricDescriptionType.subclass(*args_, **kwargs_)
        else:
            return MetricDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_localizedDescription(self):
        return self.localizedDescription
    def set_localizedDescription(self, localizedDescription):
        self.localizedDescription = localizedDescription
    def validate_LanguageType(self, value):
        result = True
        # Validate type LanguageType, a restriction on common:AtomicStringType2.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            value = value
            enumerations = ['HU', 'EN', 'DE']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on LanguageType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on LanguageType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on LanguageType' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_SimpleText512NotBlankType(self, value):
        result = True
        # Validate type SimpleText512NotBlankType, a restriction on AtomicStringType512.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) > 512:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on SimpleText512NotBlankType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on SimpleText512NotBlankType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_SimpleText512NotBlankType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_SimpleText512NotBlankType_patterns_, ))
                result = False
        return result
    validate_SimpleText512NotBlankType_patterns_ = [['^(.*[^\\s].*)$']]
    def _hasContent(self):
        if (
            self.language is not None or
            self.localizedDescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='MetricDescriptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetricDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MetricDescriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetricDescriptionType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetricDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetricDescriptionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics"  xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common" ', name_='MetricDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespaceprefix_ , eol_))
        if self.localizedDescription is not None:
            namespaceprefix_ = self.localizedDescription_nsprefix_ + ':' if (UseCapturedNS_ and self.localizedDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocalizedDescription>%s</%slocalizedDescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.localizedDescription), input_name='localizedDescription')), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='MetricDescriptionType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        if self.language is not None:
            language_ = self.language
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}language').text = self.gds_format_string(language_)
        if self.localizedDescription is not None:
            localizedDescription_ = self.localizedDescription
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}localizedDescription').text = self.gds_format_string(localizedDescription_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MetricDescriptionType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.language is not None:
            showIndent(outfile, level)
            outfile.write('language=%s,\n' % self.gds_encode(quote_python(self.language)))
        if self.localizedDescription is not None:
            showIndent(outfile, level)
            outfile.write('localizedDescription=%s,\n' % self.gds_encode(quote_python(self.localizedDescription)))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'language':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'language')
            value_ = self.gds_validate_string(value_, node, 'language')
            self.language = value_
            self.language_nsprefix_ = child_.prefix
            # validate type LanguageType
            self.validate_LanguageType(self.language)
        elif nodeName_ == 'localizedDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'localizedDescription')
            value_ = self.gds_validate_string(value_, node, 'localizedDescription')
            self.localizedDescription = value_
            self.localizedDescription_nsprefix_ = child_.prefix
            # validate type SimpleText512NotBlankType
            self.validate_SimpleText512NotBlankType(self.localizedDescription)
# end class MetricDescriptionType


class MetricType(GeneratedsSuper):
    """MetricType -- Metrika t
    í
    pus
    Metric data type
    metricDefinition -- Metrika defin
    í
    ci
    ó
    Metric definition
    metricValues -- Metrika
    é
    rt
    é
    kek
    Metric values

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, metricDefinition=None, metricValues=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.metricDefinition = metricDefinition
        self.metricDefinition_nsprefix_ = None
        if metricValues is None:
            self.metricValues = []
        else:
            self.metricValues = metricValues
        self.metricValues_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetricType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetricType.subclass:
            return MetricType.subclass(*args_, **kwargs_)
        else:
            return MetricType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_metricDefinition(self):
        return self.metricDefinition
    def set_metricDefinition(self, metricDefinition):
        self.metricDefinition = metricDefinition
    def get_metricValues(self):
        return self.metricValues
    def set_metricValues(self, metricValues):
        self.metricValues = metricValues
    def add_metricValues(self, value):
        self.metricValues.append(value)
    def insert_metricValues_at(self, index, value):
        self.metricValues.insert(index, value)
    def replace_metricValues_at(self, index, value):
        self.metricValues[index] = value
    def _hasContent(self):
        if (
            self.metricDefinition is not None or
            self.metricValues
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='MetricType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetricType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MetricType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetricType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetricType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetricType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='MetricType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.metricDefinition is not None:
            namespaceprefix_ = self.metricDefinition_nsprefix_ + ':' if (UseCapturedNS_ and self.metricDefinition_nsprefix_) else ''
            self.metricDefinition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metricDefinition', pretty_print=pretty_print)
        for metricValues_ in self.metricValues:
            namespaceprefix_ = self.metricValues_nsprefix_ + ':' if (UseCapturedNS_ and self.metricValues_nsprefix_) else ''
            metricValues_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metricValues', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MetricType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        if self.metricDefinition is not None:
            metricDefinition_ = self.metricDefinition
            metricDefinition_.to_etree(element, name_='metricDefinition', mapping_=mapping_, nsmap_=nsmap_)
        for metricValues_ in self.metricValues:
            metricValues_.to_etree(element, name_='metricValues', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MetricType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.metricDefinition is not None:
            showIndent(outfile, level)
            outfile.write('metricDefinition=model_.MetricDefinitionType(\n')
            self.metricDefinition.exportLiteral(outfile, level, name_='metricDefinition')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('metricValues=[\n')
        level += 1
        for metricValues_ in self.metricValues:
            showIndent(outfile, level)
            outfile.write('model_.MetricValueType(\n')
            metricValues_.exportLiteral(outfile, level, name_='MetricValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'metricDefinition':
            obj_ = MetricDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metricDefinition = obj_
            obj_.original_tagname_ = 'metricDefinition'
        elif nodeName_ == 'metricValues':
            obj_ = MetricValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metricValues.append(obj_)
            obj_.original_tagname_ = 'metricValues'
# end class MetricType


class MetricValueType(GeneratedsSuper):
    """MetricValueType -- Metrika
    é
    rt
    é
    k t
    í
    pus
    Metric value type
    value -- Metrika
    é
    rt
    é
    ke
    Metric's value
    timestamp -- Metrika
    é
    rt
    é
    k
    é
    nek id
    ő
    pontja UTC id
    ő
    ben
    Time of metric value in UTC time

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, timestamp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = value
        self.validate_GenericDecimalType(self.value)
        self.value_nsprefix_ = "common"
        if isinstance(timestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timestamp
        self.timestamp = initvalue_
        self.timestamp_nsprefix_ = "base"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetricValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetricValueType.subclass:
            return MetricValueType.subclass(*args_, **kwargs_)
        else:
            return MetricValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_timestamp(self):
        return self.timestamp
    def set_timestamp(self, timestamp):
        self.timestamp = timestamp
    def validate_GenericDecimalType(self, value):
        result = True
        # Validate type GenericDecimalType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.fromisostring('2010-01-01T00:00:00.000000').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceTimestampType_patterns_, ))
                result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def _hasContent(self):
        if (
            self.value is not None or
            self.timestamp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='MetricValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetricValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MetricValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetricValueType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetricValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetricValueType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base" ', name_='MetricValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_decimal(self.value, input_name='value'), namespaceprefix_ , eol_))
        if self.timestamp is not None:
            namespaceprefix_ = self.timestamp_nsprefix_ + ':' if (UseCapturedNS_ and self.timestamp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimestamp>%s</%stimestamp>%s' % (namespaceprefix_ , self.gds_format_datetime(self.timestamp, input_name='timestamp'), namespaceprefix_ , eol_))
    def to_etree(self, parent_element=None, name_='MetricValueType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        if self.value is not None:
            value_ = self.value
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}value').text = self.gds_format_decimal(value_)
        if self.timestamp is not None:
            timestamp_ = self.timestamp
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}timestamp').text = self.gds_format_datetime(timestamp_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MetricValueType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%f,\n' % self.value)
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'value')
            fval_ = self.gds_validate_decimal(fval_, node, 'value')
            self.value = fval_
            self.value_nsprefix_ = child_.prefix
            # validate type GenericDecimalType
            self.validate_GenericDecimalType(self.value)
        elif nodeName_ == 'timestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.timestamp = dval_
            self.timestamp_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.timestamp)
# end class MetricValueType


class QueryServiceMetricsListResponseType(GeneratedsSuper):
    """QueryServiceMetricsListResponseType -- A GET /queryServiceMetrics/list REST oper
    á
    ci
    ó
    v
    á
    lasz t
    í
    pusa
    Response type of the GET /queryServiceMetrics/list REST operation
    metricDefinition -- Metrika defin
    í
    ci
    ó
    i
    Metric definitions

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, metricDefinition=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if metricDefinition is None:
            self.metricDefinition = []
        else:
            self.metricDefinition = metricDefinition
        self.metricDefinition_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryServiceMetricsListResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryServiceMetricsListResponseType.subclass:
            return QueryServiceMetricsListResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryServiceMetricsListResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_metricDefinition(self):
        return self.metricDefinition
    def set_metricDefinition(self, metricDefinition):
        self.metricDefinition = metricDefinition
    def add_metricDefinition(self, value):
        self.metricDefinition.append(value)
    def insert_metricDefinition_at(self, index, value):
        self.metricDefinition.insert(index, value)
    def replace_metricDefinition_at(self, index, value):
        self.metricDefinition[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.metricDefinition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryServiceMetricsListResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryServiceMetricsListResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryServiceMetricsListResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryServiceMetricsListResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryServiceMetricsListResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryServiceMetricsListResponseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryServiceMetricsListResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for metricDefinition_ in self.metricDefinition:
            namespaceprefix_ = self.metricDefinition_nsprefix_ + ':' if (UseCapturedNS_ and self.metricDefinition_nsprefix_) else ''
            metricDefinition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metricDefinition', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryServiceMetricsListResponseType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        for metricDefinition_ in self.metricDefinition:
            metricDefinition_.to_etree(element, name_='metricDefinition', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryServiceMetricsListResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('metricDefinition=[\n')
        level += 1
        for metricDefinition_ in self.metricDefinition:
            showIndent(outfile, level)
            outfile.write('model_.MetricDefinitionType(\n')
            metricDefinition_.exportLiteral(outfile, level, name_='MetricDefinitionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'metricDefinition':
            obj_ = MetricDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metricDefinition.append(obj_)
            obj_.original_tagname_ = 'metricDefinition'
# end class QueryServiceMetricsListResponseType


class QueryServiceMetricsResponseType(GeneratedsSuper):
    """QueryServiceMetricsResponseType -- A GET /queryServiceMetrics REST oper
    á
    ci
    ó
    v
    á
    lasz t
    í
    pusa
    Response type of the GET /queryServiceMetrics REST operation
    result -- Alap v
    á
    laszeredm
    é
    ny adatok
    Basic result data
    metricsLastUpdateTime -- A metrik
    á
    k utols
    ó
    friss
    í
    t
    é
    s
    é
    nek id
    ő
    pontja UTC id
    ő
    ben
    Last update time of metrics in UTC time
    metric -- Metrika adatai
    Metric data

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, result=None, metricsLastUpdateTime=None, metric=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.result = result
        self.result_nsprefix_ = "common"
        if isinstance(metricsLastUpdateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(metricsLastUpdateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = metricsLastUpdateTime
        self.metricsLastUpdateTime = initvalue_
        self.metricsLastUpdateTime_nsprefix_ = "base"
        if metric is None:
            self.metric = []
        else:
            self.metric = metric
        self.metric_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryServiceMetricsResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryServiceMetricsResponseType.subclass:
            return QueryServiceMetricsResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryServiceMetricsResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_result(self):
        return self.result
    def set_result(self, result):
        self.result = result
    def get_metricsLastUpdateTime(self):
        return self.metricsLastUpdateTime
    def set_metricsLastUpdateTime(self, metricsLastUpdateTime):
        self.metricsLastUpdateTime = metricsLastUpdateTime
    def get_metric(self):
        return self.metric
    def set_metric(self, metric):
        self.metric = metric
    def add_metric(self, value):
        self.metric.append(value)
    def insert_metric_at(self, index, value):
        self.metric.insert(index, value)
    def replace_metric_at(self, index, value):
        self.metric[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_InvoiceTimestampType(self, value):
        result = True
        # Validate type InvoiceTimestampType, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if value < datetime.datetime.fromisostring('2010-01-01T00:00:00.000000').replace(tzinfo=pytz.UTC):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on InvoiceTimestampType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_InvoiceTimestampType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_InvoiceTimestampType_patterns_, ))
                result = False
        return result
    validate_InvoiceTimestampType_patterns_ = [['^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d{1,3})?Z)$']]
    def _hasContent(self):
        if (
            self.result is not None or
            self.metricsLastUpdateTime is not None or
            self.metric
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryServiceMetricsResponseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryServiceMetricsResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryServiceMetricsResponseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryServiceMetricsResponseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryServiceMetricsResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryServiceMetricsResponseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common" xmlns:common="http://schemas.nav.gov.hu/NTCA/1.0/common"  xmlns:base="http://schemas.nav.gov.hu/OSA/3.0/base"  xmlns:None="http://schemas.nav.gov.hu/OSA/3.0/metrics" ', name_='QueryServiceMetricsResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.result is not None:
            namespaceprefix_ = self.result_nsprefix_ + ':' if (UseCapturedNS_ and self.result_nsprefix_) else ''
            self.result.export(outfile, level, namespaceprefix_, namespacedef_='', name_='result', pretty_print=pretty_print)
        if self.metricsLastUpdateTime is not None:
            namespaceprefix_ = self.metricsLastUpdateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.metricsLastUpdateTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smetricsLastUpdateTime>%s</%smetricsLastUpdateTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.metricsLastUpdateTime, input_name='metricsLastUpdateTime'), namespaceprefix_ , eol_))
        for metric_ in self.metric:
            namespaceprefix_ = self.metric_nsprefix_ + ':' if (UseCapturedNS_ and self.metric_nsprefix_) else ''
            metric_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='metric', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryServiceMetricsResponseType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.result is not None:
            result_ = self.result
            result_.to_etree(element, name_='result', mapping_=mapping_, nsmap_=nsmap_)
        if self.metricsLastUpdateTime is not None:
            metricsLastUpdateTime_ = self.metricsLastUpdateTime
            etree_.SubElement(element, '{http://schemas.nav.gov.hu/OSA/3.0/metrics}metricsLastUpdateTime').text = self.gds_format_datetime(metricsLastUpdateTime_)
        for metric_ in self.metric:
            metric_.to_etree(element, name_='metric', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryServiceMetricsResponseType'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def _exportLiteralChildren(self, outfile, level, name_):
        if self.result is not None:
            showIndent(outfile, level)
            outfile.write('result=model_.BasicResultType(\n')
            self.result.exportLiteral(outfile, level, name_='result')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metricsLastUpdateTime is not None:
            showIndent(outfile, level)
            outfile.write('metricsLastUpdateTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.metricsLastUpdateTime, input_name='metricsLastUpdateTime'))
        showIndent(outfile, level)
        outfile.write('metric=[\n')
        level += 1
        for metric_ in self.metric:
            showIndent(outfile, level)
            outfile.write('model_.MetricType(\n')
            metric_.exportLiteral(outfile, level, name_='MetricType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'result':
            class_obj_ = self.get_class_obj_(child_, BasicResultType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.result = obj_
            obj_.original_tagname_ = 'result'
        elif nodeName_ == 'metricsLastUpdateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.metricsLastUpdateTime = dval_
            self.metricsLastUpdateTime_nsprefix_ = child_.prefix
            # validate type InvoiceTimestampType
            self.validate_InvoiceTimestampType(self.metricsLastUpdateTime)
        elif nodeName_ == 'metric':
            obj_ = MetricType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.metric.append(obj_)
            obj_.original_tagname_ = 'metric'
# end class QueryServiceMetricsResponseType


class QueryServiceMetricsListResponse(QueryServiceMetricsListResponseType):
    """QueryServiceMetricsListResponse -- A GET /queryServiceMetrics/list REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the GET /queryServiceMetrics/list REST operation
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryServiceMetricsListResponseType
    def __init__(self, metricDefinition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryServiceMetricsListResponse"), self).__init__(metricDefinition,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryServiceMetricsListResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryServiceMetricsListResponse.subclass:
            return QueryServiceMetricsListResponse.subclass(*args_, **kwargs_)
        else:
            return QueryServiceMetricsListResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryServiceMetricsListResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryServiceMetricsListResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryServiceMetricsListResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryServiceMetricsListResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryServiceMetricsListResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryServiceMetricsListResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryServiceMetricsListResponse'):
        super(QueryServiceMetricsListResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryServiceMetricsListResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryServiceMetricsListResponse', fromsubclass_=False, pretty_print=True):
        super(QueryServiceMetricsListResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryServiceMetricsListResponse', mapping_=None, nsmap_=None):
        element = super(QueryServiceMetricsListResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryServiceMetricsListResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryServiceMetricsListResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryServiceMetricsListResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryServiceMetricsListResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryServiceMetricsListResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryServiceMetricsListResponse


class QueryServiceMetricsResponse(QueryServiceMetricsResponseType):
    """QueryServiceMetricsResponse -- A GET /queryServiceMetrics REST oper
    á
    ci
    ó
    v
    á
    lasz
    á
    nak root elementje
    Response root element of the GET /queryServiceMetrics REST operation
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QueryServiceMetricsResponseType
    def __init__(self, result=None, metricsLastUpdateTime=None, metric=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QueryServiceMetricsResponse"), self).__init__(result, metricsLastUpdateTime, metric,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QueryServiceMetricsResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QueryServiceMetricsResponse.subclass:
            return QueryServiceMetricsResponse.subclass(*args_, **kwargs_)
        else:
            return QueryServiceMetricsResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(QueryServiceMetricsResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryServiceMetricsResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QueryServiceMetricsResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QueryServiceMetricsResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryServiceMetricsResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QueryServiceMetricsResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QueryServiceMetricsResponse'):
        super(QueryServiceMetricsResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QueryServiceMetricsResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:tns="http://schemas.nav.gov.hu/NTCA/1.0/common"', name_='QueryServiceMetricsResponse', fromsubclass_=False, pretty_print=True):
        super(QueryServiceMetricsResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QueryServiceMetricsResponse', mapping_=None, nsmap_=None):
        element = super(QueryServiceMetricsResponse, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QueryServiceMetricsResponse'):
        level += 1
        already_processed = set()
        self._exportLiteralAttributes(outfile, level, already_processed, name_)
        if self._hasContent():
            self._exportLiteralChildren(outfile, level, name_)
    def _exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryServiceMetricsResponse, self)._exportLiteralAttributes(outfile, level, already_processed, name_)
    def _exportLiteralChildren(self, outfile, level, name_):
        super(QueryServiceMetricsResponse, self)._exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(QueryServiceMetricsResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QueryServiceMetricsResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryServiceMetricsResponse


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BasicHeaderType'
        rootClass = BasicHeaderType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BasicHeaderType'
        rootClass = BasicHeaderType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BasicHeaderType'
        rootClass = BasicHeaderType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ns2="http://schemas.nav.gov.hu/NTCA/1.0/common"')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BasicHeaderType'
        rootClass = BasicHeaderType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from online_invoice import *\n\n')
        sys.stdout.write('import online_invoice as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://schemas.nav.gov.hu/NTCA/1.0/common': [('AtomicStringType100',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType1024',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType128',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType15',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType16',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType2',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType200',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType2048',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType255',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType256',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType32',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType4',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType4000',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType50',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType512',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType64',
                                                'common.xsd',
                                                'ST'),
                                               ('AtomicStringType8',
                                                'common.xsd',
                                                'ST'),
                                               ('GenericDateType',
                                                'common.xsd',
                                                'ST'),
                                               ('GenericDecimalType',
                                                'common.xsd',
                                                'ST'),
                                               ('GenericTimestampType',
                                                'common.xsd',
                                                'ST'),
                                               ('SHA256Type',
                                                'common.xsd',
                                                'ST'),
                                               ('SHA512Type',
                                                'common.xsd',
                                                'ST'),
                                               ('SimpleText100NotBlankType',
                                                'common.xsd',
                                                'ST'),
                                               ('SimpleText1024NotBlankType',
                                                'common.xsd',
                                                'ST'),
                                               ('SimpleText15NotBlankType',
                                                'common.xsd',
                                                'ST'),
                                               ('SimpleText200NotBlankType',
                                                'common.xsd',
                                                'ST'),
                                               ('SimpleText255NotBlankType',
                                                'common.xsd',
                                                'ST'),
                                               ('SimpleText50NotBlankType',
                                                'common.xsd',
                                                'ST'),
                                               ('SimpleText512NotBlankType',
                                                'common.xsd',
                                                'ST'),
                                               ('BankAccountNumberType',
                                                'common.xsd',
                                                'ST'),
                                               ('CommunityVatNumberType',
                                                'common.xsd',
                                                'ST'),
                                               ('CountryCodeType',
                                                'common.xsd',
                                                'ST'),
                                               ('CountyCodeType',
                                                'common.xsd',
                                                'ST'),
                                               ('CurrencyType',
                                                'common.xsd',
                                                'ST'),
                                               ('PlateNumberType',
                                                'common.xsd',
                                                'ST'),
                                               ('PostalCodeType',
                                                'common.xsd',
                                                'ST'),
                                               ('TaxpayerIdType',
                                                'common.xsd',
                                                'ST'),
                                               ('VatCodeType',
                                                'common.xsd',
                                                'ST'),
                                               ('BusinessResultCodeType',
                                                'common.xsd',
                                                'ST'),
                                               ('EntityIdType',
                                                'common.xsd',
                                                'ST'),
                                               ('FunctionCodeType',
                                                'common.xsd',
                                                'ST'),
                                               ('LoginType',
                                                'common.xsd',
                                                'ST'),
                                               ('RequestPageType',
                                                'common.xsd',
                                                'ST'),
                                               ('ResponsePageType',
                                                'common.xsd',
                                                'ST'),
                                               ('TechnicalResultCodeType',
                                                'common.xsd',
                                                'ST'),
                                               ('BasicHeaderType',
                                                'common.xsd',
                                                'CT'),
                                               ('BasicRequestType',
                                                'common.xsd',
                                                'CT'),
                                               ('BasicResponseType',
                                                'common.xsd',
                                                'CT'),
                                               ('BasicResultType',
                                                'common.xsd',
                                                'CT'),
                                               ('CryptoType',
                                                'common.xsd',
                                                'CT'),
                                               ('GeneralErrorHeaderResponseType',
                                                'common.xsd',
                                                'CT'),
                                               ('NotificationsType',
                                                'common.xsd',
                                                'CT'),
                                               ('NotificationType',
                                                'common.xsd',
                                                'CT'),
                                               ('TechnicalValidationResultType',
                                                'common.xsd',
                                                'CT'),
                                               ('UserHeaderType',
                                                'common.xsd',
                                                'CT')],
 'http://schemas.nav.gov.hu/OSA/3.0/annul': [('AnnulmentCodeType',
                                              'invoiceAnnulment.xsd',
                                              'ST'),
                                             ('InvoiceAnnulmentType',
                                              'invoiceAnnulment.xsd',
                                              'CT')],
 'http://schemas.nav.gov.hu/OSA/3.0/api': [('AnnulmentVerificationStatusType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('IncorporationType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('InvoiceDirectionType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('InvoiceStatusType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('ManageAnnulmentOperationType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('ManageInvoiceOperationType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('OriginalRequestVersionType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('QueryNameType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('QueryOperatorType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('RequestStatusType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('SoftwareIdType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('SoftwareOperationType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('SourceType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('TaxpayerAddressTypeType',
                                            'invoiceApi.xsd',
                                            'ST'),
                                           ('AdditionalQueryParamsType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('AnnulmentDataType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('AnnulmentOperationListType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('AnnulmentOperationType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('AuditDataType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('BasicOnlineInvoiceRequestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('BasicOnlineInvoiceResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('BusinessValidationResultType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('DateIntervalParamType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('DateTimeIntervalParamType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('GeneralErrorResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceChainDigestResultType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceChainDigestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceChainElementType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceChainQueryType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceDataResultType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceDigestResultType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceDigestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceLinesType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceNumberQueryType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceOperationListType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceOperationType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceQueryParamsType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('InvoiceReferenceDataType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('ManageAnnulmentRequestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('ManageInvoiceRequestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('MandatoryQueryParamsType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('NewCreatedLinesType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('PointerType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('ProcessingResultListType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('ProcessingResultType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryInvoiceChainDigestRequestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryInvoiceChainDigestResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryInvoiceCheckResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryInvoiceDataRequestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryInvoiceDataResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryInvoiceDigestRequestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryInvoiceDigestResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryTaxpayerRequestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryTaxpayerResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryTransactionListRequestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryTransactionListResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryTransactionStatusRequestType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('QueryTransactionStatusResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('RelationalQueryParamsType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('RelationQueryDateType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('RelationQueryMonetaryType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('SoftwareType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('TaxpayerAddressItemType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('TaxpayerAddressListType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('TaxpayerDataType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('TokenExchangeResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('TransactionListResultType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('TransactionQueryParamsType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('TransactionResponseType',
                                            'invoiceApi.xsd',
                                            'CT'),
                                           ('TransactionType',
                                            'invoiceApi.xsd',
                                            'CT')],
 'http://schemas.nav.gov.hu/OSA/3.0/base': [('InvoiceAppearanceType',
                                             'invoiceBase.xsd',
                                             'ST'),
                                            ('InvoiceCategoryType',
                                             'invoiceBase.xsd',
                                             'ST'),
                                            ('InvoiceDateType',
                                             'invoiceBase.xsd',
                                             'ST'),
                                            ('InvoiceIndexType',
                                             'invoiceBase.xsd',
                                             'ST'),
                                            ('InvoiceTimestampType',
                                             'invoiceBase.xsd',
                                             'ST'),
                                            ('InvoiceUnboundedIndexType',
                                             'invoiceBase.xsd',
                                             'ST'),
                                            ('LineNumberType',
                                             'invoiceBase.xsd',
                                             'ST'),
                                            ('MonetaryType',
                                             'invoiceBase.xsd',
                                             'ST'),
                                            ('PaymentMethodType',
                                             'invoiceBase.xsd',
                                             'ST'),
                                            ('AddressType',
                                             'invoiceBase.xsd',
                                             'CT'),
                                            ('DetailedAddressType',
                                             'invoiceBase.xsd',
                                             'CT'),
                                            ('SimpleAddressType',
                                             'invoiceBase.xsd',
                                             'CT'),
                                            ('TaxNumberType',
                                             'invoiceBase.xsd',
                                             'CT')],
 'http://schemas.nav.gov.hu/OSA/3.0/data': [('CustomerVatStatusType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('DataNameType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('EkaerIdType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('ExchangeRateType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('LineNatureIndicatorType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('LineOperationType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('MarginSchemeType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('ProductCodeCategoryType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('ProductCodeValueType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('ProductFeeMeasuringUnitType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('ProductFeeOperationType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('ProductStreamType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('QuantityType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('RateType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('TakeoverType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('UnitOfMeasureType',
                                             'invoiceData.xsd',
                                             'ST'),
                                            ('AdditionalDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('AdvanceDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('AdvancePaymentDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('AggregateInvoiceLineDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('AircraftType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('BatchInvoiceType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ContractNumbersType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ConventionalInvoiceInfoType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('CostCentersType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('CustomerCompanyCodesType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('CustomerDeclarationType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('CustomerInfoType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('CustomerTaxNumberType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('CustomerVatDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('DealerCodesType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('DeliveryNotesType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('DetailedReasonType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('DieselOilPurchaseType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('DiscountDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('EkaerIdsType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('FiscalRepresentativeType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('GeneralLedgerAccountNumbersType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('GlnNumbersType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('InvoiceDetailType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('InvoiceDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('InvoiceHeadType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('InvoiceMainType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('InvoiceReferenceType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('InvoiceType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ItemNumbersType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('LineAmountsNormalType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('LineAmountsSimplifiedType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('LineGrossAmountDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('LineModificationReferenceType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('LineNetAmountDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('LinesType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('LineType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('LineVatDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('MaterialNumbersType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('NewTransportMeanType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('OrderNumbersType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('PaymentEvidenceDocumentDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ProductCodesType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ProductCodeType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ProductFeeClauseType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ProductFeeDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ProductFeeSummaryType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ProductFeeTakeoverDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ProjectNumbersType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ReferencesToOtherLinesType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('ShippingDatesType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('SummaryByVatRateType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('SummaryGrossDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('SummaryNormalType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('SummarySimplifiedType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('SummaryType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('SupplierCompanyCodesType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('SupplierInfoType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('VatAmountMismatchType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('VatRateGrossDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('VatRateNetDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('VatRateType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('VatRateVatDataType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('VehicleType',
                                             'invoiceData.xsd',
                                             'CT'),
                                            ('VesselType',
                                             'invoiceData.xsd',
                                             'CT')],
 'http://schemas.nav.gov.hu/OSA/3.0/metrics': [('LanguageType',
                                                'serviceMetrics.xsd',
                                                'ST'),
                                               ('MetricTypeType',
                                                'serviceMetrics.xsd',
                                                'ST'),
                                               ('MetricDefinitionType',
                                                'serviceMetrics.xsd',
                                                'CT'),
                                               ('MetricDescriptionType',
                                                'serviceMetrics.xsd',
                                                'CT'),
                                               ('MetricType',
                                                'serviceMetrics.xsd',
                                                'CT'),
                                               ('MetricValueType',
                                                'serviceMetrics.xsd',
                                                'CT'),
                                               ('QueryServiceMetricsListResponseType',
                                                'serviceMetrics.xsd',
                                                'CT'),
                                               ('QueryServiceMetricsResponseType',
                                                'serviceMetrics.xsd',
                                                'CT')]}

__all__ = [
    "AdditionalDataType",
    "AdditionalQueryParamsType",
    "AddressType",
    "AdvanceDataType",
    "AdvancePaymentDataType",
    "AggregateInvoiceLineDataType",
    "AircraftType",
    "AnnulmentDataType",
    "AnnulmentOperationListType",
    "AnnulmentOperationType",
    "AuditDataType",
    "BasicHeaderType",
    "BasicOnlineInvoiceRequestType",
    "BasicOnlineInvoiceResponseType",
    "BasicRequestType",
    "BasicResponseType",
    "BasicResultType",
    "BatchInvoiceType",
    "BusinessValidationResultType",
    "ContractNumbersType",
    "ConventionalInvoiceInfoType",
    "CostCentersType",
    "CryptoType",
    "CustomerCompanyCodesType",
    "CustomerDeclarationType",
    "CustomerInfoType",
    "CustomerTaxNumberType",
    "CustomerVatDataType",
    "DateIntervalParamType",
    "DateTimeIntervalParamType",
    "DealerCodesType",
    "DeliveryNotesType",
    "DetailedAddressType",
    "DetailedReasonType",
    "DieselOilPurchaseType",
    "DiscountDataType",
    "EkaerIdsType",
    "FiscalRepresentativeType",
    "GeneralErrorHeaderResponse",
    "GeneralErrorHeaderResponseType",
    "GeneralErrorResponse",
    "GeneralErrorResponseType",
    "GeneralExceptionResponse",
    "GeneralLedgerAccountNumbersType",
    "GlnNumbersType",
    "InvoiceAnnulment",
    "InvoiceAnnulmentType",
    "InvoiceChainDigestResultType",
    "InvoiceChainDigestType",
    "InvoiceChainElementType",
    "InvoiceChainQueryType",
    "InvoiceData",
    "InvoiceDataResultType",
    "InvoiceDataType",
    "InvoiceDetailType",
    "InvoiceDigestResultType",
    "InvoiceDigestType",
    "InvoiceHeadType",
    "InvoiceLinesType",
    "InvoiceMainType",
    "InvoiceNumberQueryType",
    "InvoiceOperationListType",
    "InvoiceOperationType",
    "InvoiceQueryParamsType",
    "InvoiceReferenceDataType",
    "InvoiceReferenceType",
    "InvoiceType",
    "ItemNumbersType",
    "LineAmountsNormalType",
    "LineAmountsSimplifiedType",
    "LineGrossAmountDataType",
    "LineModificationReferenceType",
    "LineNetAmountDataType",
    "LineType",
    "LineVatDataType",
    "LinesType",
    "ManageAnnulmentRequest",
    "ManageAnnulmentRequestType",
    "ManageAnnulmentResponse",
    "ManageInvoiceRequest",
    "ManageInvoiceRequestType",
    "ManageInvoiceResponse",
    "MandatoryQueryParamsType",
    "MaterialNumbersType",
    "MetricDefinitionType",
    "MetricDescriptionType",
    "MetricType",
    "MetricValueType",
    "NewCreatedLinesType",
    "NewTransportMeanType",
    "NotificationType",
    "NotificationsType",
    "OrderNumbersType",
    "PaymentEvidenceDocumentDataType",
    "PointerType",
    "ProcessingResultListType",
    "ProcessingResultType",
    "ProductCodeType",
    "ProductCodesType",
    "ProductFeeClauseType",
    "ProductFeeDataType",
    "ProductFeeSummaryType",
    "ProductFeeTakeoverDataType",
    "ProjectNumbersType",
    "QueryInvoiceChainDigestRequest",
    "QueryInvoiceChainDigestRequestType",
    "QueryInvoiceChainDigestResponse",
    "QueryInvoiceChainDigestResponseType",
    "QueryInvoiceCheckRequest",
    "QueryInvoiceCheckResponse",
    "QueryInvoiceCheckResponseType",
    "QueryInvoiceDataRequest",
    "QueryInvoiceDataRequestType",
    "QueryInvoiceDataResponse",
    "QueryInvoiceDataResponseType",
    "QueryInvoiceDigestRequest",
    "QueryInvoiceDigestRequestType",
    "QueryInvoiceDigestResponse",
    "QueryInvoiceDigestResponseType",
    "QueryServiceMetricsListResponse",
    "QueryServiceMetricsListResponseType",
    "QueryServiceMetricsResponse",
    "QueryServiceMetricsResponseType",
    "QueryTaxpayerRequest",
    "QueryTaxpayerRequestType",
    "QueryTaxpayerResponse",
    "QueryTaxpayerResponseType",
    "QueryTransactionListRequest",
    "QueryTransactionListRequestType",
    "QueryTransactionListResponse",
    "QueryTransactionListResponseType",
    "QueryTransactionStatusRequest",
    "QueryTransactionStatusRequestType",
    "QueryTransactionStatusResponse",
    "QueryTransactionStatusResponseType",
    "ReferencesToOtherLinesType",
    "RelationQueryDateType",
    "RelationQueryMonetaryType",
    "RelationalQueryParamsType",
    "ShippingDatesType",
    "SimpleAddressType",
    "SoftwareType",
    "SummaryByVatRateType",
    "SummaryGrossDataType",
    "SummaryNormalType",
    "SummarySimplifiedType",
    "SummaryType",
    "SupplierCompanyCodesType",
    "SupplierInfoType",
    "TaxNumberType",
    "TaxpayerAddressItemType",
    "TaxpayerAddressListType",
    "TaxpayerDataType",
    "TechnicalValidationResultType",
    "TokenExchangeRequest",
    "TokenExchangeResponse",
    "TokenExchangeResponseType",
    "TransactionListResultType",
    "TransactionQueryParamsType",
    "TransactionResponseType",
    "TransactionType",
    "UserHeaderType",
    "VatAmountMismatchType",
    "VatRateGrossDataType",
    "VatRateNetDataType",
    "VatRateType",
    "VatRateVatDataType",
    "VehicleType",
    "VesselType"
]
